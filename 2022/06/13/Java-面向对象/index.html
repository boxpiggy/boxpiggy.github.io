<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png"><link rel="icon" href="/img/avatar.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Neo"><meta name="keywords" content=""><meta name="description" content="一、面向对象和面向过程的区别面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：  面向过程编程（POP）：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象编程（OOP）：面向对象会先抽象出对象"><meta property="og:type" content="article"><meta property="og:title" content="Java 面向对象"><meta property="og:url" content="https://blog-21n.pages.dev/2022/06/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html"><meta property="og:site_name" content="KingShit"><meta property="og:description" content="一、面向对象和面向过程的区别面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：  面向过程编程（POP）：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象编程（OOP）：面向对象会先抽象出对象"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8Eset%E7%BB%93%E5%90%88.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%8C%87%E5%AE%9A%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%EF%BC%88jdk1.7%E4%BB%A5%E5%89%8D%EF%BC%89.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/this%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/shallow&deep-copy.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8F%98%E9%87%8F.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/main%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%A4%BA%E4%BE%8B6-1%E7%BB%93%E6%9E%9C.png"><meta property="article:published_time" content="2022-06-13T13:45:00.000Z"><meta property="article:modified_time" content="2024-08-09T17:20:09.567Z"><meta property="article:author" content="Neo"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8Eset%E7%BB%93%E5%90%88.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>Java 面向对象 - KingShit</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"blog-21n.pages.dev",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="https://boxpiggy.github.io/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Neo&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Java 面向对象"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-06-13 21:45" pubdate>2022年6月13日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 13k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 112 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Java 面向对象</h1><div class="markdown-body"><h1 id="一、面向对象和面向过程的区别"><a href="#一、面向对象和面向过程的区别" class="headerlink" title="一、面向对象和面向过程的区别"></a>一、面向对象和面向过程的区别</h1><p>面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：</p><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>相较于 POP，OOP 开发的程序一般具有下面这些优点：</p><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><p>在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。</p><p>求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案</p><p><strong>面向对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-comment">// 定义圆的半径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算圆的面积</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算圆的周长</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPerimeter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * Math.PI * radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个半径为3的圆</span><br>        <span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">3.0</span>);<br><br>        <span class="hljs-comment">// 输出圆的面积和周长</span><br>        System.out.println(<span class="hljs-string">&quot;圆的面积为：&quot;</span> + circle.getArea());<br>        System.out.println(<span class="hljs-string">&quot;圆的周长为：&quot;</span> + circle.getPerimeter());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了一个 Circle 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。</p><p><strong>面向过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义圆的半径</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.0</span>;<br><br>        <span class="hljs-comment">// 计算圆的面积和周长</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.PI * radius * radius;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">perimeter</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * Math.PI * radius;<br><br>        <span class="hljs-comment">// 输出圆的面积和周长</span><br>        System.out.println(<span class="hljs-string">&quot;圆的面积为：&quot;</span> + area);<br>        System.out.println(<span class="hljs-string">&quot;圆的周长为：&quot;</span> + perimeter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长。</p><h1 id="二、面向对象三大特征"><a href="#二、面向对象三大特征" class="headerlink" title="二、面向对象三大特征"></a>二、面向对象三大特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><p>就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作【方法】，才能对数据进行操作</p><p><strong>步骤</strong></p><ol><li>对属性进行私有化private 【不能直接修改属性】</li><li>提供一个公共的 public set 方法，用于对属性判断并赋值 public void</li><li>提供一个公共的 public get 方法，用于获取属性的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <span class="hljs-comment">// id属性私有化</span><br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">// name属性私有化</span><br><br>    <span class="hljs-comment">//获取id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-comment">//设置id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-comment">//获取name的方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-comment">//设置name的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造器 与 set 结合</strong></p><p>将 set 方法写在构造器中，仍然可以进行数据验证</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8Eset%E7%BB%93%E5%90%88.png" srcset="/img/loading.gif" lazyload alt="构造器与set结合"></p><h2 id="继承（Extends）"><a href="#继承（Extends）" class="headerlink" title="继承（Extends）"></a>继承（Extends）</h2><p>继承可以解决代码复用。当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类无需重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承父类即可。</p><p>子类自动拥有父类定义的属性和方法。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="重要规则"><a href="#重要规则" class="headerlink" title="重要规则"></a>重要规则</h3><ol><li>子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过父类提供的公共方法去访问；</li><li>子类必须调用父类的构造器，完成对父类的初始化；</li><li>当创建子类对象时，不管使用子类哪个构造器，默认情况下总会去调用父类的无参构造器（<code>super();</code>）；（示例1）</li><li>如果父类没有无参构造器，则必须在子类的构造器中使用<code>super</code>去指定使用父类哪个构造器完成对父类的初始化工作，否则编译不通过；（示例2）</li><li>如果希望指定去调用父类的某个构造器，则显式地调用一下：<code>super(参数列表);</code></li><li><code>super</code>在使用时，必须放在构造器第一行；（<code>super</code>只能在构造器中使用）</li><li><code>super()</code> 和 <code>this()</code> 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>父类构造器的调用不限于直接父类！将一直往上追溯直到<code>Object</code>类（顶级父类）</li><li>java 是单继承机制：子类只能继承一个父类；</li><li>不能滥用继承关系，子类和父类之间必须满足 is-a 的逻辑关系。（Person is a Music? Music extends Person × Cat is a Animal? Cat extends Animal √ ）</li></ol><p><strong>示例2-1</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.png" srcset="/img/loading.gif" lazyload alt="构造器调用顺序"></p><p><strong>示例2-2</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%8C%87%E5%AE%9A%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt="指定父类构造器"></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" lazyload alt="继承内存分析"></p><p><strong>分析：</strong></p><p>（1）首先看子类是否有该属性；</p><p>（2）如果子类有，并且可以访问，则返回信息；（父类相同的属性就无法访问了）</p><p>（3）如果子类没有，就看父类有没有，如果父类有，并且可以访问，就返回信息；</p><p>（4）如果父类没有，就按照（3）的规则，继续找上级父类，知道 Object……</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>代表父类的引用，用于访问父类的属性、方法、构造器。</p><p><strong>调用父类的构造器的好处：</strong>分工明确，父类属性由父类初始化，子类属性由子类初始化。</p><p><strong>基本语法</strong></p><p>访问父类的属性（除<code>private</code>以外），<code>super.field;</code></p><p>访问父类的方法（除<code>private</code>以外），<code>super.method();</code></p><p>访问父类的构造器，<code>super(参数列表);</code> （只能放在构造器第一句，只能出现一句）</p><p><strong>重要规则</strong></p><ol><li><p>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过<code>super</code>。如果没有重名，使用<code>super</code>、<code>this</code>、直接访问是一样的效果。</p></li><li><ol><li><strong>查找同名方法和属性的规则：</strong></li><li>先找本类，如果有，则调用</li><li>如果本类没有，找上一级父类（有，并可以调用，则调用）</li><li>如果父类没有，继续往上找，直到<code>Object</code>类</li><li><code>method()</code>和<code>this.method()</code>等价遵循以上规则，<code>super.method()</code>则直接跳过本类查找父类</li></ol></li><li><p><code>super</code>的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名成员，则遵循就近原则。</p></li></ol><p><strong>super 和 this 的比较</strong></p><table><thead><tr><th></th><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>1</td><td>访问属性</td><td>访问本类中的属性，如果本类没有此属性，则从父类中继续查找</td><td>从父类开始查找属性</td></tr><tr><td>2</td><td>调用方法</td><td>访问本类中的方法，如果本类没有此方法，则从父类中继续查找</td><td>从父类开始查找方法</td></tr><tr><td>3</td><td>调用构造器</td><td>调用本类构造器，必须放在构造器首行</td><td>调用父类构造器，必须放在子类构造器首行</td></tr><tr><td>4</td><td>特殊</td><td>表示当前对象</td><td>子类中访问父类对象</td></tr></tbody></table><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>方法或对象具有多种形态</p><ol><li><p>方法的多态：方法重写和重载就体现多态</p></li><li><p>对象的多态（核心）：</p></li><li><ol><li>一个对象的编译类型和运行类型可以不一致； 如：<code>Animal animal = new Dog();</code></li><li>编译类型在定义对象时，就确定了，不能改变；</li><li>运行类型是可以变化的，可通过<code>getClass()</code>查看运行类型；</li><li>编译类型看定义时<code>=</code>号的左边，运行类型看<code>=</code>号的右边</li></ol></li></ol><h3 id="多态的特点"><a href="#多态的特点" class="headerlink" title="多态的特点"></a>多态的特点</h3><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p><strong>本质：</strong>父类的引用指向了子类的对象</p><p><strong>语法：</strong><code>父类类型 引用名 = new 子类类型();</code></p><p><strong>向上转型调用方法的规则如下：</strong></p><ol><li>可以调用父类中的所有成员（遵守访问权限）；不能调用子类中的特有成员；</li><li>在<strong>编译期</strong>，只能调用父类中声明的方法，但在<strong>运行期</strong>，实际执行的是子类重写父类的方法；</li><li>在编译阶段，能调用哪些成员，是由编译类型来决定的（编译器）；</li><li>最终运行效果看子类的具体实现。</li></ol><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;动物&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;sleep&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;run&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;eat&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;cat eat fish&quot;</span>);&#125;  <span class="hljs-comment">//重写eat方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;cat catch mouse&quot;</span>);&#125;  <span class="hljs-comment">//Cat类特有的catchMouse方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        animal.eat();  <span class="hljs-comment">//输出：cat eat fish</span><br>        animal.run();  <span class="hljs-comment">//输出：run</span><br>        animal.show();  <span class="hljs-comment">//输出：hello</span><br>        animal.sleep();  <span class="hljs-comment">//输出：sleep</span><br>        animal.catchMouse();  <span class="hljs-comment">//报错，因为在编译阶段，能调用哪些成员，是由编译类型来决定的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>语法：<code>子类类型 引用名 = (子类类型)父类引用;</code></p><ol><li>只能强转父类的引用，不能强转父类的对象；</li><li>要求父类的引用必须指向的是当前目标类型的对象；</li><li>当向下转型后，可以调用子类类型中所有的成员。</li></ol><p>编译类型和运行类型不一致才需要向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//续上示例3</span><br><span class="hljs-comment">//若要调用Cat的 catchMouse方法</span><br><span class="hljs-comment">//向下转型</span><br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal;<br>cat.catchMouse();  <span class="hljs-comment">//输出：cat catch mouse</span><br></code></pre></td></tr></table></figure><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><ol><li><strong>属性</strong>没有重写之说，属性的值看<strong>编译类型</strong>。（示例4）</li></ol><p><strong>示例4</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Base</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>        System.out.println(base.count);  <span class="hljs-comment">//输出 10</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; &#125;<br></code></pre></td></tr></table></figure><ol><li><code>instanceof</code> 比较操作符：用于判断对象的运行类型，是否为XX类型或者XX类的子类型。（示例5）</li></ol><p><strong>示例5</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//续上（示例4）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Sub</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>        System.out.println(sub <span class="hljs-keyword">instanceof</span> Sub);  <span class="hljs-comment">//true</span><br>        System.out.println(sub <span class="hljs-keyword">instanceof</span> Base);  <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><ol><li>当调用对象<strong>方法</strong>时，该方法会和该对象的内存地址&#x2F;运行类型绑定</li><li>当调用对象<strong>属性</strong>时，没有动态绑定机制，哪里声明，哪里使用。</li></ol><p><strong>示例6</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicBinding</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        System.out.println(a.sum());  <span class="hljs-comment">// 30</span><br>        System.out.println(a.sum1());  <span class="hljs-comment">// 20</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getI() + <span class="hljs-number">10</span>;  <span class="hljs-comment">//调用运行类型的 getI() 方法 </span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//先找局部变量，局部变量没有i，再找属性，属性有则返回 i+10=&gt;10+10</span><br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">10</span>;  <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">//public int sum() &#123;</span><br>    <span class="hljs-comment">//    return i + 20;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">//属性没有动态绑定机制，哪里声明就使用哪里的，使用的是B类的属性i = 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h3><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</p><p><strong>示例7</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// Student对象 和 Teacher对象，统一放在数组中，并调用每个对象的say方法</span><br>    Person[] persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[<span class="hljs-number">3</span>];<br>    persons[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">20</span>);<br>    persons[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;shit&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-number">99</span>);<br>    persons[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;boxpig&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20000</span>);<br><br>    <span class="hljs-comment">//循环遍历多态数组，调用say</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; persons.length; i++) &#123;<br>        <span class="hljs-comment">//persons[i] 编译类型是Person，运行类型是根据实际情况由JVM判断</span><br>        System.out.println(persons[i].say());  <span class="hljs-comment">//动态绑定机制</span><br>        <span class="hljs-comment">// 使用类型判断+向下转型</span><br>        <span class="hljs-comment">// 判断persons[i] 的运行类型是不是Student</span><br>        <span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Student) &#123;  <br>            <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) persons[i];  <span class="hljs-comment">//向下转型</span><br>            student.study();<br>            <span class="hljs-comment">//以上等价于 ((Student) persons[i]).study();</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (persons[i] <span class="hljs-keyword">instanceof</span> Teacher)&#123;<br>            ((Teacher) persons[i]).teach();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;你的类型有误...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p>方法定义的形参类型为父类类型，实参类型允许为子类类型。</p><h1 id="三、接口与抽象类"><a href="#三、接口与抽象类" class="headerlink" title="三、接口与抽象类"></a>三、接口与抽象类</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名 &#123;<br>    <span class="hljs-comment">//属性 总是(自带) public static final</span><br>    <span class="hljs-comment">//方法（ 1.抽象方法   2.默认实现方法   3.静态方法 ）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//接口中的抽象方法，public abstract可以省略</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;我是默认实现方法&quot;</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;我是静态方法&quot;</span>); &#125;<br>&#125;<br><br>class 类名 implements 接口 &#123;<br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-comment">//必须实现的接口的抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认方法和静态方法是 jdk8 新增，jdk7 以前接口内所有方法均无方法体，即都是抽象方法。</li><li>接口中的<strong>方法</strong>会被隐式的指定为 <code>public abstract</code></li><li>接口中的<strong>变量</strong>会被隐式的指定为 <code>public static final</code> 变量</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>由于自带<code>static</code>，接口中属性的访问语法：<code>接口名.属性名</code></li><li>一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是<code>public</code>；（IDEA快捷键：ctrl+i 或 alt shift enter）</li><li>抽象类实现接口，可以不用实现抽象方法；</li><li>接口支持多继承；（一个接口不能继承其他类，但是可以继承多个别的接口）</li><li>一个类可以同时实现多个接口；</li><li>接口的修饰符只能是 public 和 默认，这点和类一样。</li></ul><h3 id="为什么需要接口？"><a href="#为什么需要接口？" class="headerlink" title="为什么需要接口？"></a>为什么需要接口？</h3><ul><li>接口比抽象类还要抽象，可以更加规范地对子类进行约束，全面地实现了：规范和具体实现的分离。</li><li>接口就是规范，定义的是一组规则。本质是契约。</li><li>项目的具体需求是多变的，开发要以不变（规范）应万变。因此开发项目往往都是面向接口编程。</li></ul><p><strong>实现类可以不必覆写</strong><code>**default**</code><strong>方法。</strong><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><h3 id="接口的多态性"><a href="#接口的多态性" class="headerlink" title="接口的多态性"></a>接口的多态性</h3><p>接口引用可以指向实现了该接口的对象实例。</p><p>示例3-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IF</span> <span class="hljs-variable">if01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();    <span class="hljs-comment">//接口类型的变量 if01 可以指向 实现了IF接口的对象实例</span><br>        <span class="hljs-type">IF</span> <span class="hljs-variable">if02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>示例3-2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Camera</span> <span class="hljs-variable">camera</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        <span class="hljs-comment">//把手机、相机对象接入计算机</span><br>        computer.work(camera);<br>        computer.work(phone);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br>    <span class="hljs-comment">//1. UsbInterface usbInterface 形参是接口类型 UsbInterface</span><br>    <span class="hljs-comment">//2. 可以接收（实现了UsbInterface接口的类的）对象实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(UsbInterface usbInterface)</span> &#123;<br>        <span class="hljs-comment">//通过接口来调用方法</span><br>        usbInterface.start();<br>        usbInterface.stop();    <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//USB接口，规定接口的相关规范（方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//手机实现USB接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//相机实现USB接口</span><br></code></pre></td></tr></table></figure><p>示例3-3（多态数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//多态数组 -&gt; 接口类型数组</span><br>        Usb[] usbs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Usb</span>[<span class="hljs-number">2</span>];<br>        usbs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        usbs[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        <span class="hljs-comment">//输出数组对象的方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; usbs.length; i++) &#123;<br>            usbs[i].work();  <span class="hljs-comment">//动态绑定...</span><br>            <span class="hljs-keyword">if</span> (usbs[i] instance of Phone) &#123;  <span class="hljs-comment">//判断运行类型是否为Phone，是才调用手机特有的call方法</span><br>                ((Phone) usbs[i]).call();  <span class="hljs-comment">//向下转型            </span><br>            &#125;        <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Usb</span>&#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>; &#125;  <span class="hljs-comment">//usb接口，规定了work方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;手机可以打电话&quot;</span>); &#125;  <span class="hljs-comment">//手机特有的call方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;手机工作中...&quot;</span>); &#125;  <span class="hljs-comment">//实现手机的work方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;相机工作中...&quot;</span>); &#125;  <span class="hljs-comment">//实现相机的work方法</span><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>手机工作中...<br>手机可以打电话<br>相机工作中...<br></code></pre></td></tr></table></figure><p>接口的多态传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfacePolyPass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 接口类型的变量 可以指向 实现了该接口的类的对象</span><br>        <span class="hljs-type">IA</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>        <span class="hljs-comment">// 如果IB继承了IA接口，而Apple类实现了IB接口，那实际上相当于Apple类也实现了IA接口</span><br>        <span class="hljs-type">IB</span> <span class="hljs-variable">ib</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IA</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IB</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>没有任何方法的接口被称为标记接口。</p><p>标记接口是计算机科学中的一种设计思路，用于给那些面向对象的编程语言描述对象。因为编程语言本身并不支持为类维护元数据，而标记接口可以用作描述类的元数据，弥补了这个功能上的缺失。对于实现了标记接口的类，我们就可以在运行时通过反射机制去获取元数据。</p><p>以<code>Serializable</code>接口为例，如果一个类实现了这个接口，则表示这个类可以被序列化。因此，我们实际上是通过了<code>Serializable</code>这个接口给该类标记了【可被序列化】的元数据，打上了【可被序列化】的标签。这也是标记&#x2F;标签接口名字的由来。</p><p>在Java中，标记接口主要有以下两种目的：</p><ol><li>建立一个公共的父接口。比如<code>EventListener</code>接口，一个由几十个其它接口扩展的Java API，当一个接口继承了EventListener接口，Java虚拟机（JVM）就知道该接口将要被用于一个事件的代理方案。同样的，你可以使用一个标记接口来建立一组接口的父接口。</li><li>向一个类添加数据类型。这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法（因为标记接口根本就没有方法），但是该类通过 Java 的<strong>多态性</strong>可以变成一个接口类型。</li></ol><p>更多的，一些容器例如 Ejb 容器，Servlet 容器或运行时环境依赖标记接口识别类是否需要进行某种处理，比如<code>Serialialbe</code>接口标记类需要进行序列化操作。</p><p>当然了，在现在 Spring 流行的时代，注解（Annotation）已经成为了最好的维护元数据的方式。因为注解能声明在包、类、字段、方法、局部变量、方法参数等之上，既灵活又方便地起到维护元数据的目的。</p><h3 id="Java-8-新增"><a href="#Java-8-新增" class="headerlink" title="Java 8 新增"></a>Java 8 新增</h3><p>Java 8 引入的<code>default</code>方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method in the interface.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 8 引入的<code>static</code>方法无法在实现类中被覆盖，只能通过接口名直接调用（ <code>MyInterface.staticMethod()</code>），类似于类中的静态方法。<code>static</code>方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method in the interface.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 9 允许在接口中使用 <code>private</code> 方法。<code>private</code>方法可以用于在接口内部共享代码，不对外暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-comment">// default 方法</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        commonMethod();<br>    &#125;<br><br>    <span class="hljs-comment">// static 方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        commonMethod();<br>    &#125;<br><br>    <span class="hljs-comment">// 私有静态方法，可以被 static 和 default 方法调用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commonMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a private method used internally.&quot;</span>);<br>    &#125;<br><br>      <span class="hljs-comment">// 实例私有方法，只能被 default 方法调用。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceCommonMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a private instance method used internally.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>是一种模板模式。抽象类为所有子类提供一个通用模板，子类可以在这个模板的基础上进行扩展。</p><p>通过抽象类，可以避免子类设计的随意性。通过抽象类，严格限制子类的设计，使子类之间更加通用。</p><p>抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>有抽象方法的类只能定义为抽象类，抽象类不一定包含抽象方法；</li><li>抽象类不能实例化，即不能用<code>new</code>来实例化抽象类；</li><li>抽象类可以有任何成员（属性、方法、构造方法）【抽象类本质还是类】，但是构造方法不能用来new实例，只能用来被子类调用；</li><li>抽象类只能用来继承；</li><li>如果一个类继承了抽象类，则它必须<strong>实现</strong>抽象类的<strong>所有</strong>抽象方法，除非也声明为抽象类。即抽象方法必须被子类实现。</li><li>抽象方法不能有主体，即不能实现；（不能有{大括号}）</li><li>抽象方法不能用<code>private</code>、<code>final</code>和<code>static</code>来修饰，因为这些关键字都是和重写相违背。</li></ul><h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>把方法的设计与实现分离</p><p>设计：这个类有什么方法、方法的声明（方法名、返回值、形参）</p><p>实现：具体的方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-comment">//抽象类</span><br>    String str; <span class="hljs-comment">//可定义属性</span><br>    <span class="hljs-comment">// 抽象方法，不定义run()方法 (加abstract关键字，不要大括号&#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>; <br><br>    <span class="hljs-comment">// 可定义普通方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;呼吸&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 可以定义构造方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;创造一个动物&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本质是：</p><ul><li>上层代码只定义规范（例如：abstract class Person）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>需求：</strong></p><ol><li>有多个类，完成不同的任务job</li><li>要求统计得到各自完成任务的时间</li></ol><p><strong>设计一个抽象类（Template），能完成如下功能：</strong></p><ol><li>编写方法<code>calculateTime()</code>，可以计算某段代码的耗时时间</li><li>编写抽象方法<code>job()</code></li><li>编写一个子类<code>Sub</code>，继承抽象类<code>Template</code>，并实现<code>job</code>方法</li><li>编写一个测试类<code>TestTemplate</code>进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类//抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span> &#123;  <br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-comment">//实现方法，调用job方法，统计job方法的耗时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateTime</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//得到开始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        job();  <span class="hljs-comment">//动态绑定机制</span><br><br>        <span class="hljs-comment">//得到结束时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;任务执行时间：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//子类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ajob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;<br>    <span class="hljs-comment">//计算任务A</span><br>    <span class="hljs-comment">//1+2+3+...+100000</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//实现了父类Template的抽象方法job</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000000</span>; i++) &#123;<br>            num += i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//子类B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bjob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;<br>    <span class="hljs-comment">//计算任务B</span><br>    <span class="hljs-comment">//1*2*3*...*800000</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">800000</span>; i++) &#123;<br>            num *= i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类和接口的异同点"><a href="#抽象类和接口的异同点" class="headerlink" title="抽象类和接口的异同点"></a>抽象类和接口的异同点</h2><p>接口和抽象类的共同点</p><p><strong>实例化</strong>：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</p><p><strong>抽象方法</strong>：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</p><p>接口和抽象类的区别</p><p><strong>设计目的</strong>：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p><p><strong>继承和实现</strong>：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。</p><p><strong>成员变量</strong>：接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（private, protected, public），可以在子类中被重新定义或赋值。</p><p><strong>方法</strong>：</p><ul><li>Java 8 之前，接口中的方法默认是 <code>public abstract</code> ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 default（默认） 方法和 static （静态）方法。 自 Java 9 起，接口可以包含 private 方法。</li><li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li></ul><h1 id="四、类与对象"><a href="#四、类与对象" class="headerlink" title="四、类与对象"></a>四、类与对象</h1><h2 id="类与对象关系"><a href="#类与对象关系" class="headerlink" title="类与对象关系"></a>类与对象关系</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt="类与对象的关系"></p><h2 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a>属性&#x2F;成员变量</h2><ol><li>从概念或叫法上看：成员变量 &#x3D; 属性 &#x3D; 字段（field）。</li><li>属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象、数组）。</li><li>属性的定义语法：访问修饰符 属性类型 属性名 示例：<code>protected String name;</code>。</li><li>属性的定义类型可以为任意类型，包括基本类型和引用类型。</li><li>属性如果没有赋值，有默认值，规则和数组一致：int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u0000, boolean false, String null;</li></ol><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><ol><li>先声明后创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Cat cat;<br>cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><ul><li>对象名 cat 在栈指向一个空的空间</li><li>在堆开辟空间，同时分配地址（只要有数据空间，就会有地址），把地址赋给 cat 对象名</li></ul><ol><li>直接创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>先在<strong>方法区</strong>加载<code>Cat</code>类信息（<strong>属性</strong>和<strong>方法</strong>信息，只会加载一次）；</li><li>在堆中分配空间，进行默认初始化；</li><li>把地址赋给<code>whiteCat</code>，<code>whiteCat</code>就指向对象；</li><li>进行指定初始化，比如 <code>whiteCat.name = &quot;小白&quot;;</code> <code>whiteCat.age = 6;``whiteCat.color = &quot;white&quot;;</code></li></ol><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" srcset="/img/loading.gif" lazyload alt="类与对象的内存布局"></p><p><strong>⚠</strong> <strong>JDK1.7 ，字符串常量池和静态变量从永久代（方法区）移动了 Java 堆中</strong></p><p>永久代是方法区的具体实现，和堆一样都是由 JVM 管理的运行时数据区域，但堆有更高的 GC 回收效率，因此把需要大量进行字符串回收的字符串常量池移到堆中。</p><p>JDK1.8 ，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存，不受 JVM 内存的限制。</p><p>详见：<a target="_blank" rel="noopener" href="https://www.yuque.com/kingshit/java/crf342hk3xb326g3">Java内存区域详解</a></p><h3 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h3><p><strong>栈</strong>：一般存放基本数据类型（局部变量）</p><p><strong>堆</strong>：存放对象（Cat cat，数组等）</p><p><strong>方法区</strong>：常量池（常量，比如字符串），类加载信息</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%EF%BC%88jdk1.7%E4%BB%A5%E5%89%8D%EF%BC%89.png" srcset="/img/loading.gif" lazyload alt="类与对象内存分配机制（jdk1.7以前）"></p><h3 id="对象创建的流程分析"><a href="#对象创建的流程分析" class="headerlink" title="对象创建的流程分析"></a>对象创建的流程分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" lazyload alt="对象创建的流程分析"></p><p>jdk 1.7以前</p><p><strong>流程分析：</strong></p><ol><li>加载类信息（Xxx.class），只会加载一次</li><li>在堆中分配空间（地址）</li><li>完成对象初始化（默认初始化、显式初始化、构造器初始化）</li><li>把对象在堆中的地址返回给对象的引用（对象名）</li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="方法调用机制"><a href="#方法调用机制" class="headerlink" title="方法调用机制"></a>方法调用机制</h3><p>方法执行会开辟一个独立的栈空间，方法执行完毕该空间就会释放。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt="方法调用机制"></p><center>（jdk 1.7以前）</center><p><strong>同一类中的方法调用</strong>：直接调用</p><p><strong>跨类中的方法调用</strong>：需要先创建对象，通过对象名调用</p><h3 id="成员方法的定义"><a href="#成员方法的定义" class="headerlink" title="成员方法的定义"></a>成员方法的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">访问修饰符 返回数据类型 方法名(形参列表...)&#123;  <span class="hljs-comment">// 方法体</span><br>    语句；<br>    返回值；<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>访问修饰符：控制方法使用的范围，public、protected、默认（不写）、private</p></li><li><p>形参列表：表示成员方法输入 ；</p></li><li><ol><li>可以有0或多个参数，用逗号分隔；</li><li>参数类型可以为任意类型，包括基本和引用类型；</li><li>调用带参数的方法时，一定要对应着参数列表传入相同类型或兼容类型的参数；</li><li>方法定义时的参数成为形式参数（形参&#x2F;虚参）；方法调用时传入的参数成为实际参数（实参）；实参和形参的类型要一致或兼容，个数、顺序也要一致；</li></ol></li><li><p>返回数据类型：表示成员方法输出，void 表示没有返回值：</p></li><li><ol><li>一个方法最多有一个返回值；（如果要返回多个值，可以声明数组类型）</li><li>返回类型可以为任意类型，包括基本和引用类型；</li><li>如果方法声明了返回数据类型，则方法体中最后的执行语句必须为 return 值；而且要求返回值类型必须和return的值类型一致或兼容</li><li>如果方法是 void，不能有返回值，方法体中可以没有 return 语句，或者只写 return；</li></ol></li><li><p>方法体：表示为了实现某一功能代码块；</p></li><li><ol><li>写完成功能的具体语句，可以为输入输出、变量、运算、分支、循环、方法调用等，但不能再定义方法，即方法不能嵌套定义。</li></ol></li><li><p><code>return</code> 语句不是必须的。</p></li></ol><h3 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p><code>AA</code>类中编写一个方法<code>swap</code>，接收两个整数，在方法中交换两个数，主方法中声明两个数，调用<code>swap</code>方法，看两数是否发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>        <span class="hljs-type">AA</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>();<br>        aa.swap(a, b);<br>        System.out.println(<span class="hljs-string">&quot;main方法：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:8, b:24</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a和b交换前：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:8, b:24</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>        a = b;<br>        b = tmp;<br>        System.out.println(<span class="hljs-string">&quot;a和b交换后：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:24, b:8</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong>基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt="基本数据类型传参机制"></p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>B类中编写一个方法test100，可以接收一个数组，在方法中修改该数组，看原数组是否变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BB</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BB</span>();<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        bb.test100(arr);<br>        <span class="hljs-comment">// 打印数组</span><br>        System.out.println(<span class="hljs-string">&quot;main中的数组：&quot;</span>);  <span class="hljs-comment">// 100 2 3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test100</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;test100中的数组：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong>引用类型，传递的是地址（其实传递也是值，但值是地址），可以通过形参影响实参</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt="引用类型传参机制"></p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>JVM 会给每个对象分配<code>this</code>，代表当前对象。</p><p>简单的说，哪个对象调用，<code>this</code>就代表哪个对象。</p><p><strong>示例</strong></p><p>由于 java 是在虚拟机上跑的，地址是虚拟机的地址，无法直接获取对象的地址。</p><p><code>hashCode()</code>方法会针对不同对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThisTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;皮蛋&quot;</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// 输出dog1对象的哈希值（根据对象内部地址转换）</span><br>        System.out.println(<span class="hljs-string">&quot;dog1 的 hashCode= &quot;</span> + dog1.hashCode());<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;皮球&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 输出dog2对象的哈希值</span><br>        System.out.println(<span class="hljs-string">&quot;dog2 的 hashCode= &quot;</span> + dog2.hashCode());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">27</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">// 构造器</span><br>        <span class="hljs-comment">// 把构造方法的实参赋给属性</span><br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">//this.name 就是当前对象的属性name</span><br>        <span class="hljs-built_in">this</span>.age = age;   <span class="hljs-comment">//this.age 就是当前对象的属性age</span><br>        <span class="hljs-comment">// 测试：当调用构造器初始化对象的时候，输出当前this的哈希值</span><br>        System.out.println(<span class="hljs-string">&quot;this.hashCode= &quot;</span> + <span class="hljs-built_in">this</span>.hashCode());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 成员方法，输出属性x信息</span><br>        System.out.println(name + <span class="hljs-string">&quot;\t&quot;</span> + age + <span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" srcset="/img/loading.gif" lazyload alt="输出结果"></p><p>由于<code>this</code>指向当前对象，因此<code>this</code>的地址与当前对象地址相同</p><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/this%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" lazyload alt="this内存分析"></p><p>jdk 1.7以前</p><p>可以简单理解成（虽然现实可能不会这样）：在对象创建完成后，在堆内隐藏了一个this属性，指向对象本身。</p><h3 id="this-用法"><a href="#this-用法" class="headerlink" title="this 用法"></a>this 用法</h3><ol><li><code>this</code>关键字可以用来访问本类的属性、方法、构造器；</li><li><code>this</code>用于区分当前类的属性和局部变量；</li><li>访问成员方法的语法：<code>this.方法名(参数列表);</code></li><li>访问构造器语法：<code>this(参数列表);</code> 注意只能在构造器中使用（即只能在构造器中访问另一个构造器），并只能放置在第一条语句；</li><li><code>this</code>不能在类定义的外部使用，只能在类定义的方法中使用。</li></ol><h1 id="五、深拷贝和浅拷贝？什么是引用拷贝？"><a href="#五、深拷贝和浅拷贝？什么是引用拷贝？" class="headerlink" title="五、深拷贝和浅拷贝？什么是引用拷贝？"></a>五、深拷贝和浅拷贝？什么是引用拷贝？</h1><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝的示例代码如下，我们这里实现了<code>Cloneable</code>接口，并重写了<code>clone()</code>方法。</p><p><code>clone()</code>方法的实现很简单，就是直接调用的是父类<code>Object</code>的<code>clone()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Address) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-keyword">return</span> person;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// true</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code>的克隆对象和<code>person1</code>使用的仍然是同一个<code>Address</code> 对象。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>简单对<code>Person</code>类的<code>clone()</code>方法进行修改，连带着要把<code>Person</code>对象内部的<code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        person.setAddress(person.getAddress().clone());<br>        <span class="hljs-keyword">return</span> person;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// false</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出，显然<code>person1</code>的克隆对象和<code>person1</code>包含的<code>Address</code>对象已经是不同的了。</p><h2 id="什么是引用拷贝？"><a href="#什么是引用拷贝？" class="headerlink" title="什么是引用拷贝？"></a>什么是引用拷贝？</h2><p>简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/shallow&deep-copy.png" srcset="/img/loading.gif" lazyload alt="shallow&amp;deep-copy"></p><h1 id="六、static类变量和类方法"><a href="#六、static类变量和类方法" class="headerlink" title="六、static类变量和类方法"></a>六、<code>static</code>类变量和类方法</h1><h2 id="6-1-静态变量（类变量）"><a href="#6-1-静态变量（类变量）" class="headerlink" title="6.1 静态变量（类变量）"></a>6.1 静态变量（类变量）</h2><p>当我们需要让某个类的所有对象都共享一个变量时，就可以使用。比如：定义学生类，统计所有学生共交多少钱。</p><h3 id="6-1-1-基本概念"><a href="#6-1-1-基本概念" class="headerlink" title="6.1.1 基本概念"></a>6.1.1 基本概念</h3><p><strong>类变量</strong>也叫<strong>静态变量&#x2F;静态属性</strong>，是该类所有对象共享的变量。任何一个该类的对象去访问或修改它时，取到的和修改的都是同一个变量。</p><h3 id="6-1-2-语法"><a href="#6-1-2-语法" class="headerlink" title="6.1.2 语法"></a>6.1.2 语法</h3><p>定义：<code>访问修饰符 static 数据类型 变量名;</code> 【推荐】 或 <code>static 访问修饰符 数据类型 变量名</code></p><p>访问：<code>类名.类变量名</code> 【推荐】或 <code>对象名.类变量名</code></p><h3 id="6-1-3-类变量特点"><a href="#6-1-3-类变量特点" class="headerlink" title="6.1.3 类变量特点"></a>6.1.3 类变量特点</h3><ol><li><code>static</code>变量是同一个类所有对象共享；</li><li><code>static</code>变量是随着类的加载而创建，只执行一次，所以没有创建对象实例也可以访问。</li><li>类变量的访问，也必须遵守相关访问权限</li><li>类变量的生命周期随着类的加载开始，随着类的消亡而销毁。</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8F%98%E9%87%8F.png" srcset="/img/loading.gif" lazyload alt="类变量"></p><p>jdk 1.7以前（from hsp）</p><blockquote><p><strong>2024-8-3更正上图</strong>：</p><p>方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。而<strong>字符串常量池</strong>、<strong>静态变量</strong> JDK1.7 开始就从永久代（即方法区）移动到了 Java 堆中。（上图的静态域，按我理解是存储静态变量的区域）</p><p>![JDK 1.7](<a target="_blank" rel="noopener" href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK</a> 1.7.png)</p></blockquote><h2 id="6-2-静态方法（类方法）"><a href="#6-2-静态方法（类方法）" class="headerlink" title="6.2 静态方法（类方法）"></a>6.2 静态方法（类方法）</h2><p><strong>类方法</strong>也叫<strong>静态方法</strong>。实际开发往往将一些通用的方法设计成静态方法，这样就不需要创建对象就可以使用，提高开发效率。</p><h3 id="6-2-1-语法"><a href="#6-2-1-语法" class="headerlink" title="6.2.1 语法"></a>6.2.1 语法</h3><p>定义：<code>访问修饰符 static 数据返回类型 方法名() &#123; &#125;</code></p><p>调用：<code>类名.类方法名</code> 或 <code>对象名.类方法名</code></p><p>特点</p><ol><li><p>静态方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：</p></li><li><ol><li>静态方法中无this参数；</li><li>普通方法中隐含this参数</li></ol></li><li><p>静态方法可以通过类名调用，也可以通过对象名调用</p></li><li><p>静态方法不中允许使用和对象相关的关键字，比如<code>this</code>和<code>super</code>。</p></li><li><p><strong>静态方法</strong>只能访问静态成员；<strong>普通成员</strong>方法可以访问静态成员和非静态成员。</p></li></ol><h2 id="6-3-main方法"><a href="#6-3-main方法" class="headerlink" title="6.3 main方法"></a>6.3 main方法</h2><p>1）<code>main</code>方法是虚拟机（JVM）调用；</p><p>2）JVM 需要调用类得<code>main()</code>方法，所以该方法得访问权限必须是<code>public</code>；</p><p>3）JVM 在执行<code>main()</code>方法时不必创建对象，所以该方法必须是<code>static</code>；</p><p>4）该方法接收<code>String</code>类型得数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数；</p><p>5）命令：<code>java 运行的类名 arg1 arg2 arg3</code>；</p><p>6）<code>main</code>方法遵循静态方法规则。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/main%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82.png" srcset="/img/loading.gif" lazyload alt="main方法传参"></p><p>示例6-1：（idea中)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个参数：&quot;</span> + args[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%A4%BA%E4%BE%8B6-1%E7%BB%93%E6%9E%9C.png" srcset="/img/loading.gif" lazyload alt="示例6-1结果"></p><h1 id="七、代码块"><a href="#七、代码块" class="headerlink" title="七、代码块"></a>七、代码块</h1><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><ul><li><strong>代码块（Code block）</strong>又称为<strong>初始化块</strong>，属于类中的成员【即是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过<code>&#123;&#125;</code>包围起来。</li><li>和方法不同，代码块没有方法名、返回、参数，只有方法体。</li><li>不用通过对象或类显示调用，而是加载类的时候，或创建对象时隐式调用。</li></ul><h2 id="7-2-基本语法"><a href="#7-2-基本语法" class="headerlink" title="7.2 基本语法"></a>7.2 基本语法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[ 修饰符 ] &#123; 代码 &#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>使用<code>static</code>修饰叫<strong>静态代码块</strong>，使用<code>Synchronized</code>修饰叫<strong>同步代码块</strong>；</li><li>分号（<code>;</code>）可以省略。</li></ol><h2 id="7-3-分类"><a href="#7-3-分类" class="headerlink" title="7.3 分类"></a>7.3 分类</h2><p>根据其位置和声明的不同，可以分为：</p><ul><li>局部代码块</li><li>构造代码块</li><li>同步代码块</li><li>静态代码块</li></ul><h3 id="7-3-1-局部代码块"><a href="#7-3-1-局部代码块" class="headerlink" title="7.3.1 局部代码块"></a>7.3.1 局部代码块</h3><p>在方法中出现，可以限定变量生命周期，及早释放，提高内存利用率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 局部代码块</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(number);<br>    &#125;<br>    <span class="hljs-comment">// 找不到number变量</span><br>    <span class="hljs-comment">// System. out.println(number);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-2-构造代码块"><a href="#7-3-2-构造代码块" class="headerlink" title="7.3.2 构造代码块"></a>7.3.2 构造代码块</h3><ul><li>在类中方法外出现，每次调用构造方法都会执行，并且在构造方法前执行。</li><li>相当于另外一种形式的构造器（堆构造器的补充机制），可以做初始化操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlock</span> &#123;<br>    <span class="hljs-comment">// 构造代码块，在方法外出现</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;number1: &quot;</span> + number1);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeBlock</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在构造方法后出现，但构造代码块优先于构造方法执行</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;number2: &quot;</span> + number2);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//构造代码块测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">codeBlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-comment">// 注意：构造代码块通过构造方法自动调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">number1: <span class="hljs-number">10</span><br>number2: <span class="hljs-number">100</span><br>这是构造方法<br></code></pre></td></tr></table></figure><p>因此，构造代码块依赖于构造方法，而且优先于构造方法执行。即实例对象建立，才会运行构造代码块，类不能调用构造代码块。</p><p><strong>构造代码块与构造函数的区别：</strong>构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。</p><p>也就是说，<strong>构造代码块中定义的是不同对象共性的初始化内容</strong>。如果多个构造器中都有重复的语句，可以抽取到构造初始化块中，提高代码的重用性。</p><h3 id="7-3-3-同步代码块"><a href="#7-3-3-同步代码块" class="headerlink" title="7.3.3 同步代码块"></a>7.3.3 同步代码块</h3><p>被 Java 中<code>Synchronized</code>关键词修饰的代码块。</p><blockquote><p><code>Synchronized</code>关键词不仅仅可以用来修饰代码块，与此同时也可以用来修饰方法，是一种线程同步机制，被<code>Synchronized</code>关键词修饰的代码块会被加上内置锁。</p></blockquote><p><strong>作用：</strong>在很多场景，我们没有必要去同步整个方法，而只需要同步部分代码即可，也就是使用同步代码块（JDK源码中有很多应用）。</p><p><code>Synchronized</code>同步代码块是一种高开销的操作，因此我们应该尽量减少被同步的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (CodeBlock.class) &#123;<br>            System.out.print(<span class="hljs-string">&quot;同步代码块!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，静态代码是属于类而不是属于对象的，因此使用<code>Synchronized</code>来修饰静态方法和静态对象的时候，类下的所有对象都会被锁定。</p><h3 id="7-3-4-静态代码块"><a href="#7-3-4-静态代码块" class="headerlink" title="7.3.4 静态代码块"></a>7.3.4 静态代码块</h3><p>使用<code>static</code>修饰的代码块，在类中方法外出现。</p><ul><li>随着<strong>类的加载</strong>而执行，并且只会<strong>执行一次</strong>。</li><li>静态块优先于各种代码块以及构造函数。</li><li>此外静态代码块不能访问普通变量，只能直接调用静态成员。</li></ul><p><strong>作用：</strong>对类进行初始化。</p><p><strong>类什么时候被加载？</strong></p><ol><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时（静态属性、静态方法）</li></ol><h2 id="7-4-执行顺序"><a href="#7-4-执行顺序" class="headerlink" title="7.4 执行顺序"></a>7.4 执行顺序</h2><p><strong>执行时机</strong></p><ul><li><strong>静态代码块</strong>：在类加载到JVM时初始化，且只被执行一次。</li><li><strong>构造代码块</strong>：在创建实例时，会被隐式的调用。每创建一次（每调用构造方法），构造代码块就会执行一次，构造代码块执行的顺序优先于构造器。</li></ul><h3 id="7-4-1-一个类中代码块执行顺序"><a href="#7-4-1-一个类中代码块执行顺序" class="headerlink" title="7.4.1 一个类中代码块执行顺序"></a>7.4.1 一个类中代码块执行顺序</h3><p>创建一个对象时，在一个类调用顺序是：</p><ol><li>执行静态代码块和静态属性的初始化；</li><li>执行构造代码块和普通属性的初始化；</li><li>执行构造方法；</li></ol><blockquote><p>代码块和属性初始化执行优先级一样，若有多个则按照代码定义顺序执行。</p></blockquote><p><strong>总结</strong></p><p><strong>加载类信息</strong>（加载静态代码块和静态属性初始化） -&gt; <strong>创建对象</strong>（加载普通代码块和普通属性初始化） -&gt; <strong>调用构造器</strong></p><h3 id="7-4-2-继承中代码块执行顺序"><a href="#7-4-2-继承中代码块执行顺序" class="headerlink" title="7.4.2 继承中代码块执行顺序"></a>7.4.2 继承中代码块执行顺序</h3><ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）；</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）；</li><li>父类的构造代码块和普通属性（优先级一样，按定义顺序执行）；</li><li>父类的构造方法</li><li>子类的构造代码块和普通属性（优先级一样，按定义顺序执行）；</li><li>子类的构造方法</li></ol><p><strong>总结</strong></p><p>**加载类信息(父→子)**（加载静态代码块和静态属性初始化）-&gt; (父类)<strong>加载构造代码块和普通属性初始化</strong> -&gt; (父类)<strong>调用构造器</strong> -&gt; (子类)<strong>加载构造代码块和普通属性初始化</strong> -&gt; (子类)<strong>调用构造器</strong></p><blockquote><p>构造器的最前面隐含了<code>super()</code>和<code>&#123;普通代码块&#125;</code>。</p></blockquote><h1 id="八、对象初始化详细过程"><a href="#八、对象初始化详细过程" class="headerlink" title="八、对象初始化详细过程"></a>八、对象初始化详细过程</h1><h2 id="8-1-一个类及其对象初始化的过程"><a href="#8-1-一个类及其对象初始化的过程" class="headerlink" title="8.1 一个类及其对象初始化的过程"></a>8.1 一个类及其对象初始化的过程</h2><h3 id="什么时候需要初始化一个类"><a href="#什么时候需要初始化一个类" class="headerlink" title="什么时候需要初始化一个类"></a>什么时候需要初始化一个类</h3><p>首次创建某个对象时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <br></code></pre></td></tr></table></figure><p>首次访问某个类的静态方法或者静态字段时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Dog.staticFields;<br></code></pre></td></tr></table></figure><p>Java 解释器就会去找类的路径，定位已经编译好的 Dog.class 文件。</p><h3 id="获得类的资源"><a href="#获得类的资源" class="headerlink" title="获得类的资源"></a>获得类的资源</h3><p>然后 jvm 就会载入 <code>Dog.class</code>，生成一个<code>class</code>对象。这个时候如果有静态的方法或者变量，静态初始化动作都会被执行。这个时候要注意啦，静态初始化在程序运行过程中只会在 Class 对象首次加载的时候运行一次。这些资源都会放在 jvm 的<strong>方法区</strong>。</p><p><strong>方法区</strong>又叫<strong>静态区</strong>，跟堆一样，被所有的线程共享。</p><p>方法区中包含的都是在整个程序中永远唯一的元素，包含所有的 class 和 static 变量。</p><h3 id="初始化对象-Dog-dog-new-Dog"><a href="#初始化对象-Dog-dog-new-Dog" class="headerlink" title="初始化对象 Dog dog = new Dog()"></a>初始化对象 <code>Dog dog = new Dog()</code></h3><ol><li>第一次创建<code>Dog</code>对象先执行上面的一二步</li><li>在堆上为<code>Dog</code>对象分配足够的存储空间，所有属性和方法都被设置成默认值(数字为 0，字符为<code>null</code>，布尔为<code>false</code>，而所有引用被设置成<code>null</code>）</li><li>执行构造函数检查是否有父类，如果有父类会先调用父类的构造函数，这里假设 <code>Dog</code> 没有父类，执行默认值字段的赋值即方法的初始化动作。</li><li>执行构造函数。</li></ol><h2 id="8-2-有父类情况下的初始化"><a href="#8-2-有父类情况下的初始化" class="headerlink" title="8.2 有父类情况下的初始化"></a>8.2 有父类情况下的初始化</h2><p>假设: <code>Dog extends Animal</code></p><ol><li>执行第一步，找出<code>Dog.class</code>文件，接着在加载过程中发现他有一个基类（通过<code>extends</code> 关键字），于是先执行<code>Animal</code>类的第一二步，加载<code>Animal</code>类的静态变量和方法，加载结束之后再加载子类<code>Dog</code>的静态变量和方法。</li></ol><p>如果<code>Animal</code>类还有父类就以此类推，最终的基类叫做根基类。</p><blockquote><p>因为子类的<code>static</code>初始化可能会依赖于父类的静态资源，所以要先加载父类的静态资源。</p></blockquote><ol><li>接着要 <code>new Dog</code> 对象，先为<code>Dog</code>对象分配存储空间 -&gt; 到<code>Dog</code>的构造函数 -&gt; 创建默认的属性。这里其构造函数里面的第一行有个隐含的<code>super()</code>，即父类构造函数，所以这时会跳转到父类<code>Animal</code>的构造函数。</li></ol><p>Java 会帮我们完成构造函数的补充，Dog 实际隐式的构造函数如下:</p><ol><li>父类<code>Animal</code>执行构造函数前也是分配存储空间 -&gt; 到其构造函数 -&gt; 创建默认的属性 -&gt; 发现已经没有父类了，这个时候就给它的默认的属性赋值和方法的初始化。</li><li>接着执行构造函数余下的部分，结束后跳转到子类<code>Dog</code>的构造函数。</li><li>子类<code>Dog</code>对默认属性和方法分别进行赋值和初始化，接着完成构造函数接下来的部分。</li></ol><p><strong>为什么要执行父类 Animal 的构造方法才继续子类 Dog 的属性及方法赋值？</strong></p><p>因为子类 Dog 的非静态变量和方法的初始化有可能使用到其父类 Animal 的属性或方法，所以子类构造默认的属性和方法之后不应该进行赋值，而要跳转到父类的构造方法完成父类对象的构造之后，才来对自己的属性和方法进行初始化。</p><p>这也是为什么子类的构造函数显示调用父类构造函数 super() 时要强制写在第一行的原因，程序需要跳转到父类构造函数完成父类对象的构造后才能执行子类构造函数的余下部分。</p><p><strong>为什么对属性和方法初始化之后再执行构造函数其他的部分？</strong></p><p>因为构造函数中的显式部分有可能使用到对象的属性和方法。</p><blockquote><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/java-init-object-process.html">Java 对象初始化详细过程 | 菜鸟教程</a></p></blockquote><h2 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3 总结"></a>8.3 总结</h2><h1 id="九、内部类"><a href="#九、内部类" class="headerlink" title="九、内部类"></a>九、内部类</h1><p>一个类的内部又完整嵌套了另一个类结构，被嵌套的（里面的）类成为内部类（inner class），嵌套其他类的（外面的）类称为外部类（outer class）。</p><p>内部类是类的第五大成员【属性、方法、构造器、代码块、内部类】</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>内部类最大特点是<strong>可以直接访问私有属性</strong>，并且可以体现类与类直接的包含关系。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>定义在外部类局部位置上</strong>（比如方法内）：</p><ol><li>局部内部类（有类名）</li><li>匿名内部类（没有类名，重点!!!!!!!）</li></ol><p><strong>定义在外部类的成员位置上：</strong></p><ol><li>成员内部类（没用<code>static</code>修饰）</li><li>静态内部类（有用<code>static</code>修饰）</li></ol><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在外部类的局部位置，比如方法、代码块中，并且有类名，本质仍然是一个类。</p><p><strong>重要规则</strong></p><ol><li>不能添加访问修饰符（由于它地位就是一个局部变量，局部变量不能使用修饰符），但是可以使用final修饰。</li><li>可以直接访问外部类的所有成员。</li><li>作用域：仅仅在定义它的方法或代码块中。</li><li>局部内部类 —&gt; 访问 —&gt; 外部类成员【访问方式：直接访问】</li><li>外部类 —&gt; 访问 —&gt; 局部内部类成员【访问方式：创建对象再访问】（且必须在作用域内）示例9-1</li><li>外部其他类 — 不能访问 —&gt; 局部内部类（因为局部内部类地位相当于局部变量）</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，使用：<strong>外部类名.this.成员</strong>（本质是外部类的对象，即哪个对象调用了m1）</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>定义在外部类的局部位置，比如方法、代码块中，并且没有类名，本质仍然是一个类，同时还是一个对象</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类or接口(参数列表) &#123;<br>    类体<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>因为匿名内部类<strong>既是一个类的定义</strong>，同时也<strong>本身也是一个对象</strong>，</p><p>所以从语法上看，它既有定义类的特征，也有创建对象的特征（对前面代码分析可以看出这个特点），因此可以调用匿名内部类方法。</p><p>示例9-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousInnerClassDetail</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Outer05</span> <span class="hljs-variable">outer05</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer05</span>();<br>        outer05.f1();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer05</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;  <span class="hljs-comment">//外部类属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//外部类方法</span><br>        <span class="hljs-comment">//(1) 创建一个基于类的匿名内部类</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//可以直接访问外部类的所有成员，包括私有的</span><br>                System.out.println(<span class="hljs-string">&quot;匿名内部类重写了hi方法 n1= &quot;</span> + n1);<br>            &#125;<br>        &#125;;<br>        person.hi();  <span class="hljs-comment">//动态绑定，运行类型是 Outer05$1</span><br><br>        <span class="hljs-comment">//(2) 也可以直接调用(本质：匿名内部类本身也是返回对象)</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>        &#125;.ok(<span class="hljs-string">&quot;shit&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person hi()&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ok</span><span class="hljs-params">(String str)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;输出&quot;</span> + str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重要规则（与局部内部类相似）</strong></p><ol><li>不能添加访问修饰符，因为它的地位就是一个局部变量</li><li>可以直接访问外部类的所有成员，包含私有的</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>匿名内部类 —&gt; 访问 —&gt; 外部类成员【访问方式：直接访问】</li><li>外部其他类 —&gt; 不能访问 —&gt; 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（<code>外部类名.this.成员</code>）访问</li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在外部类的成员位置，并且没有<code>static</code>修饰。</p><p><strong>重要规则</strong></p><ol><li><p>可以添加任意访问修饰符</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>成员内部类 –&gt; 访问 –&gt; 外部类成员成员【访问方式：直接访问】</p></li><li><p>外部类 –&gt; 访问 —&gt; 成员内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类 —&gt; 访问 —&gt; 成员内部类</p></li><li><ol><li>① 利用外部类创建内部类对象，再访问；【例：<code>Outer.Inner inner = outer.new Inner();</code>】（<code>**outer.new Inner();**</code> 相当于把 <code>new Inner()</code> 当作<code>outer</code>对象的成员）</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>()<br></code></pre></td></tr></table></figure><ol><li><ol><li>② 在外部类中编写一个方法，返回内部类的对象。例：</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">Inner</span> getInnerInstance() &#123;     <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();  &#125; <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.getInnerInstance();<br></code></pre></td></tr></table></figure><ol><li><ol><li>③ <code>new Outer().new Inner();</code> 相当于①，只是把<code>Outer outer = new Outer();</code> 合并了。</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>().<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); <span class="hljs-keyword">Outer</span> <span class="hljs-keyword">outer</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>(); <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br></code></pre></td></tr></table></figure><ol><li>如果外部类和成员内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，使用：<code>**外部类名.this.成员**</code></li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义在外部类的成员位置，有static修饰。</p><p><strong>重要规则（与成员内部类相似）</strong></p><ol><li><p>可以添加任意访问修饰符</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>静态内部类 –&gt; 访问 –&gt; 外部类成员【访问方式：直接访问所有的静态成员】</p></li><li><p>外部类 –&gt; 访问 —&gt; 静态内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类 —&gt; 访问 —&gt; 成员内部类</p></li><li><ol><li>方式①：利用外部类创建内部类对象，再访问；【例：<code>Outer.Inner inner = new Outer.Inner();</code>】<code>**new Outer.Inner();**</code> 因为静态内部类是静态成员，可以直接通过类名访问</li><li>方式②：在外部类中编写一个方法，返回内部类的对象。【例：<code>public static Inner getInner() &#123; return new Inner(); &#125;``Outer.Inner inner = Outer.getInner();</code> 】（非静态也可以）</li></ol></li><li><p>如果外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，使用：<strong>外部类名.成员</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberInnerClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer08</span> <span class="hljs-variable">outer08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer08</span>();<br>        outer08.t1();<br><br>        <span class="hljs-comment">//第一种 成员内部类</span><br>        <span class="hljs-comment">//Outer08.Inner08 inner08 = outer08.new Inner08();</span><br>        <br>        <span class="hljs-comment">//第一种 静态内部类</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer08</span>.Inner08();<br><br>        <span class="hljs-comment">//第二种</span><br>        <span class="hljs-comment">//在外部类中，编写一个方法，返回 Inner08 对象</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance</span> <span class="hljs-operator">=</span> outer08.getInner08Instance();<br>        <span class="hljs-comment">//在外部类中，编写一个静态方法，返回 Inner08 对象</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance_</span> <span class="hljs-operator">=</span> Outer08.getInner08Instance_();<br>        <br>        inner08Instance.say();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer08</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><br>    <span class="hljs-comment">//1.定义在外部类的成员位置上</span><br>    <span class="hljs-comment">//2.可以添加任意访问修饰符，因为它就是一个成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner08</span> &#123;  <span class="hljs-comment">//成员内部类</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">66</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;n1=&quot;</span> + n1 + <span class="hljs-string">&quot; name=&quot;</span> + name + <span class="hljs-string">&quot; 外部类n1=&quot;</span> + Outer08.n1);  <span class="hljs-comment">//直接访问所有的静态成员</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Inner08 <span class="hljs-title function_">getInner08Instance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Inner08 <span class="hljs-title function_">getInner08Instance_</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//静态方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//使用成员内部类</span><br>        <span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>        inner08.say();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Java/" class="category-chain-item">Java</a> <span>></span> <a href="/categories/Java/Java%E5%9F%BA%E7%A1%80/" class="category-chain-item">Java基础</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/" class="print-no-link">#Java</a></div></div><div class="license-box my-3"><div class="license-title"><div>Java 面向对象</div><div>https://blog-21n.pages.dev/2022/06/13/Java-面向对象/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Neo</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年6月13日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/06/28/Java-%E6%B3%A8%E8%A7%A3/" title="Java 注解"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Java 注解</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/06/07/Java-%E6%96%B9%E6%B3%95/" title="Java 方法"><span class="hidden-mobile">Java 方法</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>