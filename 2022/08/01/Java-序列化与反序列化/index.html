<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png"><link rel="icon" href="/img/avatar.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Neo"><meta name="keywords" content=""><meta name="description" content="什么是序列化和反序列化? 序列化：将数据结构或对象转换成二进制字节流（一个byte[]数组）的过程 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程  维基百科的介绍：  序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的"><meta property="og:type" content="article"><meta property="og:title" content="Java 序列化与反序列化"><meta property="og:url" content="https://blog-21n.pages.dev/2022/08/01/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/index.html"><meta property="og:site_name" content="KingShit"><meta property="og:description" content="什么是序列化和反序列化? 序列化：将数据结构或对象转换成二进制字节流（一个byte[]数组）的过程 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程  维基百科的介绍：  序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/20240827162203.png"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png"><meta property="article:published_time" content="2022-08-01T10:00:00.000Z"><meta property="article:modified_time" content="2024-08-27T08:58:25.677Z"><meta property="article:author" content="Neo"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/20240827162203.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>Java 序列化与反序列化 - KingShit</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"blog-21n.pages.dev",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>!function(){var o;if("boxpiggy.github.io"===window.location.hostname?o="https://boxpiggy.github.io/live2d-widget/autoload.js":"blog-21n.pages.dev"===window.location.hostname&&(o="https://blog-21n.pages.dev/live2d-widget/autoload.js"),o){var t=document.createElement("script");t.src=o,document.head.appendChild(t)}}()</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Neo&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Java 序列化与反序列化"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-01 18:00" pubdate>2022年8月1日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 20 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Java 序列化与反序列化</h1><div class="markdown-body"><h1 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化?"></a>什么是序列化和反序列化?</h1><ul><li>序列化：将数据结构或对象转换成二进制字节流（一个byte[]数组）的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>维基百科的介绍：</p><blockquote><p><strong>序列化（serialization）</strong>在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><h1 id="为什么需要序列化"><a href="#为什么需要序列化" class="headerlink" title="为什么需要序列化"></a>为什么需要序列化</h1><p>序列化后可以把二进制字节流<code>byte[]</code>保存到文件中，或者通过网络传输到远程。</p><p>总的来说，如果我们<strong>需要持久化 Java 对象</strong>比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，就要用到序列化。</p><p>同理，有了反序列化，保存到文件中或者从网络上读取的二进制字节流<code>byte[]</code>就可以转换回 Java 对象，读取到程序中进行处理。</p><p><strong>常见应用场景：</strong></p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/20240827162203.png" srcset="/img/loading.gif" lazyload></p><h1 id="序列化协议"><a href="#序列化协议" class="headerlink" title="序列化协议"></a>序列化协议</h1><p>序列化协议对应于 TCP&#x2F;IP 模型的哪一层？<strong>表示层</strong></p><blockquote><p>四层：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol></blockquote><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="OSI七层模型"></p><h2 id="常见序列化协议"><a href="#常见序列化协议" class="headerlink" title="常见序列化协议"></a>常见序列化协议</h2><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><h2 id="JDK-自带的序列化方式"><a href="#JDK-自带的序列化方式" class="headerlink" title="JDK 自带的序列化方式"></a>JDK 自带的序列化方式</h2><p>JDK 自带的序列化，只需实现<code>java.io.Serializable</code>接口即可。</p><blockquote><p><code>Serializable</code>接口属于“标记接口”，没有定义任何方法，它是一个空接口，仅仅是给自身贴了个“标记”。</p><p>一个Java对象要支持序列化机制，其类必须是可序列化的，该类必须实现一个特殊的 <code>java.io.Serializable</code>接口。（或者<code>Externalizable</code>接口，该接口继承了 <code>Serializable</code>，需要实现接口方法，不常用）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>serialVersionUID 有什么作用？</strong></p><p>序列化号<code>serialVersionUID</code>属于版本控制的作用。反序列化时，会检查<code>serialVersionUID</code>是否和当前类的<code>serialVersionUID</code>一致。如果<code>serialVersionUID</code>不一致则会抛出 <code>InvalidClassException</code>异常。强烈推荐每个序列化类都手动指定其<code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的<code>serialVersionUID</code>。</p><p><strong>不指定 serialVersionUID 会如何？</strong></p><p>如果没有指定，在序列化过程中，jvm 会自动计算出一个值作为<code>serialVersionUID</code>，由于这种运行时计算<code>serialVersionUID</code>的方式依赖于 jvm 的实现方式，如果序列化和反序列化的 jvm 实现方式不一样可能会导致抛出异常<code>InvalidClassException</code>，所以在使用原生序列化方式的时候<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/platform/serialization/spec/class.html#4100">官方</a>是强烈建议指定一个<code>serialVersionUID</code>的。</p><p><strong>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</strong></p><p>static 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，serialVersionUID 是一个特例，serialVersionUID 的序列化做了特殊处理。当一个对象被序列化时，serialVersionUID 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。</p><p>官方说明：</p><blockquote><p>A serializable class can declare its own serialVersionUID explicitly by declaring a field named “serialVersionUID” that must be static, final, and of type long;</p><p>如果想显式指定 serialVersionUID ，则需要在类中使用 static 和 final 关键字来修饰一个 long 类型的变量，变量名字必须为 “serialVersionUID” 。</p></blockquote><p>也就是说，<code>serialVersionUID</code>只是用来被 JVM 识别，实际并没有被序列化。</p><p><strong>如果有些字段不想进行序列化怎么办？</strong></p><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code>关键字的作用：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被<code>transient</code>修饰的变量值不会被持久化和恢复。</p><p><strong>注意细节：</strong></p><ul><li><code>transient</code>只能修饰变量，不能修饰类和方法。</li><li><code>transient</code>修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰<code>int</code>类型，那么反序列后结果就是 0。</li><li><code>static</code>变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li></ul><p><strong>为什么不推荐使用 JDK 自带的序列化？</strong></p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：<a target="_blank" rel="noopener" href="https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/">应用安全:JAVA 反序列化漏洞之殇 - Cryin</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37562657/answer/1916596031">Java 反序列化安全漏洞怎么回事? - Monica</a></li></ul><h2 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h2><p>Kryo 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p><p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a></p><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p><blockquote><p>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言。</p></blockquote><p>一个简单的 proto 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// protobuf的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span><br>message Person &#123;<br>  <span class="hljs-comment">//string类型字段</span><br>  <span class="hljs-type">string</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// int 类型字段</span><br>  <span class="hljs-type">int32</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p><h2 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h2><p>由于 Protobuf 的易用性较差，它的哥哥 Protostuff 诞生了。</p><p>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p><p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/protostuff/protostuff">https://github.com/protostuff/protostuff</a></p><h2 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h2><p>Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。</p><p>Dubbo2.x 默认启用的序列化方式是 Hessian2，但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/user/serialization/">一篇文章</a>中提到说推荐使用 Kryo 作为生产环境的序列化方式。</p><p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p><p>除了上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p><hr><p>参考：</p><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/serialization.html">Java 序列化详解</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Java/" class="category-chain-item">Java</a> <span>></span> <a href="/categories/Java/Java%E5%9F%BA%E7%A1%80/" class="category-chain-item">Java基础</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/" class="print-no-link">#Java</a></div></div><div class="license-box my-3"><div class="license-title"><div>Java 序列化与反序列化</div><div>https://blog-21n.pages.dev/2022/08/01/Java-序列化与反序列化/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Neo</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年8月1日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/09/15/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/" title="Linux查看系统配置"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Linux查看系统配置</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/08/01/Java-IO%E6%B5%81/" title="Java IO流"><span class="hidden-mobile">Java IO流</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>