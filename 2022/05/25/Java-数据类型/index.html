<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png"><link rel="icon" href="/img/avatar.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Neo"><meta name="keywords" content=""><meta name="description" content="Java 基本数据类型Java 中有 8 种基本数据类型，分别为：  6 种数字类型：   4 种整数型：byte、short、int、long 2 种浮点型：float、double   1 种字符类型：char  1 种布尔型：boolean   这 8 种基本数据类型的默认值以及所占空间的大小如下：    类型 占用存储空间 默认值 最小值 最大值    byte 1byte 0 -27-1"><meta property="og:type" content="article"><meta property="og:title" content="Java 数据类型"><meta property="og:url" content="https://blog-21n.pages.dev/2022/05/25/Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html"><meta property="og:site_name" content="KingShit"><meta property="og:description" content="Java 基本数据类型Java 中有 8 种基本数据类型，分别为：  6 种数字类型：   4 种整数型：byte、short、int、long 2 种浮点型：float、double   1 种字符类型：char  1 种布尔型：boolean   这 8 种基本数据类型的默认值以及所占空间的大小如下：    类型 占用存储空间 默认值 最小值 最大值    byte 1byte 0 -27-1"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/valueOf%E6%BA%90%E7%A0%81.png"><meta property="article:published_time" content="2022-05-25T05:46:00.000Z"><meta property="article:modified_time" content="2024-08-09T17:20:38.288Z"><meta property="article:author" content="Neo"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/valueOf%E6%BA%90%E7%A0%81.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>Java 数据类型 - KingShit</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"blog-21n.pages.dev",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>!function(){var o;if("boxpiggy.github.io"===window.location.hostname?o="https://boxpiggy.github.io/live2d-widget/autoload.js":"blog-21n.pages.dev"===window.location.hostname&&(o="https://blog-21n.pages.dev/live2d-widget/autoload.js"),o){var t=document.createElement("script");t.src=o,document.head.appendChild(t)}}()</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Neo&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Java 数据类型"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-25 13:46" pubdate>2022年5月25日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 34 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Java 数据类型</h1><div class="markdown-body"><h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li><p>6 种数字类型：</p></li><li><ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li><p>1 种字符类型：<code>char</code></p></li><li><p>1 种布尔型：<code>boolean</code></p></li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th>类型</th><th>占用存储空间</th><th>默认值</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>byte</td><td>1byte</td><td>0</td><td>-27-128</td><td>27 - 1127</td></tr><tr><td>short</td><td>2byte</td><td>0</td><td>-215-32768</td><td>215 - 132767</td></tr><tr><td>int</td><td>4byte</td><td>0</td><td>-231-2147483648</td><td>231 - 12147483647</td></tr><tr><td>long</td><td>8byte</td><td>0L</td><td>-263……</td><td>263 - 1……</td></tr><tr><td>float</td><td>4byte</td><td>0.0f</td><td>-1.4E-45 -3.403E38</td><td>3.4028235E38</td></tr><tr><td>double</td><td>8byte</td><td>0.0d</td><td>-1.798E308</td><td>1.7976931348623157E308</td></tr><tr><td>char</td><td>2byte</td><td>‘u0000’</td><td>0 \u0000</td><td>65535（216- 1）\uffff</td></tr><tr><td>boolean</td><td>1bit</td><td>false</td><td>false</td><td>true</td></tr></tbody></table><p>像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都 <strong>-1</strong> 了。这是为什么呢？</p><p>这是因为在<strong>二进制补码表示法</strong>中，<strong>最高位是用来表示符号的</strong>（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。</p><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。</p><h2 id="整型-byte、short、int、long"><a href="#整型-byte、short、int、long" class="headerlink" title="整型 - byte、short、int、long"></a>整型 - byte、short、int、long</h2><p><code>byte</code>：字节（1byte）：8位、有符号的，以二进制补码表示的整数</p><p><code>short</code>：短整型（2byte）：16 位、有符号的，以二进制补码表示的整数</p><p><code>int</code>：整型（4byte）：32位、有符号的，以二进制补码表示的整数</p><p><code>long</code>：长整型（8byte）：64 位、有符号的，以二进制补码表示的整数</p><h3 id="整型的使用细节"><a href="#整型的使用细节" class="headerlink" title="整型的使用细节"></a>整型的使用细节</h3><ol><li>Java 的整型常量默认为 <code>int</code> 型，声明 long 型常量须在后加<code>l</code>或<code>L</code>；</li><li>Java 程序中变量声常明为 <code>int</code> 型，除非不足以表示大数，才使用 <code>long</code>；</li><li><code>bit</code>: 计算机中的最小存储单位。 <code>byte</code>: 计算机中基本存储单元，<code>1byte = 8bit</code>。</li></ol><h2 id="浮点型-float、double"><a href="#浮点型-float、double" class="headerlink" title="浮点型 - float、double"></a>浮点型 - float、double</h2><p><code>float</code>：4byte：单精度、32位、符合IEEE 754 标准的浮点数</p><p><code>double</code>：8byte：双精度、64 位、符合 IEEE 754 标准的浮点数</p><h3 id="浮点型使用细节"><a href="#浮点型使用细节" class="headerlink" title="浮点型使用细节"></a>浮点型使用细节</h3><ol><li>浮点数在机器中存放形式，浮点数 &#x3D; 符号位 + 指数位 + 尾数位</li><li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li><li>浮点数默认为<code>double</code>类型，声明<code>float</code>型须在后面加上<code>f</code>或<code>F</code>。（数值加<code>d</code>表示<code>double</code>类型）</li><li>浮点数有两种表示形式：</li></ol><ul><li><ul><li>十进制数形式：如5.12 512.0f .512</li><li>科学计数法形式：如5.12e2（5.12*10^2）</li><li>科学记数法：结尾的”E+数字”表示E之前的数字要乘以10的多少次方。比如，3.14E-3就是3.14 x 10-3 &#x3D;0.00314。</li></ul></li></ul><ol><li>通常使用<code>double</code>型，精度更高</li><li>比较浮点数的时候，不能使用“<code>==</code>”操作符。（计算机 内存存储浮点数使用IEEE754标准，存在精度问题，在存储计算过程中容易引起较小的舍入误差）</li></ol><ul><li><ul><li>使用Math.abs() 方法来计算两个浮点数之间差异的绝对值，如果这个差异在阈值范围之内，我们就认为两个浮点数是相等的。如：Math.abs(num1 - num2) &lt; 0.0001</li><li>使用 BigDecimal 类的 compareTo() 方法对两个数进行比较，该方法将会忽略小数点后的位数。见示例1。（比如说 2.0 和 2.00 的位数不同，但它俩的值是相等的）</li></ul></li></ul><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.0&quot;</span>);<br><br>System.out.println(a.equals(b));  <span class="hljs-comment">//false</span><br>System.out.println(a.compareTo(b) == <span class="hljs-number">0</span>);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="字符型-char"><a href="#字符型-char" class="headerlink" title="字符型 - char"></a>字符型 - char</h2><p><code>char</code>：2byte：单一的 16 位 Unicode 字符</p><h3 id="字符型使用细节"><a href="#字符型使用细节" class="headerlink" title="字符型使用细节"></a>字符型使用细节</h3><ol><li><code>char</code>用单引号<code>&#39; &#39;</code>，<code>String</code>字符串用双引号<code>&quot; &quot;</code></li><li>转义字符 ‘<code>\</code>‘ ，将其后的字符转变为特殊字符型常量。如：<code>char c = &#39;\n&#39;</code></li><li>Java 中，<code>char</code>本质是一个整数，输出时是 unicode 编码对应的字符（因此可直接赋值<code>char</code>一个整数）</li></ol><ul><li><ul><li>Unicode与中文之间的相互转换工具：<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/tools/index?name=unicode_chinese">在线Unicode&#x2F;中文转换工具 - 编码转换工具 - W3Cschool</a></li><li><a target="_blank" rel="noopener" href="http://tool.chinaz.com/Tools/Unicode.aspx">Unicode编码转换 - 站长工具</a></li></ul></li></ul><ol><li>由3.可得，<code>char</code>类型可进行运算。</li><li>字符型存储到计算机中，需要找到字符对应的码值（整数），比如<code>&#39;a&#39;</code>：</li></ol><ul><li><ul><li>存储：<code>&#39;a&#39;</code> –&gt; 码值 97 –&gt; 二进制 0110 0001 –&gt; 存储</li></ul></li></ul><ol><li>字符编码表：</li></ol><ul><li><ul><li>- ASCII 编码表 1 个字节表示，一个128个字符（实际上一个字节可以表示256个字符，只用了128个）</li><li>Unicode 编码表 固定大小的编码，使用 2 个字节表示，字母和汉字统一占用 2 个字节（但这样浪费空间）。（Unicode兼容ASCII）</li><li>utf-8 编码表：大小可变的编码，使用1-6个字节表示一个符号，字母使用 1 个字节，汉字使用 3 个字节（实际开发用得最多）（Unicode的改进方式，互联网使用最广）</li><li>gbk 可以表示汉字，范围广，字母使用 1 个字节，汉字使用 2 个字节</li><li>gb2312 可以表示汉字，gb2312 &lt; gbk</li><li>big5 码，繁体中文，tw hk</li></ul></li></ul><h2 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型 - boolean"></a>布尔型 - boolean</h2><p><code>boolean</code>：1bit： 1 位，作为一种标志来记录 true&#x2F;false 情况</p><p>（准确讲是1byte，计算机处理数据的最小单位是 1 个字节）</p><p>事实上：boolean 占用多少字节取决于虚拟机本身的实现，《Java 虚拟机规范》提议：</p><ul><li>如果 boolean 是 “单独使用”：boolean 被编译为 int 类型，占 4 个字节</li><li>如果 boolean 是以 “boolean 数组” 的形式使用：boolean 占 1 个字节</li></ul><h3 id="布尔型细节"><a href="#布尔型细节" class="headerlink" title="布尔型细节"></a>布尔型细节</h3><ol><li>Java中不可以用 0 或者非 0 整数替代 false 和 true，这点和C、php等语言不同。</li></ol><h1 id="Java-类型转换"><a href="#Java-类型转换" class="headerlink" title="Java 类型转换"></a>Java 类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>自动类型转换：</strong>低精度数据类型 自动转换为 高精度数据类型：</p><ul><li>char –&gt; int –&gt; long –&gt; float –&gt; double</li><li>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</li></ul><p><strong>示例2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span>;  <span class="hljs-comment">//true char --&gt; int</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;  <span class="hljs-comment">//true int --&gt; double</span><br></code></pre></td></tr></table></figure><h3 id="自动类型转换细节"><a href="#自动类型转换细节" class="headerlink" title="自动类型转换细节"></a>自动类型转换细节</h3><ol><li>多种类型得数据混合运算时，系统自动将所有数据转换成精度（容量）最大的数据类型，然后再进行计算：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1.2</span>;  <span class="hljs-comment">//double 11.2</span><br></code></pre></td></tr></table></figure><ol><li>当把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错。</li><li>（<code>byte</code>, <code>short</code>） 和 <code>char</code> 之间不会相互自动转换。</li><li><code>byte</code>, <code>short</code>, <code>char</code> 三者可以计算，在计算时首先转换为 <code>**int**</code> 类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b1 + s;     <span class="hljs-comment">// √ 因为：b1 + s =&gt; int</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> b1 + b2;  <span class="hljs-comment">// × 因为：b1 + b3 =&gt; int</span><br></code></pre></td></tr></table></figure><ol><li>boolean 不参与转换</li><li>自动提升原则：表达式结果的类型自动提升为<strong>操作数中最大的类型</strong>。</li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。需要加上强制转换符()，但可能造成精度降低或溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(s + b);  <span class="hljs-comment">//由于(s+b)=&gt;int，因此要强制转换成short才不报错</span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型和String类型的转换"><a href="#基本数据类型和String类型的转换" class="headerlink" title="基本数据类型和String类型的转换"></a>基本数据类型和String类型的转换</h3><ol><li><strong>基本类型转String类型</strong></li></ol><p>方法：直接拼接个双引号””</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><ol><li><strong>String类型转基本类型</strong></li></ol><p>方法：通过基本类型的包装类调用<code>parseXX</code>方法即可（每一个基本类型都对应一个包装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;24&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br></code></pre></td></tr></table></figure><p><code>String</code>转换成<code>char</code> &#x3D;&#x3D;&gt; 得到字符串的第一个字符 （利用<code>charAt(n)</code>方法，将字符串的第<code>n</code>个字符取出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(s.charAt(<span class="hljs-number">0</span>))  <span class="hljs-comment">//s.charAt(0) 得到字符串s的第一个字符&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure><ol><li><strong>注意</strong></li></ol><ul><li>将<code>String</code>类型转成基本数据类型时，要确保<code>String</code>类型能够转成有效的数据，比如可以把<code>&quot;123&quot;</code>转成一个整数，但是不能把<code>&quot;shit&quot;</code>转成一个整数。</li><li>如果格式不正确，就会抛出异常，程序终止。</li></ul><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul><li>在进行基本的数据计算时，开发者可以直接使用基本数据类型。</li><li>但是当需要和Java其他对象结合使用，如存入集合中，就需要将基础数据类型实例封装为Java对象，</li><li>为了面向对象的这一特性，基本数据类型中的每一个类型在<code>java.lang</code>包中都有一个包装类，即将每个基本类型都包装成了一个类。八种基本类型对应包装类：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</li></ul><hr><table><tr><td>基本数据类型</td><td>包装类</td><td>接口</td><td>父类</td><td>接口</td><td>父类</td></tr><tr><td>boolean</td><td>Boolean</td><td rowspan="8">Comparable</td><td rowspan="2">—</td><td rowspan="8">Serializable</td><td rowspan="8">Object</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td><td rowspan="6">Number</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></table><h2 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h2><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中 [1]。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p>[1] 为什么说是<strong>几乎</strong>所有对象实例都存在于堆中呢？</p><p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>更多参考：<a target="_blank" rel="noopener" href="https://www.yuque.com/kingshit/java/khlmi9x1su7i6vr6">JIT逃逸分析</a></p><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 成员变量，存放在堆中</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">// 被 static 修饰，也存放在堆中，但属于类，不属于对象</span><br>    <span class="hljs-comment">// JDK1.7 静态变量从永久代移动了 Java 堆中</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 局部变量，存放在栈中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>; <span class="hljs-comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本数据类型和包装类转换"><a href="#基本数据类型和包装类转换" class="headerlink" title="基本数据类型和包装类转换"></a>基本数据类型和包装类转换</h2><ol><li>jdk5 前的手动装箱和拆箱方式。（装箱：基本类型 -&gt; 包装类型；拆箱：包装类型 -&gt; 基本类型）</li><li>jdk5 及以后的自动装箱和拆箱方式。</li><li>自动装箱底层调用的是<code>valueOf</code>方法，比如<code>Integer.valueOf()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer3</span> <span class="hljs-operator">=</span> n2;<br><span class="hljs-comment">//底层使用的是 Integer.valueOf(n2); </span><br><span class="hljs-comment">// valueOf本质是 当在 -128~127 时，直接返回；否则 new Integer(i); 详见</span><br><br><span class="hljs-comment">//自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> integer3;<br><span class="hljs-comment">//底层使用的是 integer2.intValue()，return integer3对象的value</span><br></code></pre></td></tr></table></figure><h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p><strong>装箱：</strong>将基本类型用它们对应的引用类型包装起来</p><p><strong>拆箱：</strong>将包装类型转换为基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱 等价于 Integer i = Integer.valueOf(10)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱 等价于 int n = i.intValue();</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><h2 id="浮点数运算的精度丢失风险"><a href="#浮点数运算的精度丢失风险" class="headerlink" title="浮点数运算的精度丢失风险"></a>浮点数运算的精度丢失风险</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.8f</span> - <span class="hljs-number">1.7f</span>;<br>System.out.println(a);  <span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);  <span class="hljs-comment">// 0.099999905</span><br>System.out.println(a == b);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>原因：</strong>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><p>更多内容详见：<a target="_blank" rel="noopener" href="https://www.yuque.com/kingshit/wz61vk/yxked8f04twgtmnl">浮点数</a></p><h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到<strong>货币</strong>的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(c);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.2 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.20 */</span><br><span class="hljs-comment">// 比较内容，不是比较值</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* false */</span><br><span class="hljs-comment">// 比较值相等用compareTo，相等返回0</span><br>System.out.println(<span class="hljs-number">0</span> == x.compareTo(y)); <span class="hljs-comment">/* true */</span><br></code></pre></td></tr></table></figure><p>关于 <code>BigDecimal</code> 的详细介绍，参考：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a>。</p><h2 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h2><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><p>在 Java 中，64 位 long 整型是最大的整数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span><br>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h2 id="String类型和包装类转换"><a href="#String类型和包装类转换" class="headerlink" title="String类型和包装类转换"></a>String类型和包装类转换</h2><p>包装类（Integer 为例） -&gt; String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//方式一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;  <br><span class="hljs-comment">//底层创建一个基于i对象的值的String对象，i对象的类型并没有改变</span><br><br><span class="hljs-comment">//方式二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> i.toString();  <span class="hljs-comment">//</span><br><br><span class="hljs-comment">//方式三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> String.valueOf(i);  <br><span class="hljs-comment">//底层还是跟方式二一样调用toString： </span><br><span class="hljs-comment">// return (obj == null) ? &quot;null&quot; : obj.toString()</span><br></code></pre></td></tr></table></figure><p>String -&gt; 包装类（Integer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">//方式一：调用包装类的转换方法parseXxx()</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.parseInt(str);  <span class="hljs-comment">//底层：调用parseInt(s, 10); 参数radix:10表示输出十进制整数</span><br><br><span class="hljs-comment">//方式二：调用Integer构造器</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str);  <span class="hljs-comment">//底层还是跟方式一一样：this.value = parseInt(s, 10); </span><br></code></pre></td></tr></table></figure><h2 id="包装类缓存机制"><a href="#包装类缓存机制" class="headerlink" title="包装类缓存机制"></a>包装类缓存机制</h2><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128, 127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0, 127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p><strong>所有整型包装类对象之间值的比较，全部使用</strong> <code>**equals**</code> <strong>方法比较。</strong></p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    System.out.println(i1 == j2);  <span class="hljs-comment">// false  new出来的是不同的对象</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 底层调用valueOf方法，当传入参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 等价于 Integer i4 = Integer.valueOf(127)</span><br>    System.out.println(i3 == i4);  <span class="hljs-comment">// true</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 底层调用valueOf方法，当传入参数不在 -128~127 范围时，直接创建新对象。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i6</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 同上</span><br>    System.out.println(i5 == i6);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i7</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// 从数组里面取值，属于数组对象</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);  <span class="hljs-comment">// new出来的新对象</span><br>    System.out.println(i7 == i8);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i9</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// Integer对象</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i10</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;                  <span class="hljs-comment">// 基本数据类型</span><br>    System.out.println(i9 == i10);  <span class="hljs-comment">// true  只要有基本数据类型，就是判断值是否相等!!!</span><br><br>    <span class="hljs-comment">// 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。</span><br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br>    <br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i13</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i14</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>valueOf()</code>源码：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/valueOf%E6%BA%90%E7%A0%81.png" srcset="/img/loading.gif" lazyload alt="valueOf源码"></p><p><strong>解读：</strong></p><ul><li>当传入的参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</li><li>当传入的参数不在 -128~127 范围时，直接创建新对象。</li></ul><p><code>**IntegerCache.cache**</code><strong>数组（部分）</strong>：</p><p>该数组由包装类<code>Integer</code>创建，大小为 256，存储了 -128~127</p><p><strong>Character</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">isDigit</span><span class="hljs-params">()</span></span>`方法：确定指定的字符是否为数字，返回`boolean<br></code></pre></td></tr></table></figure><p>示例：判断字符串是否都为数字组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断一个字符串是否都为数字组成</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span> ( !(Character.isDigit(str.charAt(i))) ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Java/" class="category-chain-item">Java</a> <span>></span> <a href="/categories/Java/Java%E5%9F%BA%E7%A1%80/" class="category-chain-item">Java基础</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/" class="print-no-link">#Java</a></div></div><div class="license-box my-3"><div class="license-title"><div>Java 数据类型</div><div>https://blog-21n.pages.dev/2022/05/25/Java-数据类型/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Neo</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年5月25日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/05/30/Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="Java 基本语法"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Java 基本语法</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/05/24/Java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java 基础概念"><span class="hidden-mobile">Java 基础概念</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>