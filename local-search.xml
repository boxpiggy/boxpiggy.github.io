<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis实现在线人数统计功能</title>
    <link href="/2024/08/10/Redis%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
    <url>/2024/08/10/Redis%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在线人数统计有多种实现方式，本文使用 Redis 的有序集合数据类型来实现。</p><p>核心方法：<code>zadd</code>、<code>zrangeByScore</code>、<code>zremrangeByScore</code>、<code>zrem</code>。</p><h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><h2 id="如何认定用户是否在线？"><a href="#如何认定用户是否在线？" class="headerlink" title="如何认定用户是否在线？"></a>如何认定用户是否在线？</h2><p>认定用户在线的条件一般跟网站有关，如果网站需要登录才能进入，那么这种网站就是根据用户的token令牌有效性判断是否在线；</p><p>如果网站是公开的，是那种不需要登录就可以浏览的，那么这种网站一般就需要自定一个规则来识别用户，也有很多方式实现如<strong>IP</strong>、<strong>deviceId</strong>、<strong>浏览器指纹</strong>，推荐使用<strong>浏览器指纹</strong>的方式实现。</p><p>浏览器指纹可能包括以下信息的组合：用户代理字符串 (User-Agent string)、HTTP请求头信息、屏幕分辨率和颜色深度、时区和语言设置、浏览器插件详情等。现成的JavaScript库，像 FingerprintJS 或 ClientJS，可以帮助简化这个过程，因为它们已经实现了收集上述信息并生成唯一标识的算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 安装：npm install @fingerprintjs/fingerprintjs</span><br><br><span class="hljs-comment">// 使用示例：</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">FingerprintJS</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fingerprintjs/fingerprintjs&#x27;</span>;<br><br><span class="hljs-comment">// 初始化指纹JS Library</span><br><span class="hljs-title class_">FingerprintJS</span>.<span class="hljs-title function_">load</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">fp</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取访客ID</span><br>  fp.<span class="hljs-title function_">get</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> visitorId = result.<span class="hljs-property">visitorId</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(visitorId);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样就可以获取一个访问公开网站的用户的唯一ID了，当用户访问网站的时候，将这个ID放到访问链接的Cookie或者header中传到后台，后端服务根据这个ID标示用户。</p><h2 id="zadd命令添加在线用户"><a href="#zadd命令添加在线用户" class="headerlink" title="zadd命令添加在线用户"></a><code>zadd</code>命令添加在线用户</h2><p><strong>（1）zadd 命令介绍</strong> </p><p><code>zadd</code> 命令有三个参数 <code>ZADD key score &quot;member&quot;</code>：</p><ul><li><code>key</code>：有序集合的名称。 </li><li><code>score1</code>、<code>score2</code> 等：分数值，可以是整数值或双精度浮点数。 </li><li><code>member1</code>、<code>member2</code> 等：要添加到有序集合的成员。</li></ul><p><strong>示例：</strong>向有序集合<code>myzset</code>中添加一个成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZADD myzset 1 <span class="hljs-string">&quot;one&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（2）添加在线用户标识到有序集合中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// expireTime给用户令牌设置了一个过期时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().plusSeconds(expireTimeout);<br><span class="hljs-type">String</span> <span class="hljs-variable">expireTimeStr</span> <span class="hljs-operator">=</span> DateUtil.formatFullTime(expireTime);<br><span class="hljs-comment">// 添加用户token到有序集合中</span><br>redisService.zadd(<span class="hljs-string">&quot;user.active&quot;</span>, Double.parseDouble(expireTimeStr), userToken);<br></code></pre></td></tr></table></figure><p>由于一个用户可能会重复登录，这就导致<code>userToken</code>也会重复，但为了不重复计算这个用户的访问次数，<code>zadd</code>命令的第二个参数很好的解决了这个问题。</p><p>我这里的逻辑是：每次添加一个在线用户时，利用<strong>当前时间</strong>加上<strong>过期时间</strong>计算出一个分数，可以有效保证当前用户只会存在一个最新的登录态。</p><h2 id="zrangeByScore命令查询在线人数"><a href="#zrangeByScore命令查询在线人数" class="headerlink" title="zrangeByScore命令查询在线人数"></a><code>zrangeByScore</code>命令查询在线人数</h2><p><strong>（1）zrangeByScore命令介绍</strong></p><ul><li><code>key</code>：指定的有序集合的名字。 </li><li><code>min</code> 和 <code>max</code>：定义了查询的分数范围，也可以是 -inf 和 +inf（分别表示“负无穷大”和“正无穷大”）。</li></ul><p><strong>示例：</strong>查询有序集合<code>myzset</code>中分数在 1 到 3 之间的所有成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZRANGEBYSCORE myzset 1 3<br></code></pre></td></tr></table></figure><p><strong>（2）查询当前所有的在线用户</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前的日期</span><br><span class="hljs-type">String</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> DateUtil.formatFullTime(LocalDateTime.now());<br><span class="hljs-comment">// 查询当前日期到&quot;+inf&quot;之间所有的用户</span><br>Set&lt;String&gt; userOnlineStringSet = redisService.zrangeByScore(<span class="hljs-string">&quot;user.active&quot;</span>, now, <span class="hljs-string">&quot;+inf&quot;</span>);<br></code></pre></td></tr></table></figure><p>利用<code>zrangeByScore</code>方法可以查询这个有序集合指定范围内的用户，</p><p>这<code>userOnlineStringSet</code>也就是在线用户集，它的<code>size</code>就是在线人数了。</p><h2 id="zremrangeByScore命令定时清除在线用户"><a href="#zremrangeByScore命令定时清除在线用户" class="headerlink" title="zremrangeByScore命令定时清除在线用户"></a><code>zremrangeByScore</code>命令定时清除在线用户</h2><p><strong>（1）zremrangeByScore命令介绍</strong></p><ul><li><code>key</code>：指定的有序集合的名字。 </li><li><code>min</code> 和 <code>max</code>：定义了查询的分数范围，也可以是 -inf 和 +inf（分别表示“负无穷大”和“正无穷大”）。</li></ul><p> <strong>示例：</strong>删除有序集合<code>myzset</code>分数在 1 到 3 之间的所有成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ZREMRANGEBYSCORE myzset <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>（2）定时清除在线用户</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前的日期</span><br><span class="hljs-type">String</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> DateUtil.formatFullTime(LocalDateTime.now());<br><span class="hljs-comment">// 清除当前日期到&quot;-inf&quot;之间所有的用户</span><br>redisService.zremrangeByScore(<span class="hljs-string">&quot;&quot;</span>user.active<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;-inf&quot;</span>, now);      <br></code></pre></td></tr></table></figure><p>由于有序集合不会自动清理下线的用户，所以这里我们需要写一个定时任务去定时删除下线的用户。</p><h2 id="zrem命令用户退出登录时删除成员"><a href="#zrem命令用户退出登录时删除成员" class="headerlink" title="zrem命令用户退出登录时删除成员"></a><code>zrem</code>命令用户退出登录时删除成员</h2><p><strong>（1）zrem命令介绍</strong></p><ul><li><code>key</code>：指定的有序集合的名字。 </li><li><code>members</code>：需要删除的成员。</li></ul><p><strong>示例：</strong>删除<code>myzset</code>有序集合中名为<code>xxx</code>的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ZREM myzset <span class="hljs-string">&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（2）定时清除在线用户</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除名为xxx的成员</span><br>redisService.zrem(<span class="hljs-string">&quot;user.active&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>);      <br></code></pre></td></tr></table></figure><p>删除<code>zset</code>中的记录，确保主动退出的用户下线。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这种方案的核心逻辑就是，创建一个<strong>在线用户身份集合</strong>为<code>key</code>，利用<strong>用户身份</strong>为<code>member</code>，利用<strong>过期时间</strong>为<code>score</code>，然后对这个集合进行增删改查，实现起来还是比较巧妙和简单的，大家有兴趣可以试试看。</p><hr><p>来源：<a href="https://juejin.cn/post/7356065093060427816">https://juejin.cn/post/7356065093060427816</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Java 编程风格指南</title>
    <link href="/2023/11/14/Google%20Java%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <url>/2023/11/14/Google%20Java%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://hawstein.com/2014/01/20/google-java-style/">https://hawstein.com/2014/01/20/google-java-style/</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h2 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h2><p>在本文档中，除非另有说明：</p><ol><li>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)</li><li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li></ol><p>其他的术语说明会偶尔在后面的文档出现。</p><h2 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h2><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p><h1 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h1><h2 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。</p><h2 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h2><p>源文件编码格式为UTF-8。</p><h2 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h2><h3 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ol><li>所有其它字符串中的空白字符都要进行转义。</li><li>制表符不用于缩进。</li></ol><h3 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h3><p>对于具有特殊<a href="http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">转义序列</a>的任何字符(\b, \t, \n, \f, \r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p><h3 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p><p><em>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</em></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">unitAbbrev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;μs&quot;</span>;                                <span class="hljs-comment">// 赞，即使没有注释也非常清晰</span><br><span class="hljs-type">String</span> <span class="hljs-variable">unitAbbrev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\u03bcs&quot;</span>; <span class="hljs-comment">// &quot;μs&quot;                   // 允许，但没有理由要这样做</span><br><span class="hljs-type">String</span> <span class="hljs-variable">unitAbbrev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\u03bcs&quot;</span>; <span class="hljs-comment">// Greek letter mu, &quot;s&quot;   // 允许，但这样做显得笨拙还容易出错</span><br><span class="hljs-type">String</span> <span class="hljs-variable">unitAbbrev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\u03bcs&quot;</span>;                           <span class="hljs-comment">// 很糟，读者根本看不出这是什么</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\ufeff&#x27;</span> + content; <span class="hljs-comment">// byte order mark            // Good，对于非打印字符，使用转义，并在必要时写上注释</span><br></code></pre></td></tr></table></figure><p><em>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</em></p><h1 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h1><p>一个源文件包含(按顺序地)：</p><ol><li>许可证或版权信息(如有需要)</li><li>package语句</li><li>import语句</li><li>一个顶级类(<strong>只有一个</strong>)</li></ol><p>以上每个部分之间用一个空行隔开。</p><h2 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h2 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h2><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p><h2 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h2><h3 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h3><p>即，不要出现类似这样的import语句：import java.util.*;</p><h3 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h3><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p><h3 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h3><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p><ol><li>所有的静态导入独立成组</li><li>com.google imports(仅当这个源文件是在com.google包下)</li><li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li><li>java imports</li><li>javax imports</li></ol><p>组内不空行，按字典序排列。</p><h2 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h2><h3 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p><p>例外：package-info.java，该文件中可没有package-info类。</p><h3 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h4 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h4><p>当一个类有多个构造函数，或是多个同名方法，这些函数&#x2F;方法应该按顺序出现在一起，中间不要放进其它函数&#x2F;方法。</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p><strong>术语说明</strong>：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p><h2 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h2><h3 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h3><p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p><h3 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h3><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>() &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (condition()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                something();<br>            &#125; <span class="hljs-keyword">catch</span> (ProblemException e) &#123;<br>                recover();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>4.8.1节给出了enum类的一些例外。</p><h3 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if&#x2F;else 或 try&#x2F;catch&#x2F;finally) ，即使大括号内没内容，右大括号也要换行。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br><br>void doNothing() &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h2><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p><h2 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h2><p>每个语句后要换行。</p><h2 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p><p>例外：</p><ol><li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)。</li><li>注释中那些可能被剪切并粘贴到shell中的命令行。</li></ol><h2 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h2><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p><p><em>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</em></p><h3 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p><ol><li>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li><li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如&#x3D;，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(,)与其前面的内容留在同一行。</li></ol><h3 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h2 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h2><h3 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h3><p>以下情况需要使用一个空行：</p><ol><li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。</li></ol><ul><li><ul><li><strong>例外</strong>：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li></ul></li></ul><ol><li>在函数体内，语句的逻辑分组间使用空行。</li><li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li><li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li></ol><p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p><h3 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p><ol><li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li><li>分隔任何保留字与其前面的右大括号(<code>&#125;</code>)(如<code>else, catch</code>)。</li><li>在任何左大括号前(<code>&#123;</code>)，两个例外：</li></ol><ul><li><ul><li><code>@SomeAnnotation(&#123;a, b&#125;)</code>(不使用空格)。</li><li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li></ul></li></ul><ol><li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：</li></ol><ul><li><ul><li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li><li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li><li><code>foreach</code>语句中的分号。</li></ul></li></ul><ol><li>在<code>, : ;</code>及右括号(<code>)</code>)后</li><li>如果在一条语句后做注释，则双斜杠(&#x2F;&#x2F;)两边都要空格。这里可以允许多个空格，但没有必要。</li><li>类型和变量之间：List list。</li><li>数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</li></ol><p><em>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</em></p><h3 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h3><p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p><p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p><p>以下示例先展示未对齐的代码，然后是对齐的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x; <span class="hljs-comment">// this is fine</span><br><span class="hljs-keyword">private</span> Color color; <span class="hljs-comment">// this too</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>   x;      <span class="hljs-comment">// permitted, but future edits</span><br><span class="hljs-keyword">private</span> Color color;  <span class="hljs-comment">// may leave it unaligned</span><br></code></pre></td></tr></table></figure><p><em>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</em></p><h2 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h2><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p><h2 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h2><h3 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p><p>没有方法和文档的枚举类可写成数组初始化的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Suit</span> &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;<br></code></pre></td></tr></table></figure><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h3 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h3><h4 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h4><p>不要使用组合声明，比如int a, b;。</p><h4 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h3 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h3><h4 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span>,<br>    <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h4><p>中括号是类型的一部分：String[] args， 而非String args[]。</p><h3 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h3><p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p><h4 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h4><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p><p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p><h4 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h4><p>在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用&#x2F;&#x2F; fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (input) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        prepareOneOrTwo();<br>        <span class="hljs-comment">// fall through</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        handleOneTwoOrThree();<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        handleLargeNumber(input);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h4><p>每个switch语句都包含一个default语句组，即使它什么代码也不包含。</p><h3 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameIfPresent</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p><strong>例外</strong>：单个的注解可以和签名的第一行出现在同一行。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br><br>@Override public int hashCode() &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br><br>@Partial @Mock DataLoader loader;<br></code></pre></td></tr></table></figure><p>参数和局部变量注解没有特定规则。</p><h3 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h3><h4 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是&#x2F;* … <em>&#x2F;风格，也可以是&#x2F;&#x2F; …风格。对于多行的&#x2F;</em> … <em>&#x2F;注释，后续行必须从</em>开始， 并且与前一行的*对齐。以下示例注释都是OK的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br><br>/*<br> * This is          // And so           /* Or you can<br> * okay.            // is this.          * even do this. */<br> */<br></code></pre></td></tr></table></figure><p>注释不要封闭在由星号或其它字符绘制的框架里。</p><p><em>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用</em> *&#x2F;* … *&#x2F;*<em>。</em></p><h3 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h3><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br><br>public protected private abstract static final transient volatile synchronized native strictfp<br></code></pre></td></tr></table></figure><h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h2><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p><h2 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h2><h3 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h3><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p><h3 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h3><p>类名都以UpperCamelCase风格编写。</p><p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p><h3 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h3><p>方法名都以lowerCamelCase风格编写。</p><p>方法名通常是动词或动词短语。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test<MethodUnderTest>_<state>，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。</p><h3 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h3><p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p><p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Constants</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="hljs-string">&quot;Ed&quot;</span>, <span class="hljs-string">&quot;Ann&quot;</span>);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Joiner</span> <span class="hljs-variable">COMMA_JOINER</span> <span class="hljs-operator">=</span> Joiner.on(<span class="hljs-string">&#x27;,&#x27;</span>);  <span class="hljs-comment">// because Joiner is immutable</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SomeEnum</span> &#123; ENUM_CONSTANT &#125;<br><br><span class="hljs-comment">// Not constants</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">nonFinal</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;non-final&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">nonStatic</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;non-static&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(MyClass.getName());<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] nonEmptyArray = &#123;<span class="hljs-string">&quot;these&quot;</span>, <span class="hljs-string">&quot;can&quot;</span>, <span class="hljs-string">&quot;change&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>这些名字通常是名词或名词短语。</p><h3 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h3><p>非常量字段名以lowerCamelCase风格编写。</p><p>这些名字通常是名词或名词短语。</p><h3 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h3><p>参数名以lowerCamelCase风格编写。</p><p>参数应该避免用单个字符命名。</p><h3 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h3><p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p><p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p><p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p><h3 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li></ul><h2 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h2><p><a href="http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰式命名法</a>分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ol><li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。</li></ol><ul><li><ul><li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li></ul><ol><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：</li></ol><ul><li><ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li></ul><ol><li>最后将所有的单词连接起来得到一个标识符。</li></ol><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">Prose form                Correct               Incorrect<br>------------------------------------------------------------------<br>&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest<br>&quot;new customer ID&quot;         newCustomerId         newCustomerID<br>&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch<br>&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS<br>&quot;YouTube importer&quot;        YouTubeImporter<br>                          YoutubeImporter*<br></code></pre></td></tr></table></figure><p>加星号处表示可以，但不推荐。</p><p><em>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<strong>checkNonempty</strong>和<strong>checkNonEmpty</strong>也都是正确的。</em></p><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h2><p>只要是合法的，就把@Override注解给用上。</p><h2 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)</p><p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br>5<br>6<br>7<br><br>try &#123;<br>  int i = Integer.parseInt(response);<br>  return handleNumericResponse(i);<br>&#125; catch (NumberFormatException ok) &#123;<br>  // it&#x27;s not numeric; that&#x27;s fine, just continue<br>&#125;<br>return handleTextResponse(response);<br></code></pre></td></tr></table></figure><p><strong>例外</strong>：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br>5<br><br>try &#123;<br>  emptyStack.pop();<br>  fail();<br>&#125; catch (NoSuchElementException expected) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br><br>Foo aFoo = ...;<br>Foo.aStaticMethod(); // good<br>aFoo.aStaticMethod(); // bad<br>somethingThatYieldsAFoo().aStaticMethod(); // very bad<br></code></pre></td></tr></table></figure><h2 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h2><p>极少会去重写Object.finalize。</p><p><em>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解</em> <a href="http://books.google.com/books?isbn=8131726592">Effective Java</a> <em>第7条款：“Avoid Finalizers”，然后不要使用它。</em></p><h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><h2 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h2><h3 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h3><p>Javadoc块的基本格式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Multiple lines of Javadoc text are written here,</span><br><span class="hljs-comment"> * wrapped normally...</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(String p1)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>或者是以下单行形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** An especially short bit of Javadoc. */</span><br></code></pre></td></tr></table></figure><p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p><h3 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<p>，并且它和第一个单词间没有空格。</p><h3 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h3><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p><h2 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h2><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a…或This method returns…开头, 它也不会是一个完整的祈使句，如Save the record…。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><p><em>Tip：一个常见的错误是把简单的Javadoc写成</em><em>&#x2F;</em>* @return the customer ID *&#x2F;<strong>，这是不正确的。它应该写成</strong>&#x2F;** Returns the customer ID. *&#x2F;*<em>。</em></p><h2 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h2><p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p><h3 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h3><p>对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><p><em>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<strong>getCanonicalName</strong>， 就不应该忽视文档说明，因为读者很可能不知道词语<strong>canonical name</strong>指的是什么。</em></p><h3 id="7-3-2-例外：重写"><a href="#7-3-2-例外：重写" class="headerlink" title="7.3.2 例外：重写"></a>7.3.2 例外：重写</h3><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p><h3 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p><hr><h1 id="本文来源"><a href="#本文来源" class="headerlink" title="本文来源"></a>本文来源</h1><p>本文档翻译自 <a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html">Google Java Style</a>， 译者 <a href="http://weibo.com/hawstein">@Hawstein</a>。</p><p>出处：<a href="https://hawstein.com/2014/01/20/google-java-style/">https://hawstein.com/2014/01/20/google-java-style/</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>开发效率</category>
      
      <category>规范指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 访问数据库</title>
    <link href="/2023/10/17/Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/10/17/Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为<code>Connection</code>；</p><p>连接到数据库后，需要打开游标，称之为<code>Cursor</code>，通过<code>Cursor</code>执行 SQL 语句，然后，获得执行结果。</p><p>Python 定义了一套操作数据库的 API 接口，任何数据库要连接到 Python，只需要提供符合 Python 标准的数据库驱动即可。</p><h1 id="一、常用数据库"><a href="#一、常用数据库" class="headerlink" title="一、常用数据库"></a>一、常用数据库</h1><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 是一种嵌入式数据库，它的数据库就是一个文件。由于 SQLite 本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在 iOS 和 Android 的 App 中都可以集成。Python 就内置了 SQLite3。</p><h3 id="导入数据库模块"><a href="#导入数据库模块" class="headerlink" title="导入数据库模块"></a>导入数据库模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">import sqlite3<br></code></pre></td></tr></table></figure><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>在 python 中，使用 sqlite3 创建数据库的连接，当我们指定的数据库文件不存在的时候连接对象会自动创建数据库文件；如果数据库文件已经存在，则连接对象不会再创建数据库文件，而是直接打开该数据库文件。</p><p>连接对象可以是<strong>硬盘</strong>上面的数据库文件，也可以是建立在<strong>内存</strong>（memory）中的，在内存中的数据库执行完任何操作后，都不需要提交事务的(commit)</p><p><code>connect</code>方法返回<code>con</code>对象，即是数据库链接对象，它提供了以下方法：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.cursor()</td><td>创建一个游标对象</td></tr><tr><td>.commit()</td><td>处理事务提交</td></tr><tr><td>.rollback()</td><td>处理事务回滚</td></tr><tr><td>.close()</td><td>关闭一个数据库连接</td></tr></tbody></table><h4 id="在硬盘上建立数据库"><a href="#在硬盘上建立数据库" class="headerlink" title="在硬盘上建立数据库"></a>在硬盘上建立数据库</h4><ul><li>数据库的名称不区分大小写，且以第一次建立时的名字为准。</li><li>不加全路径时，数据库文件会自动建立在工程项目文件夹下。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">con=sqlite3.connect(<span class="hljs-string">&quot;D:\Test.db&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="在内存上建立数据库"><a href="#在内存上建立数据库" class="headerlink" title="在内存上建立数据库"></a>在内存上建立数据库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">con = sqlite3.connect(<span class="hljs-string">&quot;memory&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cur = con.cursor()<br></code></pre></td></tr></table></figure><p>游标对象有以下方法支持数据库操作：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.execute()</td><td>用来执行sql语句</td></tr><tr><td>.executemany()</td><td>用来执行多条sql语句</td></tr><tr><td>.close()</td><td>用来关闭游标</td></tr><tr><td>.fetchone()</td><td>用来从结果中取一条记录，并将游标指向下一条记录</td></tr><tr><td>.fetchmany()</td><td>用来从结果中取多条记录。</td></tr><tr><td>.fetchall()</td><td>用来从结果中取出所以记录。</td></tr><tr><td>.scroll()</td><td>用于游标滚动。</td></tr></tbody></table><p>注意：使用游标的方法返回的数据类型是列表。</p><h3 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h3><h3 id="事务提交或回滚"><a href="#事务提交或回滚" class="headerlink" title="事务提交或回滚"></a>事务提交或回滚</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提交</span><br>con.commit()<br><br><span class="hljs-comment"># 回滚</span><br>con.rollback()<br><br><span class="hljs-comment"># 关闭游标</span><br>cur.close()<br><span class="hljs-comment"># 关闭数据库连接</span><br>con.close()<br></code></pre></td></tr></table></figure><p>注意：一定要先关闭游标，再关闭数据库连接，否则会报错！</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>SQLite 的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用。而MySQL 是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于 SQLite。</p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>由于 MySQL 服务器以独立的进程运行，并通过网络对外服务，所以，需要支持 Python 的 MySQL 驱动来连接到 MySQL 服务器。</p><p>MySQL 官方提供了 mysql-connector-python 驱动，但是安装的时候需要给 <code>pip</code> 命令加上参数<code>--allow-external</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install mysql-connector-python --allow-external mysql-connector-python<br><span class="hljs-comment"># 如果上面的命令安装失败，可以试试另一个驱动：</span><br>pip install mysql-connector<br></code></pre></td></tr></table></figure><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 导入MySQL驱动:</span><br>&gt;&gt;&gt; import mysql.connector<br><br><span class="hljs-comment"># 注意把password设为你的root口令:</span><br>&gt;&gt;&gt; conn = mysql.connector.connect(user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&#x27;password&#x27;</span>, database=<span class="hljs-string">&#x27;test&#x27;</span>)<br>&gt;&gt;&gt; cursor = conn.cursor()<br><br><span class="hljs-comment"># 创建user表:</span><br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;</span>)<br><br><span class="hljs-comment"># 插入一行记录，注意MySQL的占位符是%s:</span><br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;insert into user (id, name) values (%s, %s)&#x27;</span>, [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>])<br>&gt;&gt;&gt; cursor.rowcount<br>1<br><br><span class="hljs-comment"># 提交事务:</span><br>&gt;&gt;&gt; conn.commit()<br>&gt;&gt;&gt; cursor.close()<br><br><span class="hljs-comment"># 运行查询:</span><br>&gt;&gt;&gt; cursor = conn.cursor()<br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;select * from user where id = %s&#x27;</span>, (<span class="hljs-string">&#x27;1&#x27;</span>,))<br>&gt;&gt;&gt; values = cursor.fetchall()<br>&gt;&gt;&gt; values<br>[(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>)]<br><br><span class="hljs-comment"># 关闭Cursor和Connection:</span><br>&gt;&gt;&gt; cursor.close()<br>True<br>&gt;&gt;&gt; conn.close()<br></code></pre></td></tr></table></figure><h1 id="二、使用-ORM-框架"><a href="#二、使用-ORM-框架" class="headerlink" title="二、使用 ORM 框架"></a>二、使用 ORM 框架</h1><h2 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>数据库表是一个二维表，包含多行多列。把一个表的内容用 Python 的数据结构表示出来的话，可以用一个<code>list</code>表示多行，<code>list</code>的每一个元素是 <code>tuple</code>，表示一行记录，比如，包含<code>id</code>和<code>name</code>的<code>use</code> 表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[<br>    (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>),<br>    (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>),<br>    (<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure><p>Python 的 DB-API 返回的数据结构就是像上面这样表示的。</p><p>但是用<code>tuple</code>表示一行很难看出表的结构。如果把一个<code>tuple</code>用 <code>class</code> 实例来表示，就可以更容易地看出表的结构来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br><br>[<br>    User(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>),<br>    User(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>),<br>    User(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure><p>这就是传说中的 ORM 技术：<strong>Object-Relational Mapping</strong>，把<strong>关系数据库的表结构映射到对象上</strong>。</p><p>但是由谁来做这个转换呢？</p><p>所以 ORM 框架应运而生。在 Python 中，最有名的 ORM 框架是 SQLAlchemy。我们来看看 SQLAlchemy 的用法。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install sqlalchemy<br></code></pre></td></tr></table></figure><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SQLAlchemy 的初始化和对象定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入:</span><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, String, create_engine<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker<br><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br><br><span class="hljs-comment"># 创建对象的基类:</span><br>Base = declarative_base()<br><br><span class="hljs-comment"># 定义User对象:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    <span class="hljs-comment"># 表的名字:</span><br>    __tablename__ = <span class="hljs-string">&#x27;user&#x27;</span><br><br>    <span class="hljs-comment"># 表的结构:</span><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br><br><span class="hljs-comment"># 初始化数据库连接:</span><br>engine = create_engine(<span class="hljs-string">&#x27;mysql+mysqlconnector://root:password@localhost:3306/test&#x27;</span>)<br><span class="hljs-comment"># 创建DBSession类型:</span><br>DBSession = sessionmaker(bind=engine)<br></code></pre></td></tr></table></figure><p>以上代码完成 SQLAlchemy 的初始化和具体每个表的class定义。</p><p>create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：</p><p>‘数据库类型+数据库驱动名称:&#x2F;&#x2F;用户名:口令@机器地址:端口号&#x2F;数据库名’</p><p>如果有多个表，就继续定义其他 class，例如 School：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;school&#x27;</span><br>    <span class="hljs-built_in">id</span> = ...<br>    name = ...<br></code></pre></td></tr></table></figure><h4 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h4><p>由于有了 ORM，我们向数据库表中添加一行记录，可以视为添加一个<code>User</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建session对象:</span><br>session = DBSession()<br><span class="hljs-comment"># 创建新User对象:</span><br>new_user = User(<span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;5&#x27;</span>, name=<span class="hljs-string">&#x27;Bob&#x27;</span>)<br><span class="hljs-comment"># 添加到session:</span><br>session.add(new_user)<br><span class="hljs-comment"># 提交即保存到数据库:</span><br>session.commit()<br><span class="hljs-comment"># 关闭session:</span><br>session.close()<br></code></pre></td></tr></table></figure><p>可见，关键是获取<code>session</code>，然后把对象添加到<code>session</code>，最后提交并关闭。</p><p><code>DBSession</code> 对象可视为当前数据库连接。</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>有了ORM，查询出来的可以不再是<code>tuple</code>，而是<code>User</code>对象。SQLAlchemy 提供的查询接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建Session:</span><br>session = DBSession()<br><span class="hljs-comment"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:</span><br>user = session.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span>==<span class="hljs-string">&#x27;5&#x27;</span>).one()<br><span class="hljs-comment"># 打印类型和对象的name属性:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;type:&#x27;</span>, <span class="hljs-built_in">type</span>(user))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, user.name)<br><span class="hljs-comment"># 关闭Session:</span><br>session.close()<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.User&#x27;</span>&gt;<br>name: Bob<br></code></pre></td></tr></table></figure><h4 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h4><p>由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM 框架也可以提供两个对象之间的一对多、多对多等功能。</p><p>例如，如果一个<code>User</code>拥有多个<code>Book</code>，就可以定义一对多关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;user&#x27;</span><br><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br>    <span class="hljs-comment"># 一对多:</span><br>    books = relationship(<span class="hljs-string">&#x27;Book&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;book&#x27;</span><br><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br>    <span class="hljs-comment"># “多”的一方的book表是通过外键关联到user表的:</span><br>    user_id = Column(String(<span class="hljs-number">20</span>), ForeignKey(<span class="hljs-string">&#x27;user.id&#x27;</span>))<br></code></pre></td></tr></table></figure><p>当我们查询一个<code>User</code>对象时，该对象的<code>books</code>属性将返回一个包含若干个<code>Book</code>对象的<code>list</code>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="executemany"><a href="#executemany" class="headerlink" title="executemany()"></a>executemany()</h4><p>在<code>executemany()</code>方法中，参数列表需要是一个可迭代对象，并且每个元素都需要是一个序列（例如列表、元组等）。这是为了支持批量执行多次操作。</p><p>为了满足<code>executemany()</code>方法的要求，需要将每个参数以元组形式传递，即使是只有一个值的情况也不例外。这样可以确保参数列表与 SQL 语句中占位符的数量和顺序相匹配，从而正确地执行批量操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 计算生态</title>
    <link href="/2023/08/18/Python-%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81/"/>
    <url>/2023/08/18/Python-%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><p>PyPEF2：处理pdf文件的工具集</p><p>支持获取信息、分隔&#x2F;整合文件、加密解密等</p><p>完全Python语言实现，不需要额外依赖，功能稳定</p><p>NLTK：自然语言文本处理第三方库</p><p>支持语言文本分类、标记、语法句法、语义解析等</p><p>最好的Python自然语言处理库</p><p>Python-docx：创建或更新Microsoft Word文件的第三方库</p><p>提供创建或更新.doc .docx等文件的计算功能</p><p>增加并配置段落、图片、表格、文字等，功能全面</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p><strong>Numpy</strong>：表达N维数组的最基础库</p><ul><li>C语言实现，对外接口是python语言，计算速度优异</li><li>数据分析及科学计算的基础库</li><li>提供直接的矩阵运算、广播函数、线性代数等功能</li><li>Numpy最基础单元是一个数组，数组是一个变量</li></ul><p><strong>Pandas</strong>：Python数据分析高层次应用库</p><ul><li><p>操作索引即操作数据</p></li><li><p>Python最主要的数据分析功能库，基于Numpy开发</p></li><li><p>Pandas核心提供两个数据结构：</p></li><li><ul><li>Series &#x3D; 索引 + 一维数据</li><li>DataFrame &#x3D; 行列索引 + 二维数据</li></ul></li></ul><p>Pandas 库通过扩展了对一维和二维数据的表示，因而能够形成更高层次对数据的操作，简化数据分析的运行</p><p><strong>SciPy</strong>：数学、科学和工程计算功能库</p><ul><li>提供一批数学算法及工程数据运算功能</li><li>雷系Matlab，可用于如傅里叶变换、信号处理等应用</li><li>Python最主要的科学计算功能库，基于Numpy开发</li></ul><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p><strong>Matplotlib</strong>：高质量的二维数据可视化功能库</p><ul><li>通过 matplotlib.pyplot 子库调用各可视化效果（把所有有效的可视化展示方法汇集到一个子库中，相当于各个子库的快捷方式）</li><li>Python最主要的数据可视化功能库，基于Numpy开发</li></ul><p><strong>Seaborn</strong>：统计类数据可视化功能库</p><ul><li>提供了一批高层次统计类数据可视化展示效果</li><li>主要展示数据间分布、分类和线性关系等内容</li><li>基于Matplotlib开发，支持Numpy和Pandas</li></ul><p><strong>Mayavi</strong>：三维科学数据可视化功能库</p><ul><li>提供了一批易用的3D科学计算数据可视化展示效果</li><li>目前版本是Mayavi2，三维可视化最主要的第三方库</li><li>支持Numpy、TVTK、Traits、Envisage等第三方库</li></ul><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p><strong>Scikit-learn</strong>：机器学习方法工具集</p><ul><li>提供聚类、分类、回归、强化学习等计算功能</li><li>机器学习最基本且最优秀的Python第三方库</li></ul><p><strong>TensorFlow</strong>：AlphaGo背后的机器学习计算框架</p><ul><li>谷歌公司推动的开源机器学习框架</li><li>将数据流图作为基础，图节点代表运算，边代表张亮</li><li>应用机器学习方法的一种方式，支撑谷歌人工智能应用</li></ul><p>深度学习</p><p><strong>MXNet</strong>：基于神经网络的深度学习计算框架</p><ul><li>可用于自动驾驶、机器翻译、语音识别等众多领域</li><li>Python最重要的深度学习计算框架</li></ul><h1 id="从Web解析到网络空间"><a href="#从Web解析到网络空间" class="headerlink" title="从Web解析到网络空间"></a>从Web解析到网络空间</h1><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><p>（如何爬下来）</p><p><strong>Requests</strong></p><ul><li>提供了简单易用的类HTTP协议网络爬虫功能</li><li>支持连接池、SSL、Cookies、HTTP(S)代理等</li><li>Python最主要的页面级网络爬虫功能库</li></ul><p><strong>Scrapy</strong>：优秀的网络爬虫框架</p><ul><li>提供了构建网络爬虫系统的框架功能</li><li>框架可理解为功能半成品，很多基础功能已完成，只需要用户进行扩展开发或者额外配置</li><li>支持批量和定时网页爬取、提供数据处理流程等</li><li>Python最主要且最专业的网络爬虫框架</li></ul><p><strong>pyspider</strong>：</p><ul><li>提供完整的网页爬取系统构建功能</li><li>支持数据库后端、消息队列、优先级、分布式架构等</li><li>Python重要的网络爬虫类第三方库</li></ul><h2 id="Web-信息提取"><a href="#Web-信息提取" class="headerlink" title="Web 信息提取"></a>Web 信息提取</h2><p>（爬下来后如何解析html和xml等内容）</p><p><strong>Beautiful Soup</strong>：HTML和XML的解析库</p><ul><li>又名beautifulsoup4或bs4，可以加载多种解析引擎</li><li>常与网络爬虫库搭配使用，如Scrapy、request等</li><li>将HTML页面以树形结构进行组织，通过下行、上行、平行遍历解析其中的内容</li></ul><p><strong>Re</strong>：正则表达式解析和处理功能库</p><ul><li>提供了定义和解析正则表达式的一批通用功能</li><li>可用于各类场景，包括定点的Web信息提取</li><li>Python主要标准库之一</li></ul><p><strong>Python-Goose</strong>：提取文章类型Web页面的功能库</p><ul><li>提供了对Web页面中文章信息&#x2F;视频等元数据的提取功能</li><li>针对特定类型Web页面，应用覆盖面较广</li><li>Python最主要的Web信息提取库</li></ul><h2 id="Web-网站开发"><a href="#Web-网站开发" class="headerlink" title="Web 网站开发"></a>Web 网站开发</h2><p><strong>Django</strong>：最流行的Web应用框架</p><ul><li>提供了构建Web系统的基本应用框架</li><li>MTV模式：模型（model）、模板（Template）、视图（Views）</li><li>Python最重要的Web应用框架，略微复杂，适合比较专业的网站构建</li></ul><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/python-web.png" alt="python-web"></p><p><strong>Pyramid</strong>：规模适中的Web应用框架</p><ul><li>提供了简单方便构建Web系统的应用框架</li><li>规模适中，适合快速构建并适度扩展类应用</li><li>Python产品级Web应用框架，起步简单可扩展性好</li></ul><p><strong>Flask</strong>：Web应用开发微框架</p><ul><li>提供了最简单构建Web系统的应用框架</li><li>特点是：简单、规模小、快速</li><li>Django &gt; Pyramid &gt; Flask</li></ul><h2 id="网络应用开发"><a href="#网络应用开发" class="headerlink" title="网络应用开发"></a>网络应用开发</h2><p><strong>WeRoBot</strong>：微信公众号开发框架</p><ul><li>提供了解析微信服务器消息及反馈消息的功能</li><li>建立微信机器人的重要技术手段</li></ul><p><strong>aip</strong>：百度AI开放平台接口</p><ul><li>提供了访问百度AI服务的Python功能接口</li><li>语音、人脸、OCR、NLP、知识图谱、图像搜索等领域</li><li>Python百度AI应用的最主要方式</li></ul><p><strong>MyQR</strong>：二维码生成第三方库</p><ul><li>提供了生成二维码的系列功能</li><li>基本二维码、艺术二维码和动态二维码</li></ul><h1 id="从人机交互到艺术设计"><a href="#从人机交互到艺术设计" class="headerlink" title="从人机交互到艺术设计"></a>从人机交互到艺术设计</h1><h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><p><strong>PyQt5</strong>：Qt开发框架的Python接口</p><ul><li>提供了创建Qt5程序的Python API接口</li><li>Qt是非常成熟的跨平台桌面应用开发系统，完备GUI</li><li>推荐的Python GUI开发第三方库</li></ul><p><strong>wxPython</strong>：跨平台GUI开发框架</p><ul><li>提供了专用于Python的跨平台GUI开发框架</li><li>理解数据类型与索引的关系，操作索引即操作数据</li><li>Python最主要的数据分析功能库，基于Numpy开发</li></ul><p><strong>PyGObject</strong>：使用GTK+开发GUI的功能库</p><ul><li>提供了整合GTK+、WebKitGTK+等库的功能</li><li>GTK+：跨平台的一种用户图形界面GUI框架</li><li>实例：Anaconda采用该库开发GUI</li></ul><h2 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h2><p><strong>PyGame</strong>：简单的游戏开发功能库</p><ul><li>提供了基于SDL的简单游戏开发功能及实现引擎</li><li>理解游戏对外部输入的响应机制及角色构建和交互机制</li><li>Python游戏入门最主要的第三方库</li></ul><p><strong>Panda3D</strong>：开源、跨平台的3D渲染和游戏开发库</p><ul><li>一个3D游戏引擎，提供Python和C++接口</li><li>支持很多先进特性：法线贴图、光泽贴图、卡通渲染等</li><li>由迪士尼和卡尼吉梅隆大学共同开发</li></ul><p><strong>cocos2d</strong>：构建2D游戏和图形界面交互式应用的框架</p><ul><li>提供了基于OpenGL的游戏开发图形渲染功能</li><li>支持GPU加速，采用树形结构分层管理游戏对象类型</li><li>适用于2D专业级游戏开发</li></ul><h2 id="虚拟现实"><a href="#虚拟现实" class="headerlink" title="虚拟现实"></a>虚拟现实</h2><p><strong>VR Zero</strong>：在树莓派上开发VR应用的Python库</p><ul><li>提供大量与VR开发相关的功能</li><li>针对树莓派的VR开发库，支持设备小型化，配置简单化</li><li>适合初学者实践VR开发及应用</li></ul><p><strong>pyovr</strong>：Oculus Rift的Python开发接口</p><ul><li>针对Oculus VR设备的Python开发库</li><li>基于成熟的VR设备，提供全套文档，工业级应用设备</li><li>Python+虚拟现实领域探索的一种思路</li></ul><p><strong>Vizard</strong>：基于Python的通用VR开发引擎</p><ul><li>专业的企业级虚拟现实开发引擎</li><li>提供详细的官方文档</li><li>支持多种主流的VR硬件设备，具有一定通用性</li></ul><h2 id="图形艺术"><a href="#图形艺术" class="headerlink" title="图形艺术"></a>图形艺术</h2><p><strong>Quads</strong>：迭代的艺术</p><ul><li>对图片进行四分迭代，形成像素风</li><li>可以生成动图或静图图像</li><li>简单易用，具有很高的展示度</li></ul><p><strong>ascii_art</strong>：ASCII艺术库</p><ul><li>将普通图片转为ASCII艺术风格</li><li>输出可以是纯文本或彩色文本</li><li>可采用图片格式输出</li></ul><p><strong>turtle</strong>：海龟绘图体系</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github + hexo 搭建博客过程</title>
    <link href="/2022/12/26/neo-first-blog/"/>
    <url>/2022/12/26/neo-first-blog/</url>
    
    <content type="html"><![CDATA[<p>我是neo，何梓猪的neo，这是我使用hexo搭建的博客~</p><p>这是我的第一篇博客，我想顺便用来记录我的搭建过程。</p><span id="more"></span><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h3><ul><li><p>Node.js（LTS长期支持版）：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><ul><li>安装后包含两个组件：node 和 npm（包管理器）</li></ul></li><li><p>git</p></li></ul><h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><h3 id="1-3-安装国内镜像源-cnpm"><a href="#1-3-安装国内镜像源-cnpm" class="headerlink" title="1.3 安装国内镜像源 cnpm"></a>1.3 安装国内镜像源 cnpm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org # -g：global 全局安装 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证，查看版本号</span> <br>cnpm -v<br></code></pre></td></tr></table></figure><h3 id="1-4-安装-hexo-框架"><a href="#1-4-安装-hexo-框架" class="headerlink" title="1.4 安装 hexo 框架"></a>1.4 安装 hexo 框架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli # -g：全局安装<br></code></pre></td></tr></table></figure><h2 id="二、博客-初始化与启动"><a href="#二、博客-初始化与启动" class="headerlink" title="二、博客 初始化与启动"></a>二、博客 初始化与启动</h2><h3 id="2-1-hexo-init-初始化博客"><a href="#2-1-hexo-init-初始化博客" class="headerlink" title="2.1 hexo init 初始化博客"></a>2.1 hexo init 初始化博客</h3><ol><li>新建一个存放博客资源的目录 blog</li><li>进入上述的 blog 目录，使用初始化命令：<code>hexo init</code></li></ol><p>初始化后，目录中生成了以下文件：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/blog_dir.png" alt="blog_dir"></p><h3 id="2-2-hexo-s-启动博客"><a href="#2-2-hexo-s-启动博客" class="headerlink" title="2.2 hexo s 启动博客"></a>2.2 hexo s 启动博客</h3><p>使用启动命令 <code>hexo s</code> 或者 <code>hexo server</code> 启动并预览博客。</p><p>启动后在本地的<code>4000</code>端口访问：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">D:\blog&gt;hexo s<br><span class="hljs-keyword">INFO</span> Validating config<br><span class="hljs-keyword">INFO</span> <span class="hljs-keyword">Start</span> processing<br><span class="hljs-keyword">INFO</span> Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span>/. Press Ctr1+C <span class="hljs-keyword">to</span> stop.<br></code></pre></td></tr></table></figure><h2 id="三、博客-新建与发布"><a href="#三、博客-新建与发布" class="headerlink" title="三、博客 新建与发布"></a>三、博客 新建与发布</h2><h3 id="3-1-hexo-n-新建博文"><a href="#3-1-hexo-n-新建博文" class="headerlink" title="3.1 hexo n 新建博文"></a>3.1 hexo n 新建博文</h3><p>使用 <code>hexo n</code> 或 <code>hexo new</code> 新建一篇博客文章：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&#x27;neo-first-blog&#x27;</span><br></code></pre></td></tr></table></figure><p>可见，在<code>\blog\source\_posts\</code>目录下生成了一个 <code>.markdown</code> 格式的文件。</p><p>然后就可以通过编辑该<code>.md</code>文件编辑博客内容。</p><h3 id="3-2-hexo-clean-清除缓存"><a href="#3-2-hexo-clean-清除缓存" class="headerlink" title="3.2 hexo clean 清除缓存"></a>3.2 hexo clean 清除缓存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件<code>db.json</code>和已生成的静态文件<code>public</code>。</p><p>网站显示异常时可以执行这条命令试试。</p><h3 id="3-3-hexo-g-生成"><a href="#3-3-hexo-g-生成" class="headerlink" title="3.3 hexo g 生成"></a>3.3 hexo g 生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g # generate<br></code></pre></td></tr></table></figure><p>生成网站静态文件到默认设置的<code>public</code>文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令。</li></ul><h2 id="四、部署到远端仓库"><a href="#四、部署到远端仓库" class="headerlink" title="四、部署到远端仓库"></a>四、部署到远端仓库</h2><h3 id="4-1-新建仓库"><a href="#4-1-新建仓库" class="headerlink" title="4.1 新建仓库"></a>4.1 新建仓库</h3><p>仓库名必须遵循指定格式：<code>owner.github.io</code>，如：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/repo.png" alt="repo"></p><h3 id="4-2-安装git部署插件"><a href="#4-2-安装git部署插件" class="headerlink" title="4.2 安装git部署插件"></a>4.2 安装git部署插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="4-3-添加配置"><a href="#4-3-添加配置" class="headerlink" title="4.3 添加配置"></a>4.3 添加配置</h3><p>打开本地<code>/blog/_config.yml</code>配置文件，在底部添加配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Deployment</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span><br>deploy:<br>  type: git<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">你的仓库地址</span><br>  repo: git@github.com:boxpiggy/boxpiggy.github.io.git<br>  branch: main<br></code></pre></td></tr></table></figure><h3 id="4-4-部署到远程仓库"><a href="#4-4-部署到远程仓库" class="headerlink" title="4.4 部署到远程仓库"></a>4.4 部署到远程仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d  # deploy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>hexo clean     # 清除缓存<br>hexo generate  # 生成静态文件<br>hexo deploy    # 部署到Github<br></code></pre></td></tr></table></figure><p>自动生成网站静态文件，并部署到设定的仓库。</p><p>需要输入目标仓库的用户名（boxpiggy）和密码（***）</p><p>据说部署前要先配置git全局用户：git config –global user.name “xxx”; git config –global user.email</p><p>每次修改完配置都要保存，然后hexo clean &amp; </p><h2 id="五、自定义主题与插件"><a href="#五、自定义主题与插件" class="headerlink" title="五、自定义主题与插件"></a>五、自定义主题与插件</h2><p>Hexo具有很强的自定义能力，可以打开 Hexo的官网，顶栏上就有 Themes 和 Plugins 的入口。</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>首先需要去 Themes 页面找到一款心仪的主题（可以通过点击图片来访问主题的演示站点），然后点击主题的名称进入主题的 GitHub 页面。</p><p>可以通过<code>git clone</code>命令将其克隆至博客根目录下的<code>themes</code>文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">git clone https:<span class="hljs-comment">//github.com/&lt;username&gt;/&lt;reponame&gt;</span><br></code></pre></td></tr></table></figure><p>或者通过 GitHub 自带的下载，下载源码的<code>zip</code>包，将其解压缩至<code>themes</code>文件夹中。</p><p>详细安装流程查看主题的<code>README.MD</code></p><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><p>每个主题文件夹中，都有着自己的<code>_config.yml</code>，管理着这个主题的一些配置，因此如果想要切换主题，在下载下来后，一定要到文件夹中去查看<code>_config.yml</code>的配置，并进行自己的个性化修改。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>本人使用了 Fluid 主题，<a href="https://hexo.fluid-dev.com/docs/guide/">官方文档</a>。</p><p><strong>安装</strong>（hexo 5.0.0 以上版本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p><strong>指定主题：</strong>修改 _config.yml 站点配置文件中的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">theme: fluid<br></code></pre></td></tr></table></figure><p>清除缓存并本地预览：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hexo c &amp; hexo s<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/fluid.png" alt="fluid"></p><p>图片位于：<code>node_modules\hexo-theme-fluid\source\img\</code>目录下</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>而如果是插件，那么就与主题的安装大不相同了。先找到需要的插件，然后再进入到插件的 GitHub 页面，一般在 <code>README.md</code> 中都会详细介绍如何安装。</p><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="①-hexo部署到gitee后无样式问题"><a href="#①-hexo部署到gitee后无样式问题" class="headerlink" title="① hexo部署到gitee后无样式问题"></a>① hexo部署到gitee后无样式问题</h3><details class="lake-collapse"><summary id="u4ba7e748"><span class="ne-text">参考</span></summary><p id="u08f876ee" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="font-size: 14px"></span><a href="https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank" data-href="https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank" target="_blank" class="ne-link"><span class="ne-text">https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank</span></a></p></details><ol><li>修改 <code>_config.yml</code> 配置，添加 <code>url</code> 和 <code>root</code> 两个配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, ......</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://boxpiggy.gitee.io/kingshit</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/kingshit/</span><br></code></pre></td></tr></table></figure><p><code>url</code> 为 Gitee Pages 上的网址</p><p><code>root </code> 为”仓库名”</p><ol start="2"><li>最后更新 Gitee Pages</li></ol><hr><p><strong>参考教程</strong></p><p><a href="https://www.cnblogs.com/visugar/p/6821777.html">https://www.cnblogs.com/visugar/p/6821777.html</a></p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p><p><a href="https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg">https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg</a></p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&vd_source=8a4e439fa8e8c5283477bc164e9a7126">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=8a4e439fa8e8c5283477bc164e9a7126</a></p><p><a href="https://sspai.com/post/59337">https://sspai.com/post/59337</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven安装配置</title>
    <link href="/2022/11/08/Maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/08/Maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Maven核心程序解压与配置"><a href="#一、Maven核心程序解压与配置" class="headerlink" title="一、Maven核心程序解压与配置"></a>一、Maven核心程序解压与配置</h1><h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><p>Maven官网下载：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/maven%E4%B8%8B%E8%BD%BD.png" alt="maven下载"></p><h2 id="2-解压Maven核心程序"><a href="#2-解压Maven核心程序" class="headerlink" title="2. 解压Maven核心程序"></a>2. 解压Maven核心程序</h2><p>核心程序压缩包：<code>apache-maven-3.8.6-bin.zip</code>，解压到非中文目录</p><p>在解压目录中，Maven 核心配置文件：<code>conf / settings.xml</code></p><h2 id="3-指定本地仓库"><a href="#3-指定本地仓库" class="headerlink" title="3. 指定本地仓库"></a>3. 指定本地仓库</h2><p>本地仓库默认值：<code>用户home目录/.m2/repository</code>。（将来仓库中 jar 包越来越多，仓库体积增大，建议不要放在C盘）</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/maven%E6%8C%87%E5%AE%9A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="maven指定本地仓库"></p><h2 id="4-配置镜像仓库（阿里云提供）"><a href="#4-配置镜像仓库（阿里云提供）" class="headerlink" title="4. 配置镜像仓库（阿里云提供）"></a>4. 配置镜像仓库（阿里云提供）</h2><p>Maven 下载 jar 包默认访问境外的中央仓库，速度慢，因此需要改成阿里云提供的镜像仓库。</p><p>配置方式：将<code>&lt;mirror&gt;</code>标签整体复制到核心配置文件 <code>settings.xml</code> 的<code>&lt;mirrors&gt;</code>标签内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">  &lt;mirrorOf&gt;可以设置为哪个中央仓库做镜像，Maven默认中央仓库的id为central </span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">    也有人说新版仓库地址是 https://maven.aliyun.com/repository/public</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-配置-Maven-工程的基础-JDK-版本"><a href="#5-配置-Maven-工程的基础-JDK-版本" class="headerlink" title="5. 配置 Maven 工程的基础 JDK 版本"></a>5. 配置 Maven 工程的基础 JDK 版本</h2><p>如果按照默认配置运行，java工程使用的默认 JDK 版本是1.5，我们可以改成熟悉的 JDK1.8。</p><p>配置方式：将<code>&lt;profile&gt;</code>标签复制到核心配置文件 <code>settings.xml</code> 的<code>&lt;profiles&gt;</code>标签内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="二、配置环境变量"><a href="#二、配置环境变量" class="headerlink" title="二、配置环境变量"></a>二、配置环境变量</h1><h2 id="1-检查-JAVA-HOME-配置是否正确"><a href="#1-检查-JAVA-HOME-配置是否正确" class="headerlink" title="1. 检查 JAVA_HOME 配置是否正确"></a>1. 检查 JAVA_HOME 配置是否正确</h2><p>Maven 是一个用 Java 语言开发的程序，必须基于 JDK 来运行，需要通过 JAVA_HOME 来找到 JDK 的安装位置。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="jdk环境变量"></p><h2 id="2-配置-MAVEN-HOME"><a href="#2-配置-MAVEN-HOME" class="headerlink" title="2. 配置 MAVEN_HOME"></a>2. 配置 MAVEN_HOME</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/MAVEN_HOME%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="MAVEN_HOME环境变量"></p><p>配置环境变量的规律：</p><ul><li>XXX_HOME 通常指向的是 bin 目录的上一级</li><li>PATH 指向的是 bin 目录</li></ul><h2 id="3-配置-PATH"><a href="#3-配置-PATH" class="headerlink" title="3. 配置 PATH"></a>3. 配置 PATH</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%8A%A0%E5%85%A5%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="加入到环境变量"></p><h2 id="4-验证"><a href="#4-验证" class="headerlink" title="4. 验证"></a>4. 验证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn -v<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>开发效率</category>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间日期处理</title>
    <link href="/2022/07/05/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <url>/2022/07/05/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第三代日期类（JDK8）"><a href="#第三代日期类（JDK8）" class="headerlink" title="第三代日期类（JDK8）"></a>第三代日期类（JDK8）</h1><h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><p><code>LocalDateTime</code>：日期时间 &#x2F; 年月日时分秒（<code>LocalDate</code>：日期 &#x2F; 年月日、<code>LocalTime</code>：时间 &#x2F; 时分秒）</p><ul><li><p>表示本地日期和时间。</p></li><li><p>默认严格按照 ISO 8601 规定的日期和时间格式进行打印。</p></li><li><p>ISO 8601 规定的日期和时间分隔符是T。标准格式如下：</p></li><li><ul><li>日期：yyyy-MM-dd</li><li>时间：HH:mm:ss</li><li>带毫秒的时间：HH:mm:ss.SSS</li><li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li><li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li></ul></li><li><p>自定义格式打印需要使用<code>DateTimeFormatter</code>类。</p></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// now(): 获取当前时间</span><br>LocalDateTime.now()<br><br><span class="hljs-comment">// of(): 指定的日期和时间创建 LocalDateTime 实例</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dt2</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2019</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>);<br><br><span class="hljs-comment">// plusXxx(): 日期时间的加减（方法的参数都是long型，返回值都是LocalDateTime）</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">plusYearsResult</span> <span class="hljs-operator">=</span> localDateTime.plusYears(<span class="hljs-number">2L</span>);  <span class="hljs-comment">// 2025-10-30T09:51:26.062</span><br><br><span class="hljs-comment">// 时间 转 字符串</span><br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().format(formatter);  <span class="hljs-comment">// 2023-10-30 09:48:01</span><br><span class="hljs-comment">// 字符串 转 时间</span><br><span class="hljs-type">String</span> <span class="hljs-variable">dateTimeStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-10-30 09:48:11&quot;</span>;<br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> LocalDateTime.parse(dateTimeStr, dtf);  <span class="hljs-comment">// 2023-10-30T09:48:11</span><br><br><span class="hljs-comment">// toInstant 指定时区生成毫秒数（这里指定国际时间 UTC 0，实际上就是 System.currentTimeMillis() + 时区偏移毫秒数）</span><br>LocalDateTime.now().toInstant();<br><span class="hljs-comment">// toEpochSecond(): 获取秒数  .toEpochMilli(): 获取毫秒数</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.of(<span class="hljs-string">&quot;+8&quot;</span>));  <span class="hljs-comment">// 1698630422</span><br></code></pre></td></tr></table></figure><h2 id="格式日期类（DateTimeFormatter）"><a href="#格式日期类（DateTimeFormatter）" class="headerlink" title="格式日期类（DateTimeFormatter）"></a>格式日期类（DateTimeFormatter）</h2><p>格式化类型，取代了<code>SimpleDateFormat</code>。</p><p><strong>示例一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//-----------------------------------------------创建对象---------------------------------------------//</span><br><span class="hljs-comment">// now()方法：获取本地日期时间，总是以当前默认时区返回</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now();  <span class="hljs-comment">//LocalDate.now()  LocalTime.now()</span><br>System.out.println(ldt);  <span class="hljs-comment">//2022-07-05T19:22:21.955</span><br><br><span class="hljs-comment">/// of()方法：指定日期和时间创建对象:</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2017</span>, <span class="hljs-number">1</span>, <span class="hljs-number">29</span>); <span class="hljs-comment">// 2017-1-29</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>); <span class="hljs-comment">// 15:16:17</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dt2</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2017</span>, <span class="hljs-number">1</span>, <span class="hljs-number">29</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>);  <br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dt3</span> <span class="hljs-operator">=</span> LocalDateTime.of(d2, t2);<br>System.out.println(dt2);  <span class="hljs-comment">// 2017-01-29T15:16:17</span><br><br><span class="hljs-comment">// 获取指定属性（年月日时分秒）</span><br>System.out.println(<span class="hljs-string">&quot;年：&quot;</span> + ldt.getYear());  <span class="hljs-comment">// 年：2022</span><br>System.out.println(<span class="hljs-string">&quot;月：&quot;</span> + ldt.getMonthValue());  <span class="hljs-comment">// 月：7  （getMonth()：JULY）</span><br><br><span class="hljs-comment">// 使用DateTimeFormatter格式化日期时间</span><br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);  <span class="hljs-comment">// 创建DateTimeFormatter对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> dtf.format(ldt);<br>System.out.println(<span class="hljs-string">&quot;格式化后：&quot;</span> + format);  <span class="hljs-comment">//格式化后：2022年07月05日 19小时22分钟21秒</span><br><br><span class="hljs-comment">// plusDays(n)：获取n天后的日期时间（其他属性同理）</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> ldt.plusDays(<span class="hljs-number">180</span>);  <span class="hljs-comment">// 180天后，是什么时候</span><br>System.out.println(<span class="hljs-string">&quot;180天后的现在 = &quot;</span> + dtf.format(localDateTime));  <span class="hljs-comment">// 180天后的现在 = 2023年01月01日 19小时19分钟14秒</span><br><br><span class="hljs-comment">//minusMinutes(n)：获取n分钟前的日期时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime1</span> <span class="hljs-operator">=</span> ldt.minusMinutes(<span class="hljs-number">3456</span>);  <span class="hljs-comment">// 3456分钟前是什么时候</span><br>System.out.println(<span class="hljs-string">&quot;3456分钟前是 = &quot;</span> + dtf.format(localDateTime1));  <span class="hljs-comment">// 3456分钟前是 = 2022年07月03日 09小时46分钟21秒</span><br></code></pre></td></tr></table></figure><h2 id="时区（ZoneDateTime）"><a href="#时区（ZoneDateTime）" class="headerlink" title="时区（ZoneDateTime）"></a>时区（ZoneDateTime）</h2><p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p><p>可以简单地把<code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。<code>ZoneId</code>是<code>java.time</code>引入的新的时区类。</p><p><strong>创建ZoneDateTime对象的两种方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. now()方法创建ZonedDateTime对象</span><br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zbj</span> <span class="hljs-operator">=</span> ZonedDateTime.now(); <span class="hljs-comment">// 默认时区</span><br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zny</span> <span class="hljs-operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>)); <span class="hljs-comment">// 用指定时区获取当前时间</span><br>System.out.println(zbj);  <span class="hljs-comment">// 2022-07-05T20:06:24.139+08:00[Asia/Shanghai]</span><br>System.out.println(zny);  <span class="hljs-comment">// 2022-07-05T08:06:24.141-04:00[America/New_York]</span><br><br><span class="hljs-comment">//2. 通过LocalDateTime -&gt; ZonedDateTime (给一个LocalDateTime对象附加一个ZoneId)</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2019</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>);<br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zbj2</span> <span class="hljs-operator">=</span> ldt.atZone(ZoneId.systemDefault());<br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zny2</span> <span class="hljs-operator">=</span> ldt.atZone(ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br>System.out.println(zbj2);  <span class="hljs-comment">//2019-09-15T15:16:17+08:00[Asia/Shanghai]</span><br>System.out.println(zny2);  <span class="hljs-comment">//2019-09-15T15:16:17-04:00[America/New_York]</span><br></code></pre></td></tr></table></figure><h2 id="时间、日期差（Duration-和-Period）"><a href="#时间、日期差（Duration-和-Period）" class="headerlink" title="时间、日期差（Duration 和 Period）"></a>时间、日期差（Duration 和 Period）</h2><p><code>Duration</code>表示两个时刻之间的时间间隔。<code>Period</code>表示两个日期之间的天数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2020</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">19</span>, <span class="hljs-number">48</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">48</span>, <span class="hljs-number">30</span>);<br><span class="hljs-type">Duration</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Duration.between(start, end);<br>System.out.println(d); <span class="hljs-comment">// PT16872H30S</span><br><br><span class="hljs-type">Period</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2020</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>).until(LocalDate.of(<span class="hljs-number">2022</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>));<br>System.out.println(p); <span class="hljs-comment">// P1Y11M4D</span><br></code></pre></td></tr></table></figure><p>代码解释：两个<code>LocalDateTime</code>之间的差值使用<code>Duration</code>表示，<code>PT16872H30S</code>表示16872小时30秒。而两个<code>LocalDate</code>之间的差值用<code>Period</code>表示，<code>P1Y11M4D</code>表示1年11个月4天。</p><p><code>Duration</code>和<code>Period</code>的表示方法也符合ISO 8601的格式，它以<code>P...T...</code>的形式表示。</p><h2 id="时间戳（Instant）"><a href="#时间戳（Instant）" class="headerlink" title="时间戳（Instant）"></a>时间戳（Instant）</h2><p>Java提供的<code>System.currentTimeMillis()</code>返回的就是以毫秒(long类型)表示的当前时间戳。</p><p>这个当前时间戳在<code>java.time</code>中以<code>Instant</code>类型表示，我们用<code>Instant.now()</code>获取当前时间戳，效果和<code>System.currentTimeMillis()</code>类似</p><p>实际上，Instant内部只有两个核心字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> seconds;  <span class="hljs-comment">// 以秒为单位的时间戳</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> nanos;  <span class="hljs-comment">//更精确的纳秒精度</span><br></code></pre></td></tr></table></figure><p>Instant是时间戳，那么，给它附加上一个时区，就可以创建出ZonedDateTime：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Instant</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> Instant.ofEpochSecond(<span class="hljs-number">1568568760</span>);  <span class="hljs-comment">// 以指定时间戳创建Instant:</span><br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zdt</span> <span class="hljs-operator">=</span> ins.atZone(ZoneId.systemDefault());<br>System.out.println(zdt);  <span class="hljs-comment">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure><p>可见，对于某一个时间戳，给它关联上指定的<code>ZoneId</code>，就得到了<code>ZonedDateTime</code>，继而可以获得了对应时区的<code>LocalDateTime</code>。</p><p><code>LocalDateTime</code>，<code>ZoneId</code>，<code>Instant</code>，<code>ZonedDateTime</code>和<code>long</code>都可以互相转换：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/LocalDateTime&ZoneId&ZonedDateTime.png" alt="LocalDateTime&amp;ZoneId&amp;ZonedDateTime"></p><h1 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h1><h2 id="Calendar类（JDK1-1引入）"><a href="#Calendar类（JDK1-1引入）" class="headerlink" title="Calendar类（JDK1.1引入）"></a>Calendar类（JDK1.1引入）</h2><p>1）是一个抽象类，并且构造器是<code>private</code></p><p>2）可以通过<code>getInstance()</code>方法来获取实例</p><p>3）Calendar没有提供对应的格式化的类，需要开发者自己组合显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>System.out.println(c);  <span class="hljs-comment">//java.util.GregorianCalendar[time=1657010957876,areFieldsSet=true,...]</span><br><span class="hljs-comment">//</span><br>System.out.println(<span class="hljs-string">&quot;年：&quot;</span> + c.get(Calendar.YEAR));<br>System.out.println(<span class="hljs-string">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class="hljs-number">1</span>));<br>System.out.println(<span class="hljs-string">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));<br>System.out.println(<span class="hljs-string">&quot;时：&quot;</span> + c.get(Calendar.HOUR));<br>System.out.println(<span class="hljs-string">&quot;分：&quot;</span> + c.get(Calendar.MINUTE));<br>System.out.println(<span class="hljs-string">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));<br><br><span class="hljs-comment">//Calendar没有专门的格式化方法，需要开发者自己组合显式</span><br>System.out.println(c.get(Calendar.YEAR) + <span class="hljs-string">&quot;-&quot;</span> + (c.get(Calendar.MONTH) + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;-&quot;</span> + c.get(Calendar.DAY_OF_MONTH)<br>        + <span class="hljs-string">&quot; &quot;</span> + c.get(Calendar.HOUR_OF_DAY) + <span class="hljs-string">&quot;:&quot;</span> + c.get(Calendar.MINUTE) + <span class="hljs-string">&quot;:&quot;</span> + c.get(Calendar.SECOND));<br></code></pre></td></tr></table></figure><p><strong>前两代的不足</strong></p><p><code>Date</code>类的大多数方法已经在引入<code>Calendar</code>类后被弃用。</p><p>（1）可变性：像日期和时间这样的类应该是不可变的；</p><p>（2）偏移性：<code>Date</code>中年份是从1900开始，而月份都从0开始；</p><p>（3）格式化：格式化类只支持<code>Date</code>，不支持<code>Calendar</code>；</p><p>（4）其他：线程不安全、不能处理闰秒等（每隔2天，多出1s）</p><h1 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h1><h2 id="Date类（JDK1-0引入）"><a href="#Date类（JDK1-0引入）" class="headerlink" title="Date类（JDK1.0引入）"></a>Date类（JDK1.0引入）</h2><p>精确到毫秒，代表特定的瞬间</p><h2 id="SimpleDateFormat类：格式化和解析日期的类"><a href="#SimpleDateFormat类：格式化和解析日期的类" class="headerlink" title="SimpleDateFormat类：格式化和解析日期的类"></a>SimpleDateFormat类：格式化和解析日期的类</h2><p>允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="获取当前系统时间"><a href="#获取当前系统时间" class="headerlink" title="获取当前系统时间"></a>获取当前系统时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();  <span class="hljs-comment">//获取当前系统时间</span><br>System.out.println(<span class="hljs-string">&quot;当前日期 = &quot;</span> + date1);  <span class="hljs-comment">//当前日期 = Tue Jul 05 15:38:28 CST 2022</span><br><br><span class="hljs-comment">//创建 SimpleDateFormat对象，可以指定格式</span><br><span class="hljs-comment">//格式遵循规定</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> sdf.format(date1);<br>System.out.println(<span class="hljs-string">&quot;当前日期 = &quot;</span> + format);  <span class="hljs-comment">//当前日期 = 2022年07月05日 03:49:28 星期二</span><br></code></pre></td></tr></table></figure><h3 id="把一个格式化的-String-转成对应的-Date"><a href="#把一个格式化的-String-转成对应的-Date" class="headerlink" title="把一个格式化的 String 转成对应的 Date"></a>把一个格式化的 String 转成对应的 Date</h3><p>在把<code>String</code> -&gt; <code>Date</code>时，使用的<code>sdf</code>格式需要和给定的<code>String</code>格式一致，否则会抛出转换异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2022年07月05日 03:49:28 星期二&quot;</span>;<br><span class="hljs-type">Date</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> sdf.parse(s);<br><span class="hljs-comment">//得到 Date 仍然按国外形式输出，需要转换</span><br>System.out.println(<span class="hljs-string">&quot;parse = &quot;</span> + parse);  <span class="hljs-comment">//parse = Tue Jul 05 03:49:28 CST 2022</span><br>System.out.println(<span class="hljs-string">&quot;format_parse = &quot;</span> + sdf.format(parse));  <span class="hljs-comment">//format_parse = 2022年07月05日 03:49:28 星期二</span><br></code></pre></td></tr></table></figure><h3 id="通过指定毫秒数得到日期时间"><a href="#通过指定毫秒数得到日期时间" class="headerlink" title="通过指定毫秒数得到日期时间"></a>通过指定毫秒数得到日期时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">999999999</span>);<br>System.out.println(date2);  <span class="hljs-comment">//Mon Jan 12 21:46:39 CST 1970</span><br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>ISO 8601规定的日期和时间分隔符是T。标准格式如下：</p><ul><li>日期：yyyy-MM-dd</li><li>时间：HH:mm:ss</li><li>带毫秒的时间：HH:mm:ss.SSS</li><li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li><li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 异常</title>
    <link href="/2022/06/29/Java-%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/06/29/Java-%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p>Java语言中，程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。</p><p><code>Throwable</code> 类有两个重要的子类：</p><ul><li><p><strong>Exception（异常）</strong>：因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (非受检查异常，可以不处理)。</p></li><li><ul><li>如：空指针访问、试图读取不存在的文件、网络连接中断等等。</li></ul></li><li><p><strong>Error（错误）</strong>：<code>Error</code>属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获。例如 Java 虚拟机运行错误（<code>Virtual</code> MachineError）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p></li></ul><h1 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h1><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE.png" alt="异常体系图"></p><h1 id="受检异常和非受检异常"><a href="#受检异常和非受检异常" class="headerlink" title="受检异常和非受检异常"></a>受检异常和非受检异常</h1><p><strong>受检查异常（Checked Exception）</strong>：Java 代码在编译过程中，如果受检查异常没有被捕获<code>catch</code>或者抛出<code>throws</code>处理的话，就没办法通过编译。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。</p><p><strong>非受检查异常（Unchecked Exception）</strong>：Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code>及其子类都统称为非受检查异常，常见的有：</p><ul><li><code>NullPointerException</code>(空指针异常)</li><li><code>IllegalArgumentException</code>(参数异常 比如方法入参类型异常)</li><li><code>NumberFormatException</code>（字符串转换为数字格式异常，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界异常）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术异常）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><h1 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a><code>Throwable</code>类常用方法</h1><p><code>String getMessage()</code>：返回异常发生时的简要描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>()<span class="hljs-string">`：返回异常发生时的详细信息`</span><span class="hljs-title class_">String</span><br></code></pre></td></tr></table></figure><p><code>getLocalizedMessage()</code>：返回异常对象的本地化信息。使用<code>Throwable</code>的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</p><p><code>void printStackTrace()</code>：在控制台上打印<code>Throwable</code>对象封装的异常信息</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p><code>try-catch-finally</code>：程序员在代码中捕获发生的异常，自行处理。</p><p><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/try-catch-finally%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="try-catch-finally处理机制示意图"></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/throws%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="throws处理机制示意图"></p><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>Java提供<code>try-catch</code>块来处理异常。</p><p><code>try</code>用于包含可能出错得代码；<code>catch</code>块用于处理<code>try</code>块中发生的异常。</p><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>如果异常发生了，异常发生后面的代码不会执行，直接进入到<code>catch</code>块；</li><li>如果异常没有发生，则顺序执行<code>try</code>的代码块，不会进入到<code>catch</code>；</li><li>如果希望不管是否发生异常，都执行某段代码（比如关闭连接、释放资源等），则使用<code>finally&#123;&#125;</code>；</li><li>可以有多个<code>catch</code>语句，捕获不同的异常（进行不同的业务处理），要求子类异常在前，要求父类异常在后（如<code>Exception</code>要在<code>NullPointerException</code>后面）。如果发生异常，只会匹配一个<code>catch</code>；</li><li>可以进行<code>try-finally</code>配合使用，相当于没有捕获异常，因此执行完<code>finally</code>后程序会直接退出。（应用场景：执行一段代码，不管是否发生异常，都必须执行某个业务逻辑。）</li></ol><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol><li>如果没有出现异常，则执行<code>try</code>块中所有语句，不执行<code>catch</code>块中语句，最后还需要执行<code>finally</code>里面的语句（如果有<code>finally</code>）；</li><li>如果出现异常，则直接从异常语句直接跳到<code>catch</code>块中的语句，如果有<code>finally</code>，最后还需要执行<code>finally</code>中的语句</li><li>当在<code>try</code>块或<code>catch</code>块中遇到<code>return</code>语句时，<code>finally</code>语句块将在方法返回之前被执行。（示例1）；</li><li>由于异常已被处理，程序不会崩溃，继续执行下去，因此还要执行<code>try-catch-finally</code>后面的代码</li></ol><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        i++;  <span class="hljs-comment">// i=2</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">if</span> (names[i].equals(<span class="hljs-string">&quot;tom&quot;</span>)) &#123;  <span class="hljs-comment">// 空指针异常</span><br>            System.out.printin(names[<span class="hljs-number">1</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            names[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;jerry&quot;</span>;        <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutofBoundsException e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>        <span class="hljs-keyword">return</span> ++i; <span class="hljs-comment">//i=3 -&gt; </span><br>        <span class="hljs-comment">// 底层会把值保存在临时变量temp=3</span><br>        <span class="hljs-comment">// (由于return不能马上执行，需要先执行finally块的语句)</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ++i;  <span class="hljs-comment">// i=4</span><br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);  <span class="hljs-comment">// i=4</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(string[] args)</span> &#123;<br>    System.out.printin(method());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">i=4<br>3<br></code></pre></td></tr></table></figure><p><strong>注意：不要在</strong><code>**finally**</code><strong>语句块中使用</strong><code>**return**</code><strong>!</strong> 当<code>try/catch</code>语句和<code>finally</code>语句中都有<code>return</code>语句时，<code>try/catch</code>语句块中的<code>return</code>语句会被忽略。这是因为<code>try/catch</code>语句中的<code>return</code>返回值会先被暂存在一个本地变量中，当执行到<code>finally</code>语句中的<code>return</code>之后，这个本地变量的值就变为了<code>finally</code>语句中的<code>return</code>返回值。</p><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p>如果一个方法（中的语句执行时）可能产生某种异常，但是并不确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p><p>在方法声明中用<code>throws</code>语句可以声明抛出异常的列表，<code>throws</code>后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p><h3 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h3><ol><li><p>运行异常，程序中如果没有处理，默认就是<code>throws</code>的方式隐式处理（运行异常有默认处理机制）；</p></li><li><p>如果一个方法有可能抛出多个受查异常类型，必须<code>throws</code>列出所有异常，使用逗号分隔</p></li><li><p>子类重写父类的方法时，对抛出异常的规定：</p></li><li><ol><li>子类重写的方法，所抛出的异常类型要和父类抛出的异常一致或其子类型。</li><li>如果超类方法没有抛出任何受查异常， 子类也不能抛出任何受查异常。</li></ol></li></ol><p>总之，一个方法必须声明或捕获所有可能抛出的<strong>受查异常</strong>， 而<strong>非受查异常</strong>要么不可控制（Error），要么就应该避免发生（RuntimeException）。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>参考<code>Integer.parseInt()</code>方法，抛出异常分为两步：</p><p>1）创建某个<code>Exception</code>的实例；</p><p>2）用<code>throw</code>语句抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span> <span class="hljs-keyword">throws</span> NumberFormatException &#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(<span class="hljs-string">&quot;null&quot;</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><p>⚠ 捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</p><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><ol><li>自定义类（自定义异常类名）</li><li>继承<code>Exception</code>(编译异常)或<code>RuntimeException</code>(运行异常)</li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h2><p>不一定。以下特殊情况下，<code>finally</code>块的代码也不会被执行（<code>finally</code>执行前）：</p><ol><li>虚拟机被终止运行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>    <span class="hljs-comment">// 终止当前正在运行的Java虚拟机</span><br>    System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br>Try to <span class="hljs-keyword">do</span> something<br>Catch Exception -&gt; RuntimeException<br></code></pre></td></tr></table></figure><p>相关issue：<a href="https://github.com/Snailclimb/JavaGuide/issues/190">https://github.com/Snailclimb/JavaGuide/issues/190</a></p><h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 try-with-resources 代替try-catch-finally？</h2><p>适用范围（资源的定义）： 任何实现<code> java.lang.AutoCloseable</code>或者<code>java.io.Closeable</code>的对象</p><p>关闭资源和<code>finally</code>块的执行顺序： 在<code>try-with-resources</code>语句中，任何<code>catch</code>或 <code>finally</code>块在声明的资源关闭后运行</p><blockquote><p>《Effective Java》中明确指出：</p><p>面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。</p></blockquote><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取文本文件的内容</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://read.txt&quot;</span>));<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (scanner != <span class="hljs-literal">null</span>) &#123;<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更好的写法是使用 Java 7 之后的<code>try-with-resources</code>，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。</p><p>使用<code>try(resources)</code> 语句改造上面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;<br>    fnfe.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)));<br>     <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;out.txt&quot;</span>)))) &#123;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">while</span> ((b = bin.read()) != -<span class="hljs-number">1</span>) &#123;<br>        bout.write(b);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。<strong>编译器只看</strong><code>**try(resource = ...)**</code><strong>中的对象是否实现了</strong><code>**java.lang.AutoCloseable**</code><strong>接口</strong>，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p><h2 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h2><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 <code>new</code> 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li><li>……</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面向对象</title>
    <link href="/2022/06/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/06/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、面向对象和面向过程的区别"><a href="#一、面向对象和面向过程的区别" class="headerlink" title="一、面向对象和面向过程的区别"></a>一、面向对象和面向过程的区别</h1><p>面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：</p><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>相较于 POP，OOP 开发的程序一般具有下面这些优点：</p><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><p>在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。</p><p>求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案</p><p><strong>面向对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-comment">// 定义圆的半径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算圆的面积</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算圆的周长</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPerimeter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * Math.PI * radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个半径为3的圆</span><br>        <span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">3.0</span>);<br><br>        <span class="hljs-comment">// 输出圆的面积和周长</span><br>        System.out.println(<span class="hljs-string">&quot;圆的面积为：&quot;</span> + circle.getArea());<br>        System.out.println(<span class="hljs-string">&quot;圆的周长为：&quot;</span> + circle.getPerimeter());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了一个 Circle 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。</p><p><strong>面向过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义圆的半径</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.0</span>;<br><br>        <span class="hljs-comment">// 计算圆的面积和周长</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.PI * radius * radius;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">perimeter</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * Math.PI * radius;<br><br>        <span class="hljs-comment">// 输出圆的面积和周长</span><br>        System.out.println(<span class="hljs-string">&quot;圆的面积为：&quot;</span> + area);<br>        System.out.println(<span class="hljs-string">&quot;圆的周长为：&quot;</span> + perimeter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长。</p><h1 id="二、面向对象三大特征"><a href="#二、面向对象三大特征" class="headerlink" title="二、面向对象三大特征"></a>二、面向对象三大特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><p>就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作【方法】，才能对数据进行操作</p><p><strong>步骤</strong></p><ol><li>对属性进行私有化private 【不能直接修改属性】</li><li>提供一个公共的 public set 方法，用于对属性判断并赋值 public void</li><li>提供一个公共的 public get 方法，用于获取属性的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <span class="hljs-comment">// id属性私有化</span><br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">// name属性私有化</span><br><br>    <span class="hljs-comment">//获取id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-comment">//设置id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-comment">//获取name的方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-comment">//设置name的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造器 与 set 结合</strong></p><p>将 set 方法写在构造器中，仍然可以进行数据验证</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8Eset%E7%BB%93%E5%90%88.png" alt="构造器与set结合"></p><h2 id="继承（Extends）"><a href="#继承（Extends）" class="headerlink" title="继承（Extends）"></a>继承（Extends）</h2><p>继承可以解决代码复用。当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类无需重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承父类即可。</p><p>子类自动拥有父类定义的属性和方法。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="重要规则"><a href="#重要规则" class="headerlink" title="重要规则"></a>重要规则</h3><ol><li>子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过父类提供的公共方法去访问；</li><li>子类必须调用父类的构造器，完成对父类的初始化；</li><li>当创建子类对象时，不管使用子类哪个构造器，默认情况下总会去调用父类的无参构造器（<code>super();</code>）；（示例1）</li><li>如果父类没有无参构造器，则必须在子类的构造器中使用<code>super</code>去指定使用父类哪个构造器完成对父类的初始化工作，否则编译不通过；（示例2）</li><li>如果希望指定去调用父类的某个构造器，则显式地调用一下：<code>super(参数列表);</code></li><li><code>super</code>在使用时，必须放在构造器第一行；（<code>super</code>只能在构造器中使用）</li><li><code>super()</code> 和 <code>this()</code> 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>父类构造器的调用不限于直接父类！将一直往上追溯直到<code>Object</code>类（顶级父类）</li><li>java 是单继承机制：子类只能继承一个父类；</li><li>不能滥用继承关系，子类和父类之间必须满足 is-a 的逻辑关系。（Person is a Music? Music extends Person × Cat is a Animal? Cat extends Animal √ ）</li></ol><p><strong>示例2-1</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.png" alt="构造器调用顺序"></p><p><strong>示例2-2</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%8C%87%E5%AE%9A%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="指定父类构造器"></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="继承内存分析"></p><p><strong>分析：</strong></p><p>（1）首先看子类是否有该属性；</p><p>（2）如果子类有，并且可以访问，则返回信息；（父类相同的属性就无法访问了）</p><p>（3）如果子类没有，就看父类有没有，如果父类有，并且可以访问，就返回信息；</p><p>（4）如果父类没有，就按照（3）的规则，继续找上级父类，知道 Object……</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>代表父类的引用，用于访问父类的属性、方法、构造器。</p><p><strong>调用父类的构造器的好处：</strong>分工明确，父类属性由父类初始化，子类属性由子类初始化。</p><p><strong>基本语法</strong></p><p>访问父类的属性（除<code>private</code>以外），<code>super.field;</code></p><p>访问父类的方法（除<code>private</code>以外），<code>super.method();</code></p><p>访问父类的构造器，<code>super(参数列表);</code> （只能放在构造器第一句，只能出现一句）</p><p><strong>重要规则</strong></p><ol><li><p>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过<code>super</code>。如果没有重名，使用<code>super</code>、<code>this</code>、直接访问是一样的效果。</p></li><li><ol><li><strong>查找同名方法和属性的规则：</strong></li><li>先找本类，如果有，则调用</li><li>如果本类没有，找上一级父类（有，并可以调用，则调用）</li><li>如果父类没有，继续往上找，直到<code>Object</code>类</li><li><code>method()</code>和<code>this.method()</code>等价遵循以上规则，<code>super.method()</code>则直接跳过本类查找父类</li></ol></li><li><p><code>super</code>的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名成员，则遵循就近原则。</p></li></ol><p><strong>super 和 this 的比较</strong></p><table><thead><tr><th></th><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>1</td><td>访问属性</td><td>访问本类中的属性，如果本类没有此属性，则从父类中继续查找</td><td>从父类开始查找属性</td></tr><tr><td>2</td><td>调用方法</td><td>访问本类中的方法，如果本类没有此方法，则从父类中继续查找</td><td>从父类开始查找方法</td></tr><tr><td>3</td><td>调用构造器</td><td>调用本类构造器，必须放在构造器首行</td><td>调用父类构造器，必须放在子类构造器首行</td></tr><tr><td>4</td><td>特殊</td><td>表示当前对象</td><td>子类中访问父类对象</td></tr></tbody></table><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>方法或对象具有多种形态</p><ol><li><p>方法的多态：方法重写和重载就体现多态</p></li><li><p>对象的多态（核心）：</p></li><li><ol><li>一个对象的编译类型和运行类型可以不一致； 如：<code>Animal animal = new Dog();</code></li><li>编译类型在定义对象时，就确定了，不能改变；</li><li>运行类型是可以变化的，可通过<code>getClass()</code>查看运行类型；</li><li>编译类型看定义时<code>=</code>号的左边，运行类型看<code>=</code>号的右边</li></ol></li></ol><h3 id="多态的特点"><a href="#多态的特点" class="headerlink" title="多态的特点"></a>多态的特点</h3><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p><strong>本质：</strong>父类的引用指向了子类的对象</p><p><strong>语法：</strong><code>父类类型 引用名 = new 子类类型();</code></p><p><strong>向上转型调用方法的规则如下：</strong></p><ol><li>可以调用父类中的所有成员（遵守访问权限）；不能调用子类中的特有成员；</li><li>在<strong>编译期</strong>，只能调用父类中声明的方法，但在<strong>运行期</strong>，实际执行的是子类重写父类的方法；</li><li>在编译阶段，能调用哪些成员，是由编译类型来决定的（编译器）；</li><li>最终运行效果看子类的具体实现。</li></ol><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;动物&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;sleep&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;run&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;eat&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;cat eat fish&quot;</span>);&#125;  <span class="hljs-comment">//重写eat方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;cat catch mouse&quot;</span>);&#125;  <span class="hljs-comment">//Cat类特有的catchMouse方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        animal.eat();  <span class="hljs-comment">//输出：cat eat fish</span><br>        animal.run();  <span class="hljs-comment">//输出：run</span><br>        animal.show();  <span class="hljs-comment">//输出：hello</span><br>        animal.sleep();  <span class="hljs-comment">//输出：sleep</span><br>        animal.catchMouse();  <span class="hljs-comment">//报错，因为在编译阶段，能调用哪些成员，是由编译类型来决定的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>语法：<code>子类类型  引用名  =  (子类类型)父类引用;</code></p><ol><li>只能强转父类的引用，不能强转父类的对象；</li><li>要求父类的引用必须指向的是当前目标类型的对象；</li><li>当向下转型后，可以调用子类类型中所有的成员。</li></ol><p>编译类型和运行类型不一致才需要向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//续上示例3</span><br><span class="hljs-comment">//若要调用Cat的 catchMouse方法</span><br><span class="hljs-comment">//向下转型</span><br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal;<br>cat.catchMouse();  <span class="hljs-comment">//输出：cat catch mouse</span><br></code></pre></td></tr></table></figure><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><ol><li><strong>属性</strong>没有重写之说，属性的值看<strong>编译类型</strong>。（示例4）</li></ol><p><strong>示例4</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Base</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>        System.out.println(base.count);  <span class="hljs-comment">//输出 10</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; &#125;<br></code></pre></td></tr></table></figure><ol><li><code>instanceof</code> 比较操作符：用于判断对象的运行类型，是否为XX类型或者XX类的子类型。（示例5）</li></ol><p><strong>示例5</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//续上（示例4）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Sub</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>        System.out.println(sub <span class="hljs-keyword">instanceof</span> Sub);  <span class="hljs-comment">//true</span><br>        System.out.println(sub <span class="hljs-keyword">instanceof</span> Base);  <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><ol><li>当调用对象<strong>方法</strong>时，该方法会和该对象的内存地址&#x2F;运行类型绑定</li><li>当调用对象<strong>属性</strong>时，没有动态绑定机制，哪里声明，哪里使用。</li></ol><p><strong>示例6</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicBinding</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        System.out.println(a.sum());  <span class="hljs-comment">// 30</span><br>        System.out.println(a.sum1());  <span class="hljs-comment">// 20</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getI() + <span class="hljs-number">10</span>;  <span class="hljs-comment">//调用运行类型的 getI() 方法 </span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//先找局部变量，局部变量没有i，再找属性，属性有则返回 i+10=&gt;10+10</span><br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">10</span>;  <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">//public int sum() &#123;</span><br>    <span class="hljs-comment">//    return i + 20;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">//属性没有动态绑定机制，哪里声明就使用哪里的，使用的是B类的属性i = 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h3><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</p><p><strong>示例7</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// Student对象 和 Teacher对象，统一放在数组中，并调用每个对象的say方法</span><br>    Person[] persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[<span class="hljs-number">3</span>];<br>    persons[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">20</span>);<br>    persons[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;shit&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-number">99</span>);<br>    persons[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;boxpig&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20000</span>);<br><br>    <span class="hljs-comment">//循环遍历多态数组，调用say</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; persons.length; i++) &#123;<br>        <span class="hljs-comment">//persons[i] 编译类型是Person，运行类型是根据实际情况由JVM判断</span><br>        System.out.println(persons[i].say());  <span class="hljs-comment">//动态绑定机制</span><br>        <span class="hljs-comment">// 使用类型判断+向下转型</span><br>        <span class="hljs-comment">// 判断persons[i] 的运行类型是不是Student</span><br>        <span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Student) &#123;  <br>            <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) persons[i];  <span class="hljs-comment">//向下转型</span><br>            student.study();<br>            <span class="hljs-comment">//以上等价于 ((Student) persons[i]).study();</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (persons[i] <span class="hljs-keyword">instanceof</span> Teacher)&#123;<br>            ((Teacher) persons[i]).teach();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;你的类型有误...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p>方法定义的形参类型为父类类型，实参类型允许为子类类型。</p><h1 id="三、接口与抽象类"><a href="#三、接口与抽象类" class="headerlink" title="三、接口与抽象类"></a>三、接口与抽象类</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名 &#123;<br>    <span class="hljs-comment">//属性 总是(自带) public static final</span><br>    <span class="hljs-comment">//方法（ 1.抽象方法   2.默认实现方法   3.静态方法 ）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//接口中的抽象方法，public abstract可以省略</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;我是默认实现方法&quot;</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;我是静态方法&quot;</span>); &#125;<br>&#125;<br><br>class 类名 implements 接口 &#123;<br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-comment">//必须实现的接口的抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认方法和静态方法是 jdk8 新增，jdk7 以前接口内所有方法均无方法体，即都是抽象方法。</li><li>接口中的<strong>方法</strong>会被隐式的指定为 <code>public abstract</code></li><li>接口中的<strong>变量</strong>会被隐式的指定为 <code>public static final</code> 变量</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>由于自带<code>static</code>，接口中属性的访问语法：<code>接口名.属性名</code></li><li>一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是<code>public</code>；（IDEA快捷键：ctrl+i 或 alt shift enter）</li><li>抽象类实现接口，可以不用实现抽象方法；</li><li>接口支持多继承；（一个接口不能继承其他类，但是可以继承多个别的接口）</li><li>一个类可以同时实现多个接口；</li><li>接口的修饰符只能是 public 和 默认，这点和类一样。</li></ul><h3 id="为什么需要接口？"><a href="#为什么需要接口？" class="headerlink" title="为什么需要接口？"></a>为什么需要接口？</h3><ul><li>接口比抽象类还要抽象，可以更加规范地对子类进行约束，全面地实现了：规范和具体实现的分离。</li><li>接口就是规范，定义的是一组规则。本质是契约。</li><li>项目的具体需求是多变的，开发要以不变（规范）应万变。因此开发项目往往都是面向接口编程。</li></ul><p><strong>实现类可以不必覆写</strong><code>**default**</code><strong>方法。</strong><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><h3 id="接口的多态性"><a href="#接口的多态性" class="headerlink" title="接口的多态性"></a>接口的多态性</h3><p>接口引用可以指向实现了该接口的对象实例。</p><p>示例3-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IF</span> <span class="hljs-variable">if01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();    <span class="hljs-comment">//接口类型的变量 if01 可以指向 实现了IF接口的对象实例</span><br>        <span class="hljs-type">IF</span> <span class="hljs-variable">if02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>示例3-2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Camera</span> <span class="hljs-variable">camera</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        <span class="hljs-comment">//把手机、相机对象接入计算机</span><br>        computer.work(camera);<br>        computer.work(phone);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br>    <span class="hljs-comment">//1. UsbInterface usbInterface 形参是接口类型 UsbInterface</span><br>    <span class="hljs-comment">//2. 可以接收（实现了UsbInterface接口的类的）对象实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(UsbInterface usbInterface)</span> &#123;<br>        <span class="hljs-comment">//通过接口来调用方法</span><br>        usbInterface.start();<br>        usbInterface.stop();    <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//USB接口，规定接口的相关规范（方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//手机实现USB接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//相机实现USB接口</span><br></code></pre></td></tr></table></figure><p>示例3-3（多态数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//多态数组 -&gt; 接口类型数组</span><br>        Usb[] usbs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Usb</span>[<span class="hljs-number">2</span>];<br>        usbs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        usbs[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        <span class="hljs-comment">//输出数组对象的方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; usbs.length; i++) &#123;<br>            usbs[i].work();  <span class="hljs-comment">//动态绑定...</span><br>            <span class="hljs-keyword">if</span> (usbs[i] instance of Phone) &#123;  <span class="hljs-comment">//判断运行类型是否为Phone，是才调用手机特有的call方法</span><br>                ((Phone) usbs[i]).call();  <span class="hljs-comment">//向下转型            </span><br>            &#125;        <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Usb</span>&#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>; &#125;  <span class="hljs-comment">//usb接口，规定了work方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;手机可以打电话&quot;</span>); &#125;  <span class="hljs-comment">//手机特有的call方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;手机工作中...&quot;</span>); &#125;  <span class="hljs-comment">//实现手机的work方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;相机工作中...&quot;</span>); &#125;  <span class="hljs-comment">//实现相机的work方法</span><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>手机工作中...<br>手机可以打电话<br>相机工作中...<br></code></pre></td></tr></table></figure><p>接口的多态传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfacePolyPass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 接口类型的变量 可以指向 实现了该接口的类的对象</span><br>        <span class="hljs-type">IA</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>        <span class="hljs-comment">// 如果IB继承了IA接口，而Apple类实现了IB接口，那实际上相当于Apple类也实现了IA接口</span><br>        <span class="hljs-type">IB</span> <span class="hljs-variable">ib</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IA</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IB</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>没有任何方法的接口被称为标记接口。</p><p>标记接口是计算机科学中的一种设计思路，用于给那些面向对象的编程语言描述对象。因为编程语言本身并不支持为类维护元数据，而标记接口可以用作描述类的元数据，弥补了这个功能上的缺失。对于实现了标记接口的类，我们就可以在运行时通过反射机制去获取元数据。</p><p>以<code>Serializable</code>接口为例，如果一个类实现了这个接口，则表示这个类可以被序列化。因此，我们实际上是通过了<code>Serializable</code>这个接口给该类标记了【可被序列化】的元数据，打上了【可被序列化】的标签。这也是标记&#x2F;标签接口名字的由来。</p><p>在Java中，标记接口主要有以下两种目的：</p><ol><li>建立一个公共的父接口。比如<code>EventListener</code>接口，一个由几十个其它接口扩展的Java API，当一个接口继承了EventListener接口，Java虚拟机（JVM）就知道该接口将要被用于一个事件的代理方案。同样的，你可以使用一个标记接口来建立一组接口的父接口。</li><li>向一个类添加数据类型。这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法（因为标记接口根本就没有方法），但是该类通过 Java 的<strong>多态性</strong>可以变成一个接口类型。</li></ol><p>更多的，一些容器例如 Ejb 容器，Servlet 容器或运行时环境依赖标记接口识别类是否需要进行某种处理，比如<code>Serialialbe</code>接口标记类需要进行序列化操作。</p><p>当然了，在现在 Spring 流行的时代，注解（Annotation）已经成为了最好的维护元数据的方式。因为注解能声明在包、类、字段、方法、局部变量、方法参数等之上，既灵活又方便地起到维护元数据的目的。</p><h3 id="Java-8-新增"><a href="#Java-8-新增" class="headerlink" title="Java 8 新增"></a>Java 8 新增</h3><p>Java 8 引入的<code>default</code>方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method in the interface.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 8 引入的<code>static</code>方法无法在实现类中被覆盖，只能通过接口名直接调用（ <code>MyInterface.staticMethod()</code>），类似于类中的静态方法。<code>static</code>方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method in the interface.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 9 允许在接口中使用 <code>private</code> 方法。<code>private</code>方法可以用于在接口内部共享代码，不对外暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-comment">// default 方法</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        commonMethod();<br>    &#125;<br><br>    <span class="hljs-comment">// static 方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        commonMethod();<br>    &#125;<br><br>    <span class="hljs-comment">// 私有静态方法，可以被 static 和 default 方法调用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commonMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a private method used internally.&quot;</span>);<br>    &#125;<br><br>      <span class="hljs-comment">// 实例私有方法，只能被 default 方法调用。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceCommonMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a private instance method used internally.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>是一种模板模式。抽象类为所有子类提供一个通用模板，子类可以在这个模板的基础上进行扩展。</p><p>通过抽象类，可以避免子类设计的随意性。通过抽象类，严格限制子类的设计，使子类之间更加通用。</p><p>抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>有抽象方法的类只能定义为抽象类，抽象类不一定包含抽象方法；</li><li>抽象类不能实例化，即不能用<code>new</code>来实例化抽象类；</li><li>抽象类可以有任何成员（属性、方法、构造方法）【抽象类本质还是类】，但是构造方法不能用来new实例，只能用来被子类调用；</li><li>抽象类只能用来继承；</li><li>如果一个类继承了抽象类，则它必须<strong>实现</strong>抽象类的<strong>所有</strong>抽象方法，除非也声明为抽象类。即抽象方法必须被子类实现。</li><li>抽象方法不能有主体，即不能实现；（不能有{大括号}）</li><li>抽象方法不能用<code>private</code>、<code>final</code>和<code>static</code>来修饰，因为这些关键字都是和重写相违背。</li></ul><h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>把方法的设计与实现分离</p><p>设计：这个类有什么方法、方法的声明（方法名、返回值、形参）</p><p>实现：具体的方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-comment">//抽象类</span><br>    String str; <span class="hljs-comment">//可定义属性</span><br>    <span class="hljs-comment">// 抽象方法，不定义run()方法 (加abstract关键字，不要大括号&#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>; <br><br>    <span class="hljs-comment">// 可定义普通方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;呼吸&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 可以定义构造方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;创造一个动物&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本质是：</p><ul><li>上层代码只定义规范（例如：abstract class Person）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>需求：</strong></p><ol><li>有多个类，完成不同的任务job</li><li>要求统计得到各自完成任务的时间</li></ol><p><strong>设计一个抽象类（Template），能完成如下功能：</strong></p><ol><li>编写方法<code>calculateTime()</code>，可以计算某段代码的耗时时间</li><li>编写抽象方法<code>job()</code></li><li>编写一个子类<code>Sub</code>，继承抽象类<code>Template</code>，并实现<code>job</code>方法</li><li>编写一个测试类<code>TestTemplate</code>进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类//抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span> &#123;  <br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-comment">//实现方法，调用job方法，统计job方法的耗时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateTime</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//得到开始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        job();  <span class="hljs-comment">//动态绑定机制</span><br><br>        <span class="hljs-comment">//得到结束时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;任务执行时间：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//子类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ajob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;<br>    <span class="hljs-comment">//计算任务A</span><br>    <span class="hljs-comment">//1+2+3+...+100000</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//实现了父类Template的抽象方法job</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000000</span>; i++) &#123;<br>            num += i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//子类B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bjob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;<br>    <span class="hljs-comment">//计算任务B</span><br>    <span class="hljs-comment">//1*2*3*...*800000</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">800000</span>; i++) &#123;<br>            num *= i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类和接口的异同点"><a href="#抽象类和接口的异同点" class="headerlink" title="抽象类和接口的异同点"></a>抽象类和接口的异同点</h2><p>接口和抽象类的共同点</p><p><strong>实例化</strong>：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</p><p><strong>抽象方法</strong>：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</p><p>接口和抽象类的区别</p><p><strong>设计目的</strong>：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p><p><strong>继承和实现</strong>：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。</p><p><strong>成员变量</strong>：接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（private, protected, public），可以在子类中被重新定义或赋值。</p><p><strong>方法</strong>： </p><ul><li>Java 8 之前，接口中的方法默认是 <code>public abstract</code> ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 default（默认） 方法和 static （静态）方法。 自 Java 9 起，接口可以包含 private 方法。</li><li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li></ul><h1 id="四、类与对象"><a href="#四、类与对象" class="headerlink" title="四、类与对象"></a>四、类与对象</h1><h2 id="类与对象关系"><a href="#类与对象关系" class="headerlink" title="类与对象关系"></a>类与对象关系</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="类与对象的关系"></p><h2 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a>属性&#x2F;成员变量</h2><ol><li>从概念或叫法上看：成员变量 &#x3D; 属性 &#x3D; 字段（field）。</li><li>属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象、数组）。</li><li>属性的定义语法：访问修饰符 属性类型 属性名  示例：<code>protected String name;</code>。</li><li>属性的定义类型可以为任意类型，包括基本类型和引用类型。</li><li>属性如果没有赋值，有默认值，规则和数组一致：int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u0000, boolean false, String null;</li></ol><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><ol><li>先声明后创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Cat cat;<br>cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><ul><li>对象名 cat 在栈指向一个空的空间</li><li>在堆开辟空间，同时分配地址（只要有数据空间，就会有地址），把地址赋给 cat 对象名</li></ul><ol><li>直接创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>先在<strong>方法区</strong>加载<code>Cat</code>类信息（<strong>属性</strong>和<strong>方法</strong>信息，只会加载一次）；</li><li>在堆中分配空间，进行默认初始化；</li><li>把地址赋给<code>whiteCat</code>，<code>whiteCat</code>就指向对象；</li><li>进行指定初始化，比如  <code>whiteCat.name = &quot;小白&quot;;</code> <code>whiteCat.age = 6;``whiteCat.color = &quot;white&quot;;</code></li></ol><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="类与对象的内存布局"></p><p><strong>⚠</strong> <strong>JDK1.7 ，字符串常量池和静态变量从永久代（方法区）移动了 Java 堆中</strong></p><p>永久代是方法区的具体实现，和堆一样都是由 JVM 管理的运行时数据区域，但堆有更高的 GC 回收效率，因此把需要大量进行字符串回收的字符串常量池移到堆中。</p><p>JDK1.8 ，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存，不受 JVM 内存的限制。</p><p>详见：<a href="https://www.yuque.com/kingshit/java/crf342hk3xb326g3">Java内存区域详解</a></p><h3 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h3><p><strong>栈</strong>：一般存放基本数据类型（局部变量）</p><p><strong>堆</strong>：存放对象（Cat cat，数组等）</p><p><strong>方法区</strong>：常量池（常量，比如字符串），类加载信息</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%EF%BC%88jdk1.7%E4%BB%A5%E5%89%8D%EF%BC%89.png" alt="类与对象内存分配机制（jdk1.7以前）"></p><h3 id="对象创建的流程分析"><a href="#对象创建的流程分析" class="headerlink" title="对象创建的流程分析"></a>对象创建的流程分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="对象创建的流程分析"></p><p>jdk 1.7以前</p><p><strong>流程分析：</strong></p><ol><li>加载类信息（Xxx.class），只会加载一次</li><li>在堆中分配空间（地址）</li><li>完成对象初始化（默认初始化、显式初始化、构造器初始化）</li><li>把对象在堆中的地址返回给对象的引用（对象名）</li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="方法调用机制"><a href="#方法调用机制" class="headerlink" title="方法调用机制"></a>方法调用机制</h3><p>方法执行会开辟一个独立的栈空间，方法执行完毕该空间就会释放。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6.png" alt="方法调用机制"></p><center>（jdk 1.7以前）</center><p><strong>同一类中的方法调用</strong>：直接调用</p><p><strong>跨类中的方法调用</strong>：需要先创建对象，通过对象名调用</p><h3 id="成员方法的定义"><a href="#成员方法的定义" class="headerlink" title="成员方法的定义"></a>成员方法的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">访问修饰符 返回数据类型 方法名(形参列表...)&#123;  <span class="hljs-comment">// 方法体</span><br>    语句；<br>    返回值；<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>访问修饰符：控制方法使用的范围，public、protected、默认（不写）、private</p></li><li><p>形参列表：表示成员方法输入 ；</p></li><li><ol><li>可以有0或多个参数，用逗号分隔；</li><li>参数类型可以为任意类型，包括基本和引用类型；</li><li>调用带参数的方法时，一定要对应着参数列表传入相同类型或兼容类型的参数；</li><li>方法定义时的参数成为形式参数（形参&#x2F;虚参）；方法调用时传入的参数成为实际参数（实参）；实参和形参的类型要一致或兼容，个数、顺序也要一致；</li></ol></li><li><p>返回数据类型：表示成员方法输出，void 表示没有返回值：</p></li><li><ol><li>一个方法最多有一个返回值；（如果要返回多个值，可以声明数组类型）</li><li>返回类型可以为任意类型，包括基本和引用类型；</li><li>如果方法声明了返回数据类型，则方法体中最后的执行语句必须为 return 值；而且要求返回值类型必须和return的值类型一致或兼容</li><li>如果方法是 void，不能有返回值，方法体中可以没有 return 语句，或者只写 return；</li></ol></li><li><p>方法体：表示为了实现某一功能代码块；</p></li><li><ol><li>写完成功能的具体语句，可以为输入输出、变量、运算、分支、循环、方法调用等，但不能再定义方法，即方法不能嵌套定义。</li></ol></li><li><p><code>return</code> 语句不是必须的。</p></li></ol><h3 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p><code>AA</code>类中编写一个方法<code>swap</code>，接收两个整数，在方法中交换两个数，主方法中声明两个数，调用<code>swap</code>方法，看两数是否发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>        <span class="hljs-type">AA</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>();<br>        aa.swap(a, b);<br>        System.out.println(<span class="hljs-string">&quot;main方法：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:8, b:24</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a和b交换前：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:8, b:24</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>        a = b;<br>        b = tmp;<br>        System.out.println(<span class="hljs-string">&quot;a和b交换后：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:24, b:8</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong>基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png" alt="基本数据类型传参机制"></p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>B类中编写一个方法test100，可以接收一个数组，在方法中修改该数组，看原数组是否变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BB</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BB</span>();<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        bb.test100(arr);<br>        <span class="hljs-comment">// 打印数组</span><br>        System.out.println(<span class="hljs-string">&quot;main中的数组：&quot;</span>);  <span class="hljs-comment">// 100 2 3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test100</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;test100中的数组：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong>引用类型，传递的是地址（其实传递也是值，但值是地址），可以通过形参影响实参</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png" alt="引用类型传参机制"></p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>JVM 会给每个对象分配<code>this</code>，代表当前对象。</p><p>简单的说，哪个对象调用，<code>this</code>就代表哪个对象。</p><p><strong>示例</strong></p><p>由于 java 是在虚拟机上跑的，地址是虚拟机的地址，无法直接获取对象的地址。</p><p><code>hashCode()</code>方法会针对不同对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThisTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;皮蛋&quot;</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// 输出dog1对象的哈希值（根据对象内部地址转换）</span><br>        System.out.println(<span class="hljs-string">&quot;dog1 的 hashCode= &quot;</span> + dog1.hashCode());<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;皮球&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 输出dog2对象的哈希值</span><br>        System.out.println(<span class="hljs-string">&quot;dog2 的 hashCode= &quot;</span> + dog2.hashCode());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">27</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">// 构造器</span><br>        <span class="hljs-comment">// 把构造方法的实参赋给属性</span><br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">//this.name 就是当前对象的属性name</span><br>        <span class="hljs-built_in">this</span>.age = age;   <span class="hljs-comment">//this.age 就是当前对象的属性age</span><br>        <span class="hljs-comment">// 测试：当调用构造器初始化对象的时候，输出当前this的哈希值</span><br>        System.out.println(<span class="hljs-string">&quot;this.hashCode= &quot;</span> + <span class="hljs-built_in">this</span>.hashCode());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 成员方法，输出属性x信息</span><br>        System.out.println(name + <span class="hljs-string">&quot;\t&quot;</span> + age + <span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="输出结果"></p><p>由于<code>this</code>指向当前对象，因此<code>this</code>的地址与当前对象地址相同</p><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/this%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="this内存分析"></p><p>jdk 1.7以前</p><p>可以简单理解成（虽然现实可能不会这样）：在对象创建完成后，在堆内隐藏了一个this属性，指向对象本身。</p><h3 id="this-用法"><a href="#this-用法" class="headerlink" title="this 用法"></a>this 用法</h3><ol><li><code>this</code>关键字可以用来访问本类的属性、方法、构造器；</li><li><code>this</code>用于区分当前类的属性和局部变量；</li><li>访问成员方法的语法：<code>this.方法名(参数列表);</code> </li><li>访问构造器语法：<code>this(参数列表);</code>  注意只能在构造器中使用（即只能在构造器中访问另一个构造器），并只能放置在第一条语句；</li><li><code>this</code>不能在类定义的外部使用，只能在类定义的方法中使用。</li></ol><h1 id="五、深拷贝和浅拷贝？什么是引用拷贝？"><a href="#五、深拷贝和浅拷贝？什么是引用拷贝？" class="headerlink" title="五、深拷贝和浅拷贝？什么是引用拷贝？"></a>五、深拷贝和浅拷贝？什么是引用拷贝？</h1><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝的示例代码如下，我们这里实现了<code>Cloneable</code>接口，并重写了<code>clone()</code>方法。</p><p><code>clone()</code>方法的实现很简单，就是直接调用的是父类<code>Object</code>的<code>clone()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Address) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-keyword">return</span> person;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// true</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code>的克隆对象和<code>person1</code>使用的仍然是同一个<code>Address</code> 对象。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>简单对<code>Person</code>类的<code>clone()</code>方法进行修改，连带着要把<code>Person</code>对象内部的<code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        person.setAddress(person.getAddress().clone());<br>        <span class="hljs-keyword">return</span> person;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// false</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出，显然<code>person1</code>的克隆对象和<code>person1</code>包含的<code>Address</code>对象已经是不同的了。</p><h2 id="什么是引用拷贝？"><a href="#什么是引用拷贝？" class="headerlink" title="什么是引用拷贝？"></a>什么是引用拷贝？</h2><p>简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/shallow&deep-copy.png" alt="shallow&amp;deep-copy"></p><h1 id="六、static类变量和类方法"><a href="#六、static类变量和类方法" class="headerlink" title="六、static类变量和类方法"></a>六、<code>static</code>类变量和类方法</h1><h2 id="6-1-静态变量（类变量）"><a href="#6-1-静态变量（类变量）" class="headerlink" title="6.1 静态变量（类变量）"></a>6.1 静态变量（类变量）</h2><p>当我们需要让某个类的所有对象都共享一个变量时，就可以使用。比如：定义学生类，统计所有学生共交多少钱。</p><h3 id="6-1-1-基本概念"><a href="#6-1-1-基本概念" class="headerlink" title="6.1.1 基本概念"></a>6.1.1 基本概念</h3><p><strong>类变量</strong>也叫<strong>静态变量&#x2F;静态属性</strong>，是该类所有对象共享的变量。任何一个该类的对象去访问或修改它时，取到的和修改的都是同一个变量。</p><h3 id="6-1-2-语法"><a href="#6-1-2-语法" class="headerlink" title="6.1.2 语法"></a>6.1.2 语法</h3><p>定义：<code>访问修饰符 static 数据类型 变量名;</code> 【推荐】  或  <code>static 访问修饰符 数据类型 变量名</code></p><p>访问：<code>类名.类变量名</code> 【推荐】或  <code>对象名.类变量名</code></p><h3 id="6-1-3-类变量特点"><a href="#6-1-3-类变量特点" class="headerlink" title="6.1.3 类变量特点"></a>6.1.3 类变量特点</h3><ol><li><code>static</code>变量是同一个类所有对象共享；</li><li><code>static</code>变量是随着类的加载而创建，只执行一次，所以没有创建对象实例也可以访问。</li><li>类变量的访问，也必须遵守相关访问权限</li><li>类变量的生命周期随着类的加载开始，随着类的消亡而销毁。</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8F%98%E9%87%8F.png" alt="类变量"></p><p>jdk 1.7以前（from hsp）</p><blockquote><p><strong>2024-8-3更正上图</strong>：</p><p>方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。而<strong>字符串常量池</strong>、<strong>静态变量</strong> JDK1.7 开始就从永久代（即方法区）移动到了 Java 堆中。（上图的静态域，按我理解是存储静态变量的区域）</p><p>![JDK 1.7](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK</a> 1.7.png)</p></blockquote><h2 id="6-2-静态方法（类方法）"><a href="#6-2-静态方法（类方法）" class="headerlink" title="6.2 静态方法（类方法）"></a>6.2 静态方法（类方法）</h2><p><strong>类方法</strong>也叫<strong>静态方法</strong>。实际开发往往将一些通用的方法设计成静态方法，这样就不需要创建对象就可以使用，提高开发效率。</p><h3 id="6-2-1-语法"><a href="#6-2-1-语法" class="headerlink" title="6.2.1 语法"></a>6.2.1 语法</h3><p>定义：<code>访问修饰符 static 数据返回类型 方法名() &#123; &#125;</code></p><p>调用：<code>类名.类方法名</code>  或  <code>对象名.类方法名</code></p><p>特点</p><ol><li><p>静态方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：</p></li><li><ol><li>静态方法中无this参数；</li><li>普通方法中隐含this参数</li></ol></li><li><p>静态方法可以通过类名调用，也可以通过对象名调用</p></li><li><p>静态方法不中允许使用和对象相关的关键字，比如<code>this</code>和<code>super</code>。</p></li><li><p><strong>静态方法</strong>只能访问静态成员；<strong>普通成员</strong>方法可以访问静态成员和非静态成员。</p></li></ol><h2 id="6-3-main方法"><a href="#6-3-main方法" class="headerlink" title="6.3 main方法"></a>6.3 main方法</h2><p>1）<code>main</code>方法是虚拟机（JVM）调用；</p><p>2）JVM 需要调用类得<code>main()</code>方法，所以该方法得访问权限必须是<code>public</code>；</p><p>3）JVM 在执行<code>main()</code>方法时不必创建对象，所以该方法必须是<code>static</code>；</p><p>4）该方法接收<code>String</code>类型得数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数；</p><p>5）命令：<code>java 运行的类名 arg1 arg2 arg3</code>；</p><p>6）<code>main</code>方法遵循静态方法规则。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/main%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82.png" alt="main方法传参"></p><p>示例6-1：（idea中)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个参数：&quot;</span> + args[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%A4%BA%E4%BE%8B6-1%E7%BB%93%E6%9E%9C.png" alt="示例6-1结果"></p><h1 id="七、代码块"><a href="#七、代码块" class="headerlink" title="七、代码块"></a>七、代码块</h1><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><ul><li><strong>代码块（Code block）</strong>又称为<strong>初始化块</strong>，属于类中的成员【即是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过<code>&#123;&#125;</code>包围起来。</li><li>和方法不同，代码块没有方法名、返回、参数，只有方法体。</li><li>不用通过对象或类显示调用，而是加载类的时候，或创建对象时隐式调用。</li></ul><h2 id="7-2-基本语法"><a href="#7-2-基本语法" class="headerlink" title="7.2 基本语法"></a>7.2 基本语法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[ 修饰符 ] &#123; 代码 &#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>使用<code>static</code>修饰叫<strong>静态代码块</strong>，使用<code>Synchronized</code>修饰叫<strong>同步代码块</strong>；</li><li>分号（<code>;</code>）可以省略。</li></ol><h2 id="7-3-分类"><a href="#7-3-分类" class="headerlink" title="7.3 分类"></a>7.3 分类</h2><p>根据其位置和声明的不同，可以分为：</p><ul><li>局部代码块</li><li>构造代码块</li><li>同步代码块</li><li>静态代码块</li></ul><h3 id="7-3-1-局部代码块"><a href="#7-3-1-局部代码块" class="headerlink" title="7.3.1 局部代码块"></a>7.3.1 局部代码块</h3><p>在方法中出现，可以限定变量生命周期，及早释放，提高内存利用率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 局部代码块</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(number);<br>    &#125;<br>    <span class="hljs-comment">// 找不到number变量</span><br>    <span class="hljs-comment">// System. out.println(number);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-2-构造代码块"><a href="#7-3-2-构造代码块" class="headerlink" title="7.3.2 构造代码块"></a>7.3.2 构造代码块</h3><ul><li>在类中方法外出现，每次调用构造方法都会执行，并且在构造方法前执行。</li><li>相当于另外一种形式的构造器（堆构造器的补充机制），可以做初始化操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlock</span> &#123;<br>    <span class="hljs-comment">// 构造代码块，在方法外出现</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;number1: &quot;</span> + number1);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeBlock</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在构造方法后出现，但构造代码块优先于构造方法执行</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;number2: &quot;</span> + number2);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//构造代码块测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">codeBlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-comment">// 注意：构造代码块通过构造方法自动调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">number1: <span class="hljs-number">10</span><br>number2: <span class="hljs-number">100</span><br>这是构造方法<br></code></pre></td></tr></table></figure><p>因此，构造代码块依赖于构造方法，而且优先于构造方法执行。即实例对象建立，才会运行构造代码块，类不能调用构造代码块。</p><p><strong>构造代码块与构造函数的区别：</strong>构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。</p><p>也就是说，<strong>构造代码块中定义的是不同对象共性的初始化内容</strong>。如果多个构造器中都有重复的语句，可以抽取到构造初始化块中，提高代码的重用性。</p><h3 id="7-3-3-同步代码块"><a href="#7-3-3-同步代码块" class="headerlink" title="7.3.3 同步代码块"></a>7.3.3 同步代码块</h3><p>被 Java 中<code>Synchronized</code>关键词修饰的代码块。</p><blockquote><p><code>Synchronized</code>关键词不仅仅可以用来修饰代码块，与此同时也可以用来修饰方法，是一种线程同步机制，被<code>Synchronized</code>关键词修饰的代码块会被加上内置锁。</p></blockquote><p><strong>作用：</strong>在很多场景，我们没有必要去同步整个方法，而只需要同步部分代码即可，也就是使用同步代码块（JDK源码中有很多应用）。</p><p><code>Synchronized</code>同步代码块是一种高开销的操作，因此我们应该尽量减少被同步的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (CodeBlock.class) &#123;<br>            System.out.print(<span class="hljs-string">&quot;同步代码块!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，静态代码是属于类而不是属于对象的，因此使用<code>Synchronized</code>来修饰静态方法和静态对象的时候，类下的所有对象都会被锁定。</p><h3 id="7-3-4-静态代码块"><a href="#7-3-4-静态代码块" class="headerlink" title="7.3.4 静态代码块"></a>7.3.4 静态代码块</h3><p>使用<code>static</code>修饰的代码块，在类中方法外出现。</p><ul><li>随着<strong>类的加载</strong>而执行，并且只会<strong>执行一次</strong>。</li><li>静态块优先于各种代码块以及构造函数。</li><li>此外静态代码块不能访问普通变量，只能直接调用静态成员。</li></ul><p><strong>作用：</strong>对类进行初始化。</p><p><strong>类什么时候被加载？</strong></p><ol><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时（静态属性、静态方法）</li></ol><h2 id="7-4-执行顺序"><a href="#7-4-执行顺序" class="headerlink" title="7.4 执行顺序"></a>7.4 执行顺序</h2><p><strong>执行时机</strong></p><ul><li><strong>静态代码块</strong>：在类加载到JVM时初始化，且只被执行一次。</li><li><strong>构造代码块</strong>：在创建实例时，会被隐式的调用。每创建一次（每调用构造方法），构造代码块就会执行一次，构造代码块执行的顺序优先于构造器。</li></ul><h3 id="7-4-1-一个类中代码块执行顺序"><a href="#7-4-1-一个类中代码块执行顺序" class="headerlink" title="7.4.1 一个类中代码块执行顺序"></a>7.4.1 一个类中代码块执行顺序</h3><p>创建一个对象时，在一个类调用顺序是：</p><ol><li>执行静态代码块和静态属性的初始化；</li><li>执行构造代码块和普通属性的初始化；</li><li>执行构造方法；</li></ol><blockquote><p>代码块和属性初始化执行优先级一样，若有多个则按照代码定义顺序执行。</p></blockquote><p><strong>总结</strong></p><p><strong>加载类信息</strong>（加载静态代码块和静态属性初始化） -&gt; <strong>创建对象</strong>（加载普通代码块和普通属性初始化） -&gt; <strong>调用构造器</strong></p><h3 id="7-4-2-继承中代码块执行顺序"><a href="#7-4-2-继承中代码块执行顺序" class="headerlink" title="7.4.2 继承中代码块执行顺序"></a>7.4.2 继承中代码块执行顺序</h3><ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）；</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）；</li><li>父类的构造代码块和普通属性（优先级一样，按定义顺序执行）；</li><li>父类的构造方法</li><li>子类的构造代码块和普通属性（优先级一样，按定义顺序执行）；</li><li>子类的构造方法</li></ol><p><strong>总结</strong></p><p>**加载类信息(父→子)**（加载静态代码块和静态属性初始化）-&gt; (父类)<strong>加载构造代码块和普通属性初始化</strong> -&gt; (父类)<strong>调用构造器</strong>  -&gt; (子类)<strong>加载构造代码块和普通属性初始化</strong> -&gt; (子类)<strong>调用构造器</strong></p><blockquote><p>构造器的最前面隐含了<code>super()</code>和<code>&#123;普通代码块&#125;</code>。</p></blockquote><h1 id="八、对象初始化详细过程"><a href="#八、对象初始化详细过程" class="headerlink" title="八、对象初始化详细过程"></a>八、对象初始化详细过程</h1><h2 id="8-1-一个类及其对象初始化的过程"><a href="#8-1-一个类及其对象初始化的过程" class="headerlink" title="8.1 一个类及其对象初始化的过程"></a>8.1 一个类及其对象初始化的过程</h2><h3 id="什么时候需要初始化一个类"><a href="#什么时候需要初始化一个类" class="headerlink" title="什么时候需要初始化一个类"></a>什么时候需要初始化一个类</h3><p>首次创建某个对象时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <br></code></pre></td></tr></table></figure><p>首次访问某个类的静态方法或者静态字段时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Dog.staticFields;<br></code></pre></td></tr></table></figure><p>Java 解释器就会去找类的路径，定位已经编译好的 Dog.class 文件。</p><h3 id="获得类的资源"><a href="#获得类的资源" class="headerlink" title="获得类的资源"></a>获得类的资源</h3><p>然后 jvm 就会载入 <code>Dog.class</code>，生成一个<code>class</code>对象。这个时候如果有静态的方法或者变量，静态初始化动作都会被执行。这个时候要注意啦，静态初始化在程序运行过程中只会在 Class 对象首次加载的时候运行一次。这些资源都会放在 jvm 的<strong>方法区</strong>。</p><p><strong>方法区</strong>又叫<strong>静态区</strong>，跟堆一样，被所有的线程共享。</p><p>方法区中包含的都是在整个程序中永远唯一的元素，包含所有的 class 和 static 变量。</p><h3 id="初始化对象-Dog-dog-new-Dog"><a href="#初始化对象-Dog-dog-new-Dog" class="headerlink" title="初始化对象 Dog dog = new Dog()"></a>初始化对象 <code>Dog dog = new Dog()</code></h3><ol><li>第一次创建<code>Dog</code>对象先执行上面的一二步</li><li>在堆上为<code>Dog</code>对象分配足够的存储空间，所有属性和方法都被设置成默认值(数字为 0，字符为<code>null</code>，布尔为<code>false</code>，而所有引用被设置成<code>null</code>）</li><li>执行构造函数检查是否有父类，如果有父类会先调用父类的构造函数，这里假设 <code>Dog</code> 没有父类，执行默认值字段的赋值即方法的初始化动作。</li><li>执行构造函数。</li></ol><h2 id="8-2-有父类情况下的初始化"><a href="#8-2-有父类情况下的初始化" class="headerlink" title="8.2 有父类情况下的初始化"></a>8.2 有父类情况下的初始化</h2><p>假设: <code>Dog extends Animal</code></p><ol><li>执行第一步，找出<code>Dog.class</code>文件，接着在加载过程中发现他有一个基类（通过<code>extends</code> 关键字），于是先执行<code>Animal</code>类的第一二步，加载<code>Animal</code>类的静态变量和方法，加载结束之后再加载子类<code>Dog</code>的静态变量和方法。</li></ol><p>如果<code>Animal</code>类还有父类就以此类推，最终的基类叫做根基类。</p><blockquote><p>因为子类的<code>static</code>初始化可能会依赖于父类的静态资源，所以要先加载父类的静态资源。</p></blockquote><ol><li>接着要 <code>new Dog</code> 对象，先为<code>Dog</code>对象分配存储空间 -&gt; 到<code>Dog</code>的构造函数 -&gt; 创建默认的属性。这里其构造函数里面的第一行有个隐含的<code>super()</code>，即父类构造函数，所以这时会跳转到父类<code>Animal</code>的构造函数。</li></ol><p>Java 会帮我们完成构造函数的补充，Dog 实际隐式的构造函数如下:</p><ol><li>父类<code>Animal</code>执行构造函数前也是分配存储空间 -&gt; 到其构造函数 -&gt; 创建默认的属性 -&gt; 发现已经没有父类了，这个时候就给它的默认的属性赋值和方法的初始化。</li><li>接着执行构造函数余下的部分，结束后跳转到子类<code>Dog</code>的构造函数。</li><li>子类<code>Dog</code>对默认属性和方法分别进行赋值和初始化，接着完成构造函数接下来的部分。</li></ol><p><strong>为什么要执行父类 Animal 的构造方法才继续子类 Dog 的属性及方法赋值？</strong></p><p>因为子类 Dog 的非静态变量和方法的初始化有可能使用到其父类 Animal 的属性或方法，所以子类构造默认的属性和方法之后不应该进行赋值，而要跳转到父类的构造方法完成父类对象的构造之后，才来对自己的属性和方法进行初始化。</p><p>这也是为什么子类的构造函数显示调用父类构造函数 super() 时要强制写在第一行的原因，程序需要跳转到父类构造函数完成父类对象的构造后才能执行子类构造函数的余下部分。</p><p><strong>为什么对属性和方法初始化之后再执行构造函数其他的部分？</strong></p><p>因为构造函数中的显式部分有可能使用到对象的属性和方法。</p><blockquote><p><a href="https://www.runoob.com/w3cnote/java-init-object-process.html">Java 对象初始化详细过程 | 菜鸟教程</a></p></blockquote><h2 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3 总结"></a>8.3 总结</h2><h1 id="九、内部类"><a href="#九、内部类" class="headerlink" title="九、内部类"></a>九、内部类</h1><p>一个类的内部又完整嵌套了另一个类结构，被嵌套的（里面的）类成为内部类（inner class），嵌套其他类的（外面的）类称为外部类（outer class）。</p><p>内部类是类的第五大成员【属性、方法、构造器、代码块、内部类】</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>内部类最大特点是<strong>可以直接访问私有属性</strong>，并且可以体现类与类直接的包含关系。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>定义在外部类局部位置上</strong>（比如方法内）：</p><ol><li>局部内部类（有类名）</li><li>匿名内部类（没有类名，重点!!!!!!!）</li></ol><p><strong>定义在外部类的成员位置上：</strong></p><ol><li>成员内部类（没用<code>static</code>修饰）</li><li>静态内部类（有用<code>static</code>修饰）</li></ol><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在外部类的局部位置，比如方法、代码块中，并且有类名，本质仍然是一个类。</p><p><strong>重要规则</strong></p><ol><li>不能添加访问修饰符（由于它地位就是一个局部变量，局部变量不能使用修饰符），但是可以使用final修饰。</li><li>可以直接访问外部类的所有成员。</li><li>作用域：仅仅在定义它的方法或代码块中。</li><li>局部内部类 —&gt; 访问 —&gt; 外部类成员【访问方式：直接访问】</li><li>外部类 —&gt; 访问 —&gt; 局部内部类成员【访问方式：创建对象再访问】（且必须在作用域内）示例9-1</li><li>外部其他类 — 不能访问 —&gt; 局部内部类（因为局部内部类地位相当于局部变量）</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，使用：<strong>外部类名.this.成员</strong>（本质是外部类的对象，即哪个对象调用了m1）</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>定义在外部类的局部位置，比如方法、代码块中，并且没有类名，本质仍然是一个类，同时还是一个对象</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类or接口(参数列表) &#123;<br>    类体<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>因为匿名内部类<strong>既是一个类的定义</strong>，同时也<strong>本身也是一个对象</strong>，</p><p>所以从语法上看，它既有定义类的特征，也有创建对象的特征（对前面代码分析可以看出这个特点），因此可以调用匿名内部类方法。</p><p>示例9-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousInnerClassDetail</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Outer05</span> <span class="hljs-variable">outer05</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer05</span>();<br>        outer05.f1();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer05</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;  <span class="hljs-comment">//外部类属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//外部类方法</span><br>        <span class="hljs-comment">//(1) 创建一个基于类的匿名内部类</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//可以直接访问外部类的所有成员，包括私有的</span><br>                System.out.println(<span class="hljs-string">&quot;匿名内部类重写了hi方法 n1= &quot;</span> + n1);<br>            &#125;<br>        &#125;;<br>        person.hi();  <span class="hljs-comment">//动态绑定，运行类型是 Outer05$1</span><br><br>        <span class="hljs-comment">//(2) 也可以直接调用(本质：匿名内部类本身也是返回对象)</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>        &#125;.ok(<span class="hljs-string">&quot;shit&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person hi()&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ok</span><span class="hljs-params">(String str)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;输出&quot;</span> + str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重要规则（与局部内部类相似）</strong></p><ol><li>不能添加访问修饰符，因为它的地位就是一个局部变量</li><li>可以直接访问外部类的所有成员，包含私有的</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>匿名内部类 —&gt; 访问 —&gt; 外部类成员【访问方式：直接访问】</li><li>外部其他类 —&gt; 不能访问 —&gt; 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（<code>外部类名.this.成员</code>）访问</li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在外部类的成员位置，并且没有<code>static</code>修饰。</p><p><strong>重要规则</strong></p><ol><li><p>可以添加任意访问修饰符</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>成员内部类 –&gt; 访问 –&gt; 外部类成员成员【访问方式：直接访问】</p></li><li><p>外部类 –&gt; 访问 —&gt; 成员内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类 —&gt; 访问 —&gt; 成员内部类</p></li><li><ol><li>① 利用外部类创建内部类对象，再访问；【例：<code>Outer.Inner inner = outer.new Inner();</code>】（<code>**outer.new Inner();**</code> 相当于把 <code>new Inner()</code> 当作<code>outer</code>对象的成员）</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>()<br></code></pre></td></tr></table></figure><ol><li><ol><li>② 在外部类中编写一个方法，返回内部类的对象。例：</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">Inner</span> getInnerInstance() &#123;     <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();  &#125; <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.getInnerInstance();<br></code></pre></td></tr></table></figure><ol><li><ol><li>③ <code>new Outer().new Inner();</code> 相当于①，只是把<code>Outer outer = new Outer();</code> 合并了。</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>().<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); <span class="hljs-keyword">Outer</span> <span class="hljs-keyword">outer</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>(); <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br></code></pre></td></tr></table></figure><ol><li>如果外部类和成员内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，使用：<code>**外部类名.this.成员**</code></li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义在外部类的成员位置，有static修饰。</p><p><strong>重要规则（与成员内部类相似）</strong></p><ol><li><p>可以添加任意访问修饰符</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>静态内部类 –&gt; 访问 –&gt; 外部类成员【访问方式：直接访问所有的静态成员】</p></li><li><p>外部类 –&gt; 访问 —&gt; 静态内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类 —&gt; 访问 —&gt; 成员内部类</p></li><li><ol><li>方式①：利用外部类创建内部类对象，再访问；【例：<code>Outer.Inner inner = new Outer.Inner();</code>】<code>**new Outer.Inner();**</code> 因为静态内部类是静态成员，可以直接通过类名访问</li><li>方式②：在外部类中编写一个方法，返回内部类的对象。【例：<code>public static Inner getInner() &#123; return new Inner(); &#125;``Outer.Inner inner = Outer.getInner();</code> 】（非静态也可以）</li></ol></li><li><p>如果外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，使用：<strong>外部类名.成员</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberInnerClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer08</span> <span class="hljs-variable">outer08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer08</span>();<br>        outer08.t1();<br><br>        <span class="hljs-comment">//第一种 成员内部类</span><br>        <span class="hljs-comment">//Outer08.Inner08 inner08 = outer08.new Inner08();</span><br>        <br>        <span class="hljs-comment">//第一种 静态内部类</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer08</span>.Inner08();<br><br>        <span class="hljs-comment">//第二种</span><br>        <span class="hljs-comment">//在外部类中，编写一个方法，返回 Inner08 对象</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance</span> <span class="hljs-operator">=</span> outer08.getInner08Instance();<br>        <span class="hljs-comment">//在外部类中，编写一个静态方法，返回 Inner08 对象</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance_</span> <span class="hljs-operator">=</span> Outer08.getInner08Instance_();<br>        <br>        inner08Instance.say();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer08</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><br>    <span class="hljs-comment">//1.定义在外部类的成员位置上</span><br>    <span class="hljs-comment">//2.可以添加任意访问修饰符，因为它就是一个成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner08</span> &#123;  <span class="hljs-comment">//成员内部类</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">66</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;n1=&quot;</span> + n1 + <span class="hljs-string">&quot; name=&quot;</span> + name + <span class="hljs-string">&quot; 外部类n1=&quot;</span> + Outer08.n1);  <span class="hljs-comment">//直接访问所有的静态成员</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Inner08 <span class="hljs-title function_">getInner08Instance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Inner08 <span class="hljs-title function_">getInner08Instance_</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//静态方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//使用成员内部类</span><br>        <span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>        inner08.say();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 方法</title>
    <link href="/2022/06/07/Java-%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/07/Java-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><p><strong>方法的返回值</strong> 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p><p>按照方法的返回值和参数类型将方法分为以下几种：</p><ul><li>无参数无返回值的方法</li><li>有参数无返回值的方法</li><li>有返回值无参数的方法</li><li>有返回值有参数的方法</li></ul><h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><h3 id="1）调用方式"><a href="#1）调用方式" class="headerlink" title="1）调用方式"></a>1）调用方式</h3><p>在外部调用静态方法时，可以使用<code>类名.方法名</code>的方式，也可以使用<code>对象.方法名</code>的方式[1]，而实例方法只有<code>对象.方法名</code>这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><h3 id="2）访问类成员是否存在限制"><a href="#2）访问类成员是否存在限制" class="headerlink" title="2）访问类成员是否存在限制"></a>2）访问类成员是否存在限制</h3><ul><li>静态方法在访问本类的成员时，<strong>只允许访问静态成员</strong>（即静态成员变量和静态方法），<strong>不允许访问实例成员</strong>（即实例成员变量和实例方法）</li><li>实例方法不存在以上这个限制。</li></ul><p>[1] 不建议使用 <code>对象.方法名</code> 的方式来调用静态方法，容易混淆。静态方法不属于类的某个对象而是属于这个类。</p><h2 id="静态方法为何不能调用非静态成员"><a href="#静态方法为何不能调用非静态成员" class="headerlink" title="静态方法为何不能调用非静态成员?"></a>静态方法为何不能调用非静态成员?</h2><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul><h1 id="方法重载和重写"><a href="#方法重载和重写" class="headerlink" title="方法重载和重写"></a>方法重载和重写</h1><p><strong>重载：</strong>java 允许同一个类中，多个同名方法的存在，但要求形参列表不一致。这样，同样的一个方法能够根据输入数据的不同，做出不同的处理。（好处：减轻了起名、记名的麻烦）</p><p><strong>重写：</strong>当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法。</p><h2 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h2><p>如果多个方法（比如 <code>StringBuilder</code> 的构造方法）有<strong>相同的名字</strong>、<strong>不同的参数</strong>， 便产生了<strong>重载</strong>。</p><p><strong>规则：</strong></p><ol><li>方法名：必须相同</li><li>形参列表：必须不同（形参类型 或 个数 或 顺序，至少一种不一样，参数名无所谓）</li><li>返回类型：无要求，不是方法重载的必要条件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br></code></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好（这个过程被称为**重载解析(overloading resolution)**）。Java 允许重载任何方法， 而不只是构造器方法。</p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><h2 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h2><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><p><strong>要求：</strong></p><ol><li><strong>方法名、参数列表</strong>必须相同。</li><li>子类方法<strong>返回值类型</strong>应比父类方法返回值类型更小或相等。</li><li><strong>抛出的异常范围</strong>小于等于父类。</li><li><strong>访问修饰符范围</strong>大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private</code>&#x2F;<code>final</code>&#x2F;<code>static</code> 则子类就不能重写该方法，但是被<code>static</code>修饰的方法能够被再次声明。</li><li>构造方法无法被重写。</li></ol><p><strong>综上：</strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》，<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892open in new window</a> ）：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>⚠关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><h2 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h2><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是<strong>允许在调用方法时传入不定长度的参数</strong>。</p><p>比如下面这个方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，可变参数<strong>只能作为函数的最后一个参数</strong>，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(String arg1, String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><ul><li>答案是会<strong>优先匹配固定参数的方法</strong>，因为固定参数的方法匹配度更高。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableLengthArgument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String s : args) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String arg1, String arg2)</span> &#123;<br>        System.out.println(arg1 + arg2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        printVariable(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        printVariable(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">ab<br>a<br>b<br>c<br>d<br></code></pre></td></tr></table></figure><p>另外，Java 的<strong>可变参数编译后实际会被转换成一个****数组</strong>，我们看编译后生成的 class文件就可以看出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableLengthArgument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String... args)</span> &#123;<br>        String[] var1 = args;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> args.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var3 &lt; var2; ++var3) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> var1[var3];<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h1><h2 id="方法递归调用内存分析"><a href="#方法递归调用内存分析" class="headerlink" title="方法递归调用内存分析"></a>方法递归调用内存分析</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8.png" alt="方法递归调用"></p><h2 id="重要规则"><a href="#重要规则" class="headerlink" title="重要规则"></a>重要规则</h2><ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li><li>方法的局部变量是独立的，不会相互影响</li><li>如果方法中使用的是引用类型变量（比如数组、对象），就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则将无限递归，出现<code>StackOverflowError</code>，死龟了</li><li>当一个方法执行完毕，或者遇到<code>return</code>，就会返回，遵守谁调用就将结果返回给谁，同时当方法执行完毕或返回时，该方法也就执行完毕。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一般形式</span><br>func(mode)&#123;    <br>    <span class="hljs-keyword">if</span>(endCondition) &#123;      <span class="hljs-comment">//递归出口</span><br>          end;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>         func(mode_small)  <span class="hljs-comment">//调用本身，递归</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经典算法题：八皇后问题</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>在 java 编程中，主要的变量就是<strong>属性（成员变量）</strong>和<strong>局部变量</strong>。</p><h2 id="java作用域的规则"><a href="#java作用域的规则" class="headerlink" title="java作用域的规则"></a>java作用域的规则</h2><p>属性和局部变量可以重名，访问时遵循就近原则</p><h2 id="全局变量（属性-成员变量）"><a href="#全局变量（属性-成员变量）" class="headerlink" title="全局变量（属性\成员变量）"></a>全局变量（属性\成员变量）</h2><ol><li>作用域为整个整体；</li><li>可以不赋值，直接使用（因为有默认值）；</li><li><strong>生命周期较长</strong>，伴随着对象创建而创建、销毁而销毁；</li><li>可以被本类使用，或其他类使用（通过对象调用）；</li><li>可以加修饰符。</li></ol><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ol><li>一般是指在成员方法内定义的变量。（后面讲的{代码块}中的变量也是局部变量），作用域为定义它的代码块中；</li><li>必须赋值后，才能使用（因为没有默认值）；</li><li><strong>生命周期较短</strong>，伴随它的代码块的执行而创建、结束而销毁，即在一次方法调用过程中；</li><li>只能在本类对应的方法中使用；</li><li>不可以加修饰符。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>           <br>        t1.test(); <span class="hljs-comment">// 第1种跨类访问对象属性的方式</span><br><br>                t1.test2(p1); <span class="hljs-comment">// 第2种跨类访问对象属性的方式</span><br><br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(p.name);<br>    &#125;    <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(Person p)</span> &#123;<br>        System.out.println(p.name);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;kobe&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="构造方法-x2F-构造器"><a href="#构造方法-x2F-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h1><p>构造方法，是类的一种特殊方法，主要作用是完成<strong>对新对象的初始化</strong>。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">访问修饰符 方法名(形参列表) &#123; 方法体<span class="hljs-comment">; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol><li><p>没有返回值（不用也不能写void）</p></li><li><p>方法名 和 类名 相同</p></li><li><p>参数列表 和 成员方法 一样的规则</p></li><li><p>构造器是完成对象的初始化，并不是创建对象</p></li><li><p>创建对象时，系统会自动调用该类的构造器</p></li><li><p>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器），比如 Person(){}。（可使用<code>javap</code>反编译看看）</p></li><li><ol><li><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E9%BB%98%E8%AE%A4%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="默认无参构造器"></li></ol></li><li><p>一旦自定义了构造器，默认的构造器就被覆盖，就不能再使用默认的无参构造器，除非显式定义一下，即：Dog(){} </p></li><li><ol><li><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="有参构造器"></li></ol></li></ol><hr><p>参考</p><ul><li>韩顺平Java基础课</li><li><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">Java基础常见面试题总结(上)</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基本语法</title>
    <link href="/2022/05/30/Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/05/30/Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、运算符"><a href="#一、运算符" class="headerlink" title="一、运算符"></a>一、运算符</h1><h2 id="算术运算符（重点看-x2F-）"><a href="#算术运算符（重点看-x2F-）" class="headerlink" title="算术运算符（重点看 &#x2F; % ++ ）"></a>算术运算符（重点看 &#x2F; % ++ ）</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="%运算符"></a>%运算符</h3><p><strong>作用：</strong>取模、取余</p><p><strong>本质：</strong><code>a % b = a - a / b * b</code> </p><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="++运算符"></a>++运算符</h3><p><strong>作用：</strong>自增</p><p>作为独立式使用</p><ul><li>前++和后++完全等价于<code>i = i + 1</code>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自增</span><br>i++;  <br><span class="hljs-comment">// 等价于 </span><br>++i;<br><span class="hljs-comment">// 等价于 </span><br>i = i + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>作为表达式使用</p><ul><li>前++（++i）： 先自增后赋值</li><li>后++（i++）： 先赋值后自增</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> ++j;  <span class="hljs-comment">//等价于 j=j+1; k=j; --&gt; j==9, k==9</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j++;  <span class="hljs-comment">//等价于 k=j; j=j+1;  --&gt; j==9, k==8</span><br></code></pre></td></tr></table></figure><p>面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//面试题1：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;             <span class="hljs-comment">//i -&gt; 1</span><br>i = i++;               <span class="hljs-comment">// 规则使用临时变量：(1)temp = i; (2)i = i + 1; (3)i = temp;</span><br>System.out.println(i)  <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">//面试题2：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;             <span class="hljs-comment">// i -&gt; 1</span><br>i = ++i;               <span class="hljs-comment">// (1)i = i + 1; (2)temp = i; (3)i = temp;</span><br>System.out.println(i)  <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// tips:自己给自己赋值要用到临时变量</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&lt;</th><th>&gt;</th><th>&lt;&#x3D;</th><th>&gt;&#x3D;</th><th>instanceof</th></tr></thead><tbody><tr><td>相等于</td><td>不等于</td><td>小于</td><td>大于</td><td>小于等于</td><td>大于等于</td><td>检查是否是类的对象</td></tr></tbody></table><p>结果都是boolean值，true 或 false</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>（1）短路与 &amp;&amp;，短路或 ||，取反 !</p><p>（2）逻辑与 &amp;，逻辑或 |，逻辑异或^</p><table><thead><tr><th>a</th><th>b</th><th>a&amp;b</th><th>a&amp;&amp;b</th><th>a|b</th><th>a||b</th><th>!a</th><th>a^b</th></tr></thead><tbody><tr><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>√</td><td>×</td><td>×</td><td>×</td><td>√</td><td>√</td><td>×</td><td>√</td></tr><tr><td>×</td><td>√</td><td>×</td><td>×</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>√</td><td>×</td></tr></tbody></table><ol><li>结果都是<code>boolean</code>值，<code>true</code> 或 <code>false</code></li><li>开发中一般使用短路操作 <code>&amp;&amp;</code> 和 <code>||</code>，效率高</li></ol><ul><li><ul><li>短路与<code>&amp;&amp;</code>：如果第一个条件为<code>false</code>，则第二个条件不会判断，最终结果为<code>false</code></li><li>短路或<code>||</code>：如果第一个条件为<code>true</code>，则第二个条件不会判断，最终结果为<code>true</code></li></ul></li></ul><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, y = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (x++==<span class="hljs-number">6</span> &amp; ++y==<span class="hljs-number">6</span>) &#123;  <span class="hljs-comment">//x先比较后自增，第一个条件为false，y先自增后比较，第二个条件为true</span><br>    x = <span class="hljs-number">11</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;x=&quot;</span> + x + <span class="hljs-string">&quot;,y=&quot;</span> + y);  <span class="hljs-comment">// x=6, y=6</span><br></code></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符就是将某个运算后的值，赋给指定的变量</p><ul><li>基本赋值运算符：<code>=</code></li><li>复合赋值运算符：<code>+=</code>，<code>-=</code>，<code>/=</code>，<code>%=</code> 等</li></ul><p>特点：</p><ol><li>左边是变量，右边可以是变量、表达式、常量值</li><li>a +&#x3D; b;  等价于 a &#x3D; a + b; 其他以此类推</li><li>复合赋值运算符会自动进行类型转换</li></ol><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>b += <span class="hljs-number">3</span>;  <span class="hljs-comment">// 等价于 b = (byte)(b + 3) </span><br>b++;     <span class="hljs-comment">// 等价于 b = (byte)(b + 1)</span><br></code></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为<code>true</code>，运算后的结果是表达式1；反之<code>false</code>结果为表达式2（口诀：一眼丁真）</p><p>示例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">24</span>;<br><br><span class="hljs-comment">// 由于true，执行了表达式1（a++），不执行表达式2（b--），</span><br><span class="hljs-comment">// 因此a先返回值给res再自增，b--不执行</span><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> a &lt; b ? a++ : b--;  <br><br>System.out.println(<span class="hljs-string">&quot;a=&quot;</span> + a + <span class="hljs-string">&quot;b=&quot;</span> + b + <span class="hljs-string">&quot;res=&quot;</span> + res)<br><span class="hljs-comment">//a=9，b=24，res=8</span><br></code></pre></td></tr></table></figure><p>细节：</p><ol><li>表达式1 和 表达式2 要为可以赋给接收变量的类型（或可以自动转换&#x2F; 或强制转换）</li><li>三元运算符本质是 if–else 语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> a &gt; b ? a++ : --b;<br>等价于<br><span class="hljs-keyword">if</span> (a &gt; b) res = a++;<br><span class="hljs-keyword">else</span> res = --b;<br></code></pre></td></tr></table></figure><p>⚠️<strong>区别：</strong></p><p>三元运算符是一个整体！if 和 else 是独立语句块！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于三元运算符是一个整体，表达式1 和 表达式2 要自动转换为同一种类型</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.0</span>);  <br>System.out.println(obj1);  <span class="hljs-comment">//输出：1.0</span><br><br><span class="hljs-comment">// 根据编译器提示： &quot;true ? new Integer(1) : new Double(2.0)&quot;   </span><br><span class="hljs-comment">// 可以简化为-&gt;  &quot;(double) new Integer(1)&quot;  </span><br><span class="hljs-comment">// 可以移除包装-&gt;   &quot;(double) 1&quot;</span><br><br><span class="hljs-comment">//---------------------------------------</span><br><br>Object obj2;<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)<br>    obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br>    obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.0</span>);<br>System.out.println(obj2);  <span class="hljs-comment">//输出：1</span><br></code></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p><h1 id="二、进制转换"><a href="#二、进制转换" class="headerlink" title="二、进制转换"></a>二、进制转换</h1><h2 id="整数的四种表达方式"><a href="#整数的四种表达方式" class="headerlink" title="整数的四种表达方式"></a>整数的四种表达方式</h2><p>二进制(BIN)：<code>0,1</code>，以<code>0b</code>或<code>0B</code>开头。                  <code>int n1 = 0b1010;</code></p><p>十进制(DEC)：<code>0-9</code>。                                  <code>int n2 = 1010;</code></p><p>八进制(OCT)：<code>0-7</code>，以数字<code>0</code>开头。                    <code>int n3 = 01010;</code></p><p>十六进制(HEX)：<code>0-9</code>及<code>A(10)-F(15)</code>；以<code>0x</code>或<code>0X</code>开头。  <code>int n4 = 0x10101;</code></p><h2 id="Java-进制转换"><a href="#Java-进制转换" class="headerlink" title="Java 进制转换"></a>Java 进制转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 十转二</span><br>bin_num = Integer.toBinaryString(dec_num);<br><span class="hljs-comment">// 十转八</span><br>oct_num = Integer.toOctalString(dec_num);<br><span class="hljs-comment">// 十转十六</span><br>hex_num = Integer.toHexString(dec_num);<br></code></pre></td></tr></table></figure><h2 id="二进制（八进制、十六进制）转十进制"><a href="#二进制（八进制、十六进制）转十进制" class="headerlink" title="二进制（八进制、十六进制）转十进制"></a>二进制（八进制、十六进制）转十进制</h2><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>2</strong>的（位数-1）次方，然后求和。</p><p>例：0b1011 &#x3D; 1 * 20 + 1 * 21 + 0 * 82 + 1 * 23 &#x3D; 1 + 2 + 0 + 8 &#x3D; 11</p><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>8</strong>的（位数-1）次方，然后求和。</p><p>例：0234 &#x3D; 4 * 80 + 3 * 81 + 2 * 82 &#x3D; 4 + 24 + 128 &#x3D; 156</p><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>16</strong>的（位数-1）次方，然后求和。</p><p>例：0x23A &#x3D; 10 * 160 + 3 * 161 + 2 * 162 &#x3D; 10 + 48 + 512 &#x3D; 570</p><h2 id="十进制转二进制（八进制、十六进制同理）"><a href="#十进制转二进制（八进制、十六进制同理）" class="headerlink" title="十进制转二进制（八进制、十六进制同理）"></a>十进制转二进制（八进制、十六进制同理）</h2><p>“<strong>除2取余，逆序排列</strong>”：将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来。</p><p>例：十进制34转成二进制：  &#x3D;0B00100010</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="十进制转二进制"></p><h2 id="二进制转八进制（十六进制）"><a href="#二进制转八进制（十六进制）" class="headerlink" title="二进制转八进制（十六进制）"></a>二进制转八进制（十六进制）</h2><p>从低位开始，将二进制数每三位（每四位）一组，转成对应的八进制（十六进制）数即可。</p><p>例：0b1101(D)0101(5) &#x3D; 0xD5</p><p><strong>二转十六进制诀窍：</strong>二进制每四位视为“8421”码，1101即为1个8，1个4，0个2，1个1相加，结果为13，即D</p><h2 id="八进制（十六进制）转二进制"><a href="#八进制（十六进制）转二进制" class="headerlink" title="八进制（十六进制）转二进制"></a>八进制（十六进制）转二进制</h2><p>将<strong>八进制</strong>数每1位，转成对应的一个<font color="red">3</font>位二进制数。</p><p>例：0237转成二进制：0<font color="green">2(010)</font><font color="orange">3(011)</font><font color="blue">7(111)</font> &#x3D; 0b10011111</p><p>将<strong>十六进制</strong>数每1位，转成对应的一个<font color="red">4</font>位二进制数。</p><p>例：0x23B转成二进制：0x<font color="green">2(0010)</font><font color="orange">3(0011)</font><font color="blue">B(1011)</font> &#x3D; 0b001000111011 （快速计算”B”的二进制技巧：11 &#x3D; 15(1111) - 4(0100) &#x3D; B &#x3D; 11(1011) ）</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>原码表示范围：-127~127</p><p>反码表示范围：-127~127</p><p>补码表示范围：-128~127</p><p><strong>总结</strong>：</p><ol><li>二进制的最高位是符号位：0表示正数，1表示负数（）</li><li>正数的原码、反码、补码都一样（正数三码合一）</li><li>负数的反码 &#x3D; 它的原码符号位不变，其他位取反（0-&gt;1 1-&gt;0）</li><li>负数的补码 &#x3D; 它的反码 + 1（负数的反码 &#x3D; 它的补码 - 1）（补 &#x3D; 反 + 1）</li><li>负数的原码 &#x3D; 【它的反码 符号位不变，其他位取反】 &#x3D; 【（它的补码 - 1）符号位不变，其他位取反】&#x3D; 【它的绝对值(正数)的原码符号位变为0】</li><li>负数 &#x3D; 其绝对值的原码最高位取1（原码）的 补码（原码取反+1）</li><li>0的反码、补码都是0</li><li>java没有无符号数</li><li>在计算机运算的时候，都是以补码的方式来运算的</li><li>当我们看<strong>运算结果</strong>时，要看它的原码</li></ol><p><strong>计算机中，负数表达形式</strong></p><p>负数二进制以补码形式表达，</p><ol><li>把这个负数的绝对值转换为二进制，即求原码 （ |-24| &#x3D; 24 &#x3D; 00011000 ）</li><li>把原码取反，即求反码（ ~00011000 &#x3D; 11100111 ）</li><li>把反码加1，即求补码（ 11101000 &#x3D; -24(补码) ）</li></ol><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol><li>java中7个位运算：&amp;、|、^、~、&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;</li><li>按位与&amp;：两位为1，结果为1，否则为0</li><li>按位或|：有一个为1，则结果为1，否则为0</li><li>按位异或^：同0异1</li><li>按位取反~：0变1，1变0</li></ol><p><strong>示例：</strong></p><p>求<code>~-2</code>的结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(~-<span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ol><li>先得到-2的原码：10000000 00000000 00000000 00000010</li><li>再得-2的反码：  11111111 11111111 11111111 11111101（&#x3D;原码符号位不变，其他位取反）</li><li>再得-2的补码：  11111111 11111111 11111111 11111110（&#x3D;反码+1）</li><li><del>-2操作：       00000000 00000000 00000000 00000001（</del>-2：对-2的补码进行取反操作）</li><li>运算后的原码：   00000000 00000000 00000000 00000001（1）</li></ol><p><strong>示例：</strong></p><p>求<code>~2</code>的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(~<span class="hljs-number">2</span>); <span class="hljs-comment">//-3</span><br></code></pre></td></tr></table></figure><ol><li>先得到2的补码：00000000 00000000 00000000 00000010（正数三码都一样）</li><li><del>2操作：       11111111 11111111 11111111 11111101（运算后的补码）（</del>2：对2的补码进行取反操作）</li><li>运算后的反码：  11111111 11111111 11111111 11111100（负数反码 &#x3D; 它的补码-1）</li><li>运算后的原码：   10000000 00000000 00000000 00000011（-3）</li></ol><p>算术右移<code>&gt;&gt;</code>：向右移若干位，符号位不变，低位溢出丢弃，高位补符号位（符号位补溢出的高位，即正数高位补 0，负数高位补 1）</p><p><code>x &gt;&gt; n</code>，相当于 x 除以 2 的 n 次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-number">15</span>&gt;&gt;<span class="hljs-number">2</span>;<br><span class="hljs-comment">// 15 =&gt; 0000 1111 =&gt; 0000 0011 </span><br><span class="hljs-comment">// 本质 15 / 2 / 2 = 3 </span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> -<span class="hljs-number">15</span> &gt;&gt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 1111 0001 &gt;&gt; 0000 0010 = 1111 1100(-4)</span><br></code></pre></td></tr></table></figure><p>算术左移<code>&lt;&lt;</code>：向左移若干位，符号位不变，低位补0，高位丢弃。</p><p><code>x &lt;&lt; n</code>，相当于 x 乘以 2 的 n 次方(不溢出的情况下)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">3</span>; <br><span class="hljs-comment">//4 =&gt; 0000 0100 -&gt; 0010 0000 </span><br><span class="hljs-comment">// (本质 4 * 2 * 2 * 2 = 32) (4&lt;&lt;3 =&gt; 4 * 2^3)</span><br></code></pre></td></tr></table></figure><p>无符号右移<code>&gt;&gt;&gt;</code>：忽略符号位，空位都以0补齐。</p><p>移位操作符实际上只支持<code>int</code>和<code>long</code>类型，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p><h2 id="移位的位数超过数值所占有的位数"><a href="#移位的位数超过数值所占有的位数" class="headerlink" title="移位的位数超过数值所占有的位数"></a>移位的位数超过数值所占有的位数</h2><p>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。</p><p>也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0），左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。</p><p>当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p><p>也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x &gt;&gt;&gt;42</code>等同于<code>x &gt;&gt;&gt; 10</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>System.out.println(<span class="hljs-string">&quot;初始数据：&quot;</span> + i);<br>System.out.println(<span class="hljs-string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));<br>i &lt;&lt;= <span class="hljs-number">42</span>;  <span class="hljs-comment">// 等价于 i &lt;&lt;= 10; 42 % 32 = 10</span><br>System.out.println(<span class="hljs-string">&quot;左移 10 位后的数据 &quot;</span> + i);  <br>System.out.println(<span class="hljs-string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">初始数据：-<span class="hljs-number">1</span><br>初始数据对应的二进制字符串：<span class="hljs-number">11111111111111111111111111111111</span><br>左移 <span class="hljs-number">10</span> 位后的数据 -<span class="hljs-number">1024</span><br>左移 <span class="hljs-number">10</span> 位后的数据对应的二进制字符 <span class="hljs-number">11111111111111111111110000000000</span><br></code></pre></td></tr></table></figure><h2 id="问题：为何使用原码、反码、补码"><a href="#问题：为何使用原码、反码、补码" class="headerlink" title="问题：为何使用原码、反码、补码"></a>问题：为何使用原码、反码、补码</h2><p>我们上面说过，原码、反码、补码的表示对于正数来说都是一样的，而对于负数来说，三种码的表示确是完全不同的，那大家是否会有个疑问：如果原码才是我们人类可以识别并用于直接计算的表示方式，那为什么还会有反码和补码？计算机直接存储原码不就完事了？</p><p>在解决这些问题前，我们先来了解计算机的底层概念，我们人脑可以很轻松的知道机器数的第一位是符号位，但对于计算机基础电路设计来说判别第一位是符号位是非常难和复杂的事情，为了让计算机底层设计更加简单，人们开始探索将符号位参与运算，并且采用只保留加法的方法，我们知道减去一个数，等于加上这个数的负数，即：1-1 &#x3D; 1 + (-1) &#x3D; 0，这样让计算机运算就更加简单了，并且也让符号位参与到运算中去。</p><p><strong>使用原码运算</strong></p><p>计算十进制表达式：<code>1-1 = 0</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 原：[ 1000 0010 ] &#x3D; -2</p><p>如果用原码表示，让符号位也参与计算，对于减法来说，结果是不正确的。这也是计算机内部在存储数据时不使用原码的原因，为了解决这一问题，出现了反码。</p><p><strong>使用反码运算</strong></p><p>计算十进制表达式：<code>1-1 = 0</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 反：[ 0000 0001 ] + 反：[ 1111 1110 ]</p><p>&#x3D; 反：[ 1111 1111 ] &#x3D; 原： [ 1000 0000 ] &#x3D; -0</p><p>通过计算我们发现用反码计算减法，结果的真值部分是正确的。而唯一的问题出现在”0”这个特殊的数值上，虽然人们理解上**+0和-0**是一样的，但是0带符号是没有任何意义的，而且会有 [0000 0000] 原和 [1000 0000] 原两个编码表示0。为了解决这一问题，出现了补码。</p><p><strong>使用补码运算</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 补：[ 0000 0001 ] + 补：[ 1111 1111 ]</p><p>&#x3D; 补： [ 0000 0000 ] &#x3D; 原： [ 0000 0000 ] &#x3D; 0</p><p>这样0用 [0000 0000] 表示，而以前出现问题的-0则不存在了，而且人们还发现可以用[1000 0000]表示-128，-128的推算过程如下：</p><p>(-1) + (-127) &#x3D; -128</p><p>&#x3D; 原：[1000 0001] + 原：[ 1111 1111 ]</p><p>&#x3D; 补：[ 1111 1111 ] + 补：[ 1000 0001 ]</p><p>&#x3D; 补：[ 1000 0000 ]</p><p><strong>注意：</strong>因为实际上是使用以前的-0的补码来表示-128，所以**-128并没有原码和反码表示**，只要补码是[1000 0000]，其十进制数值就为-128。</p><p>因为补码能多存储一个-128，而且在计算机底层中存储的是补码，所以在计算机中一个8位的二进制数的存储范围是用补码表示的[-128,127]，而不是用原码或反码表示的[-127,127]。这也可以解释为什么计算机中一个字节的取值范围是[-128,127]。</p><p>这样也能够回答我们开始提出的问题了，原码、反码、补码的使用，是人们<strong>为了让符号位能参与运算并让计算机底层运算更加简单</strong>而设计出来的数据存储表示方式。</p><h1 id="三、标识符与关键字"><a href="#三、标识符与关键字" class="headerlink" title="三、标识符与关键字"></a>三、标识符与关键字</h1><p>标识符就是一个名字。（标识符：阿牛茶餐厅、美宜佳）</p><p>关键字是被赋予特殊含义的标识符。（关键字：医院、警察局、学校…）</p><p><code>default</code>关键字</p><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul><p>⚠️ 注意：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p><p>官方文档：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java提供了四种访问控制修饰符号，用于控制方法和属性的访问权限：</p><ol><li>公开级别：用<code>public</code>修饰，对外公开；</li><li>受保护级别：用<code>protected</code>修饰，对子类和同一个包中的类公开；</li><li>默认级别：没有修饰符号，向同一个包的类公开；</li><li>私有级别：用<code>private</code>修饰，只有类本身可以访问，不对外公开。</li></ol><h3 id="访问范围"><a href="#访问范围" class="headerlink" title="访问范围"></a>访问范围</h3><table><thead><tr><th>访问级别</th><th>访问控制修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>公开</td><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>受保护</td><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>默认</td><td>-</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>私有</td><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>修饰符可以用来修饰类中的属性、成员方法以及类；</li><li>只有默认的和<code>public</code>才能修饰类，并且遵循上述访问权限的特点</li><li>子类</li><li>成员方法的访问规则和属性一样</li></ol><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>可以修饰类、属性、方法、局部变量。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>1）当不希望类被继承时；</p><p>2）不希望父类的某个方法被子类覆盖&#x2F;重写override时；</p><p>3）当不希望类的某个属性的值被修改时；</p><p>4）当不希望某个局部变量被修改时。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>1）<code>final</code>修饰的属性又叫常量，一般用XX_XX_XX命名</p><p>2）<code>final</code>修饰的属性在定义时，必须赋初值，赋值可以在类定义属性时、构造器中、代码块中；</p><p>3）如果<code>final</code>修饰的属性是静态的，则初始化的位置只能是定义时、在静态代码块中（不能在构造器中赋值）</p><p>4）如果一个类已经是<code>final</code>类，就没有必要将方法修饰成<code>final</code>了。</p><p>5）<code>final</code>不能修饰构造器。</p><p>6）<code>**final**</code><strong>和</strong><code>**static**</code><strong>往往搭配使用，不会导致类加载（底层编译器做了优化处理），效率更高</strong>。</p><p>7）包装类（<code>Integer</code>、<code>Double</code>等都是<code>final</code>），<code>String</code>也是<code>final</code>类。</p><h1 id="四、控制结构"><a href="#四、控制结构" class="headerlink" title="四、控制结构"></a>四、控制结构</h1><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><p>程序从上到下逐行执行，中间没有任何判断和跳转。</p><p>Java定义变量时采用合法的前向引用。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="分支控制if-else"><a href="#分支控制if-else" class="headerlink" title="分支控制if-else"></a>分支控制if-else</h2><p>让程序有选择的执行，分支控制有三种（单分支、双分支、多分支）</p><p>嵌套分支：分支嵌套最好不要超过3层（可读性差）</p><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单分支：当条件表达式为true时，就会执行&#123; &#125;的代码。（如果&#123;&#125;中只有一条语句，可以省略&#123;&#125;，但建议写上）</span><br><span class="hljs-keyword">if</span>(条件表达式)&#123;<br>    执行代码块;<br>&#125;<br><br><span class="hljs-comment">//双分支：当条件表达式为true时，就会执行&#123;代码块1&#125;，否则执行&#123;代码块2&#125;。（如果&#123;代码块&#125;中只有一条语句，可以省略&#123;&#125;，但建议写上）</span><br><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    代码块<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    代码块<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">//多分支：当条件表达式1为true时，就会执行&#123;代码块1&#125;，当条件表达式1为false时，再判断条件表达式2是否成立，以此类推，都不成立则执行&#123;代码块n&#125;。（多分支可以没有else）</span><br><span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">1</span>) &#123;<br>    代码块<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123;<br>    代码块<span class="hljs-number">2</span>;<br>&#125;<br>......<br><span class="hljs-keyword">else</span> &#123;<br>    代码块n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="switch分支结构"><a href="#switch分支结构" class="headerlink" title="switch分支结构"></a>switch分支结构</h2><p><strong>规则：</strong></p><ol><li>case 语句中的<code>value</code>的数据类型必须与表达式变量的数据类型相同，而且只能是<strong>常量</strong>或者<strong>字面常量；</strong>（或是表达式可以自动转换成可以与<code>case</code>的<code>value</code>相互比较的类型。）</li><li>switch表达式中的返回值必须是：<code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code>、<code>enum</code>、<code>String</code>；</li><li>表达式对应一个值；</li><li>当变量的值与 <code>case</code> 语句的值相等时，那么 <code>case</code> 语句之后的语句开始执行，直到 <code>break</code> 语句出现才会跳出 switch 语句；</li><li><code>case</code>常量1：当表达式的值等于<code>value1</code>，就执行语句块1；如果没有匹配<code>value1</code>，就继续匹配case <code>value2</code>；如果一个都没匹配上，执行<code>default</code>；</li><li><code>case</code> 语句不必须要包含 <code>break</code> 语句。如果没有 <code>break</code> 语句出现，程序会继续执行下一条 <code>case</code> 语句，直到出现 <code>break</code> 语句。（穿透）。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (expression) &#123;<br>    <span class="hljs-keyword">case</span> value1:<br>        <span class="hljs-comment">//语句块1;  //可省略</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value2:<br>        <span class="hljs-comment">//语句块2;</span><br>    <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//default语句块;</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/switch%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="switch控制结构"></p><h2 id="for-循环控制"><a href="#for-循环控制" class="headerlink" title="for 循环控制"></a>for 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>循环初始值可以有多个，但类型必须相同；</li><li>初始化和变量迭代可以写到其他地方，但是分号不能省略；（见示例）</li><li>循环条件是布尔表达式。</li><li>循环四要素：循环变量初始化；循环条件；循环语句；循环变量迭代。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(循环变量初始化; 循环条件(布尔表达式); 循环变量迭代/更新) &#123;<br>    <span class="hljs-comment">//循环操作（可以多条）;</span><br>&#125;<br><br><span class="hljs-comment">//示例：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//变量初始化（变量i的作用域更大）</span><br><span class="hljs-keyword">for</span> (; i&lt;<span class="hljs-number">10</span>; ) &#123;<br>    System.out.println(<span class="hljs-string">&quot;shit&quot;</span> + i);<br>    i++;  <span class="hljs-comment">//变量迭代</span><br>&#125;<br><span class="hljs-comment">//补充</span><br><span class="hljs-keyword">for</span>(;;)&#123; <span class="hljs-comment">//死循环</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for-each-循环（增强for）"><a href="#for-each-循环（增强for）" class="headerlink" title="for each 循环（增强for）"></a>for each 循环（增强for）</h2><p>foreach 循环语句是 Java1.5 的新特征之一，在遍历数组、集合方面，foreach 为开发者提供了极大的方便。foreach 循环语句是 for 语句的特殊简化版本，主要用于执行遍历功能的循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (元素类型 元素变量名x : 遍历对象obj) &#123;   <span class="hljs-comment">// 快捷键：大写I + 回车</span><br>    <span class="hljs-comment">//引用了x的java语句; </span><br>&#125; <br></code></pre></td></tr></table></figure><p>其中，“类型”为元素的类型，“元素变量名”表示对象的每一个元素，“遍历对象”表示被遍历的对象，如集合。</p><p>每执行一次循环语句，循环变量就读取集合中的一个元素。</p><h2 id="while-循环控制"><a href="#while-循环控制" class="headerlink" title="while 循环控制"></a>while 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>while循环是先判断 再执行语句；</li><li>只要布尔表达式为 true，循环就会一直执行下去；</li><li>循环条件是布尔表达式；</li><li>也有循环四要素。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//循环变量初始化</span><br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>) &#123;  <span class="hljs-comment">//循环条件</span><br>    xxx  <span class="hljs-comment">//循环体（语句）</span><br>    i++;  <span class="hljs-comment">//循环变量迭代</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="do…while-循环控制"><a href="#do…while-循环控制" class="headerlink" title="do…while 循环控制"></a>do…while 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>do while 是关键字；</li><li>先执行，再判断，也就是说，一定会至少执行一次；</li><li>也有四要素，只是位置不一样；</li><li>最后有一个分号。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>    System.out.print(<span class="hljs-string">&quot;value of x : &quot;</span> + x ); <span class="hljs-comment">//循环体（语句）</span><br>    x++; <span class="hljs-comment">//循环变量迭代</span><br>&#125; <span class="hljs-keyword">while</span>(x &lt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//(循环条件)</span><br></code></pre></td></tr></table></figure><h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体。</p><p>当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次循环。</p><p>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次</p><h2 id="continue、break-和-return"><a href="#continue、break-和-return" class="headerlink" title="continue、break 和 return"></a><code>continue</code>、<code>break</code> 和 <code>return</code></h2><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ol><h3 id="break-跳转控制语句"><a href="#break-跳转控制语句" class="headerlink" title="break 跳转控制语句"></a>break 跳转控制语句</h3><p>主要用在循环语句或者 switch 语句中，用来跳出整个语句块</p><p>break语句出现仔多层嵌套的语句块中时，可以通过标签指明要终止的哪一层语句块。</p><p><strong>注意事项：</strong></p><ol><li>break语句可以指定退出哪一层；</li><li>label1是标签，名字由程序员指定；</li><li>break 后指定到哪个label 就退出到哪里；</li><li>在实际开发中，尽量不要用标签；</li><li>如果没有指定，break默认退出最近的循环体。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>lable1:<br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ ) &#123;<br><br>lable2:<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ ) &#123;<br>        <span class="hljs-keyword">if</span>( j == <span class="hljs-number">2</span> )&#123;<span class="hljs-keyword">break</span>;&#125;  <span class="hljs-comment">//等价于 break lable2</span><br>        System.out.print(j);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-number">01010101</span><br><span class="hljs-comment">//（如果break label1; 则输出结果为：01）</span><br></code></pre></td></tr></table></figure><h3 id="跳转控制语句-continue"><a href="#跳转控制语句-continue" class="headerlink" title="跳转控制语句 continue"></a>跳转控制语句 continue</h3><p><strong>基本规则：</strong></p><ol><li>continue 语句用于结束本次循环，继续执行下一次循环（作用是让程序立刻跳转到下一次循环的迭代）</li><li>continue 语句出现在多层嵌套循环语句体中时，可以通过标签指明要跳过的是哪一层循环（实际开发仍不建议使用）</li><li>在 for 循环中，continue 语句使程序立即跳转到更新语句。（i++）</li><li>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。（i&gt;0）</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] numbers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br><br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i : numbers ) &#123;<br>    <span class="hljs-keyword">if</span>( i == <span class="hljs-number">4</span> ) &#123;<br>        <span class="hljs-keyword">continue</span>;    <br>    &#125;<br>    System.out.print(i);<br>&#125;<br><span class="hljs-comment">//输出：1235678</span><br></code></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><ul><li>当<code>return</code>用在方法时，表示跳出方法；</li><li>如果用在main方法，表示退出程序。</li></ul><h1 id="六、注释"><a href="#六、注释" class="headerlink" title="六、注释"></a>六、注释</h1><p>Java 中的注释有三种：</p><ul><li><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</li><li><strong>多行注释</strong>：通常用于解释一段代码的作用。（不常用）</li><li><strong>文档注释</strong>：通常用于生成 Java 开发文档。</li></ul><p>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数据类型</title>
    <link href="/2022/05/25/Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/05/25/Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li><p>6 种数字类型：</p></li><li><ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li><p>1 种字符类型：<code>char</code></p></li><li><p>1 种布尔型：<code>boolean</code></p></li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th>类型</th><th>占用存储空间</th><th>默认值</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>byte</td><td>1byte</td><td>0</td><td>-27-128</td><td>27 - 1127</td></tr><tr><td>short</td><td>2byte</td><td>0</td><td>-215-32768</td><td>215 - 132767</td></tr><tr><td>int</td><td>4byte</td><td>0</td><td>-231-2147483648</td><td>231 - 12147483647</td></tr><tr><td>long</td><td>8byte</td><td>0L</td><td>-263……</td><td>263 - 1……</td></tr><tr><td>float</td><td>4byte</td><td>0.0f</td><td>-1.4E-45 -3.403E38</td><td>3.4028235E38</td></tr><tr><td>double</td><td>8byte</td><td>0.0d</td><td>-1.798E308</td><td>1.7976931348623157E308</td></tr><tr><td>char</td><td>2byte</td><td>‘u0000’</td><td>0 \u0000</td><td>65535（216- 1）\uffff</td></tr><tr><td>boolean</td><td>1bit</td><td>false</td><td>false</td><td>true</td></tr></tbody></table><p>像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都 <strong>-1</strong> 了。这是为什么呢？</p><p>这是因为在<strong>二进制补码表示法</strong>中，<strong>最高位是用来表示符号的</strong>（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。</p><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。</p><h2 id="整型-byte、short、int、long"><a href="#整型-byte、short、int、long" class="headerlink" title="整型 - byte、short、int、long"></a>整型 - byte、short、int、long</h2><p><code>byte</code>：字节（1byte）：8位、有符号的，以二进制补码表示的整数</p><p><code>short</code>：短整型（2byte）：16 位、有符号的，以二进制补码表示的整数</p><p><code>int</code>：整型（4byte）：32位、有符号的，以二进制补码表示的整数</p><p><code>long</code>：长整型（8byte）：64 位、有符号的，以二进制补码表示的整数</p><h3 id="整型的使用细节"><a href="#整型的使用细节" class="headerlink" title="整型的使用细节"></a>整型的使用细节</h3><ol><li>Java 的整型常量默认为 <code>int</code> 型，声明 long 型常量须在后加<code>l</code>或<code>L</code>；</li><li>Java 程序中变量声常明为 <code>int</code> 型，除非不足以表示大数，才使用 <code>long</code>；</li><li><code>bit</code>: 计算机中的最小存储单位。 <code>byte</code>: 计算机中基本存储单元，<code>1byte = 8bit</code>。</li></ol><h2 id="浮点型-float、double"><a href="#浮点型-float、double" class="headerlink" title="浮点型 - float、double"></a>浮点型 - float、double</h2><p><code>float</code>：4byte：单精度、32位、符合IEEE 754 标准的浮点数</p><p><code>double</code>：8byte：双精度、64 位、符合 IEEE 754 标准的浮点数</p><h3 id="浮点型使用细节"><a href="#浮点型使用细节" class="headerlink" title="浮点型使用细节"></a>浮点型使用细节</h3><ol><li>浮点数在机器中存放形式，浮点数 &#x3D; 符号位 + 指数位 + 尾数位</li><li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li><li>浮点数默认为<code>double</code>类型，声明<code>float</code>型须在后面加上<code>f</code>或<code>F</code>。（数值加<code>d</code>表示<code>double</code>类型）</li><li>浮点数有两种表示形式：</li></ol><ul><li><ul><li>十进制数形式：如5.12 512.0f .512</li><li>科学计数法形式：如5.12e2（5.12*10^2）</li><li>科学记数法：结尾的”E+数字”表示E之前的数字要乘以10的多少次方。比如，3.14E-3就是3.14 x 10-3 &#x3D;0.00314。</li></ul></li></ul><ol><li>通常使用<code>double</code>型，精度更高</li><li>比较浮点数的时候，不能使用“<code>==</code>”操作符。（计算机 内存存储浮点数使用IEEE754标准，存在精度问题，在存储计算过程中容易引起较小的舍入误差）</li></ol><ul><li><ul><li>使用Math.abs() 方法来计算两个浮点数之间差异的绝对值，如果这个差异在阈值范围之内，我们就认为两个浮点数是相等的。如：Math.abs(num1 - num2) &lt; 0.0001</li><li>使用 BigDecimal 类的 compareTo() 方法对两个数进行比较，该方法将会忽略小数点后的位数。见示例1。（比如说 2.0 和 2.00 的位数不同，但它俩的值是相等的）</li></ul></li></ul><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.0&quot;</span>);<br><br>System.out.println(a.equals(b));  <span class="hljs-comment">//false</span><br>System.out.println(a.compareTo(b) == <span class="hljs-number">0</span>);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="字符型-char"><a href="#字符型-char" class="headerlink" title="字符型 - char"></a>字符型 - char</h2><p><code>char</code>：2byte：单一的 16 位 Unicode 字符</p><h3 id="字符型使用细节"><a href="#字符型使用细节" class="headerlink" title="字符型使用细节"></a>字符型使用细节</h3><ol><li><code>char</code>用单引号<code>&#39; &#39;</code>，<code>String</code>字符串用双引号<code>&quot; &quot;</code></li><li>转义字符 ‘<code>\</code>‘ ，将其后的字符转变为特殊字符型常量。如：<code>char c = &#39;\n&#39;</code></li><li>Java 中，<code>char</code>本质是一个整数，输出时是 unicode 编码对应的字符（因此可直接赋值<code>char</code>一个整数）</li></ol><ul><li><ul><li>Unicode与中文之间的相互转换工具：<a href="https://www.w3cschool.cn/tools/index?name=unicode_chinese">在线Unicode&#x2F;中文转换工具 - 编码转换工具 - W3Cschool</a></li><li><a href="http://tool.chinaz.com/Tools/Unicode.aspx">Unicode编码转换 - 站长工具</a></li></ul></li></ul><ol><li>由3.可得，<code>char</code>类型可进行运算。</li><li>字符型存储到计算机中，需要找到字符对应的码值（整数），比如<code>&#39;a&#39;</code>：</li></ol><ul><li><ul><li>存储：<code>&#39;a&#39;</code> –&gt; 码值 97 –&gt; 二进制 0110 0001 –&gt; 存储</li></ul></li></ul><ol><li>字符编码表：</li></ol><ul><li><ul><li>- ASCII 编码表 1 个字节表示，一个128个字符（实际上一个字节可以表示256个字符，只用了128个）</li><li>Unicode 编码表 固定大小的编码，使用 2 个字节表示，字母和汉字统一占用 2 个字节（但这样浪费空间）。（Unicode兼容ASCII）</li><li>utf-8 编码表：大小可变的编码，使用1-6个字节表示一个符号，字母使用 1 个字节，汉字使用 3 个字节（实际开发用得最多）（Unicode的改进方式，互联网使用最广）</li><li>gbk 可以表示汉字，范围广，字母使用 1 个字节，汉字使用 2 个字节</li><li>gb2312 可以表示汉字，gb2312 &lt; gbk</li><li>big5 码，繁体中文，tw hk</li></ul></li></ul><h2 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型 - boolean"></a>布尔型 - boolean</h2><p><code>boolean</code>：1bit： 1 位，作为一种标志来记录 true&#x2F;false 情况</p><p>（准确讲是1byte，计算机处理数据的最小单位是 1 个字节）</p><p>事实上：boolean 占用多少字节取决于虚拟机本身的实现，《Java 虚拟机规范》提议：</p><ul><li>如果 boolean 是 “单独使用”：boolean 被编译为 int 类型，占 4 个字节</li><li>如果 boolean 是以 “boolean 数组” 的形式使用：boolean 占 1 个字节</li></ul><h3 id="布尔型细节"><a href="#布尔型细节" class="headerlink" title="布尔型细节"></a>布尔型细节</h3><ol><li>Java中不可以用 0 或者非 0 整数替代 false 和 true，这点和C、php等语言不同。</li></ol><h1 id="Java-类型转换"><a href="#Java-类型转换" class="headerlink" title="Java 类型转换"></a>Java 类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>自动类型转换：</strong>低精度数据类型 自动转换为 高精度数据类型：</p><ul><li>char –&gt; int –&gt; long –&gt; float –&gt; double</li><li>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</li></ul><p><strong>示例2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span>;  <span class="hljs-comment">//true char --&gt; int</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;  <span class="hljs-comment">//true int --&gt; double</span><br></code></pre></td></tr></table></figure><h3 id="自动类型转换细节"><a href="#自动类型转换细节" class="headerlink" title="自动类型转换细节"></a>自动类型转换细节</h3><ol><li>多种类型得数据混合运算时，系统自动将所有数据转换成精度（容量）最大的数据类型，然后再进行计算：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1.2</span>;  <span class="hljs-comment">//double 11.2</span><br></code></pre></td></tr></table></figure><ol><li>当把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错。</li><li>（<code>byte</code>, <code>short</code>） 和 <code>char</code> 之间不会相互自动转换。</li><li><code>byte</code>, <code>short</code>, <code>char</code> 三者可以计算，在计算时首先转换为 <code>**int**</code> 类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b1 + s;     <span class="hljs-comment">// √ 因为：b1 + s =&gt; int</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> b1 + b2;  <span class="hljs-comment">// × 因为：b1 + b3 =&gt; int</span><br></code></pre></td></tr></table></figure><ol><li>boolean 不参与转换</li><li>自动提升原则：表达式结果的类型自动提升为<strong>操作数中最大的类型</strong>。</li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。需要加上强制转换符()，但可能造成精度降低或溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(s + b);  <span class="hljs-comment">//由于(s+b)=&gt;int，因此要强制转换成short才不报错</span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型和String类型的转换"><a href="#基本数据类型和String类型的转换" class="headerlink" title="基本数据类型和String类型的转换"></a>基本数据类型和String类型的转换</h3><ol><li><strong>基本类型转String类型</strong></li></ol><p>方法：直接拼接个双引号””</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><ol><li><strong>String类型转基本类型</strong></li></ol><p>方法：通过基本类型的包装类调用<code>parseXX</code>方法即可（每一个基本类型都对应一个包装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;24&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br></code></pre></td></tr></table></figure><p><code>String</code>转换成<code>char</code> &#x3D;&#x3D;&gt; 得到字符串的第一个字符 （利用<code>charAt(n)</code>方法，将字符串的第<code>n</code>个字符取出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(s.charAt(<span class="hljs-number">0</span>))  <span class="hljs-comment">//s.charAt(0) 得到字符串s的第一个字符&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure><ol><li><strong>注意</strong></li></ol><ul><li>将<code>String</code>类型转成基本数据类型时，要确保<code>String</code>类型能够转成有效的数据，比如可以把<code>&quot;123&quot;</code>转成一个整数，但是不能把<code>&quot;shit&quot;</code>转成一个整数。</li><li>如果格式不正确，就会抛出异常，程序终止。</li></ul><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul><li>在进行基本的数据计算时，开发者可以直接使用基本数据类型。</li><li>但是当需要和Java其他对象结合使用，如存入集合中，就需要将基础数据类型实例封装为Java对象，</li><li>为了面向对象的这一特性，基本数据类型中的每一个类型在<code>java.lang</code>包中都有一个包装类，即将每个基本类型都包装成了一个类。八种基本类型对应包装类：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</li></ul><hr><table>    <tr>        <td>基本数据类型</td>        <td>包装类</td>        <td>接口</td>        <td>父类</td>        <td>接口</td>        <td>父类</td>    </tr>    <tr>        <td>boolean</td>        <td>Boolean</td>        <td rowspan="8">Comparable</td>        <td rowspan="2">—</td>        <td rowspan="8">Serializable</td>        <td rowspan="8">Object</td>    </tr>    <tr>        <td>char</td>        <td>Character</td>    </tr>    <tr>        <td>byte</td>        <td>Byte</td>        <td rowspan="6">Number</td>    </tr>    <tr>        <td>short</td>        <td>Short</td>    </tr>    <tr>        <td>int</td>        <td>Integer</td>    </tr>    <tr>        <td>long</td>        <td>Long</td>    </tr>    <tr>        <td>float</td>        <td>Float</td>    </tr>    <tr>        <td>double</td>        <td>Double</td>    </tr></table><h2 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h2><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中 [1]。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p>[1] 为什么说是<strong>几乎</strong>所有对象实例都存在于堆中呢？ </p><p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>更多参考：<a href="https://www.yuque.com/kingshit/java/khlmi9x1su7i6vr6">JIT逃逸分析</a></p><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 成员变量，存放在堆中</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">// 被 static 修饰，也存放在堆中，但属于类，不属于对象</span><br>    <span class="hljs-comment">// JDK1.7 静态变量从永久代移动了 Java 堆中</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 局部变量，存放在栈中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>; <span class="hljs-comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本数据类型和包装类转换"><a href="#基本数据类型和包装类转换" class="headerlink" title="基本数据类型和包装类转换"></a>基本数据类型和包装类转换</h2><ol><li>jdk5 前的手动装箱和拆箱方式。（装箱：基本类型 -&gt; 包装类型；拆箱：包装类型 -&gt; 基本类型）</li><li>jdk5 及以后的自动装箱和拆箱方式。</li><li>自动装箱底层调用的是<code>valueOf</code>方法，比如<code>Integer.valueOf()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer3</span> <span class="hljs-operator">=</span> n2;<br><span class="hljs-comment">//底层使用的是 Integer.valueOf(n2); </span><br><span class="hljs-comment">// valueOf本质是 当在 -128~127 时，直接返回；否则 new Integer(i); 详见</span><br><br><span class="hljs-comment">//自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> integer3;<br><span class="hljs-comment">//底层使用的是 integer2.intValue()，return integer3对象的value</span><br></code></pre></td></tr></table></figure><h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p><strong>装箱：</strong>将基本类型用它们对应的引用类型包装起来</p><p><strong>拆箱：</strong>将包装类型转换为基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱 等价于 Integer i = Integer.valueOf(10)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱 等价于 int n = i.intValue();</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><h2 id="浮点数运算的精度丢失风险"><a href="#浮点数运算的精度丢失风险" class="headerlink" title="浮点数运算的精度丢失风险"></a>浮点数运算的精度丢失风险</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.8f</span> - <span class="hljs-number">1.7f</span>;<br>System.out.println(a);  <span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);  <span class="hljs-comment">// 0.099999905</span><br>System.out.println(a == b);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>原因：</strong>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><p>更多内容详见：<a href="https://www.yuque.com/kingshit/wz61vk/yxked8f04twgtmnl">浮点数</a></p><h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到<strong>货币</strong>的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(c);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.2 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.20 */</span><br><span class="hljs-comment">// 比较内容，不是比较值</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* false */</span><br><span class="hljs-comment">// 比较值相等用compareTo，相等返回0</span><br>System.out.println(<span class="hljs-number">0</span> == x.compareTo(y)); <span class="hljs-comment">/* true */</span><br></code></pre></td></tr></table></figure><p>关于 <code>BigDecimal</code> 的详细介绍，参考：<a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a>。</p><h2 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h2><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><p>在 Java 中，64 位 long 整型是最大的整数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span><br>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h2 id="String类型和包装类转换"><a href="#String类型和包装类转换" class="headerlink" title="String类型和包装类转换"></a>String类型和包装类转换</h2><p>包装类（Integer 为例） -&gt; String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//方式一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;  <br><span class="hljs-comment">//底层创建一个基于i对象的值的String对象，i对象的类型并没有改变</span><br><br><span class="hljs-comment">//方式二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> i.toString();  <span class="hljs-comment">//</span><br><br><span class="hljs-comment">//方式三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> String.valueOf(i);  <br><span class="hljs-comment">//底层还是跟方式二一样调用toString： </span><br><span class="hljs-comment">// return (obj == null) ? &quot;null&quot; : obj.toString()</span><br></code></pre></td></tr></table></figure><p>String -&gt; 包装类（Integer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">//方式一：调用包装类的转换方法parseXxx()</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.parseInt(str);  <span class="hljs-comment">//底层：调用parseInt(s, 10); 参数radix:10表示输出十进制整数</span><br><br><span class="hljs-comment">//方式二：调用Integer构造器</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str);  <span class="hljs-comment">//底层还是跟方式一一样：this.value = parseInt(s, 10); </span><br></code></pre></td></tr></table></figure><h2 id="包装类缓存机制"><a href="#包装类缓存机制" class="headerlink" title="包装类缓存机制"></a>包装类缓存机制</h2><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128, 127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0, 127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p><strong>所有整型包装类对象之间值的比较，全部使用</strong> <code>**equals**</code> <strong>方法比较。</strong></p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    System.out.println(i1 == j2);  <span class="hljs-comment">// false  new出来的是不同的对象</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 底层调用valueOf方法，当传入参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 等价于 Integer i4 = Integer.valueOf(127)</span><br>    System.out.println(i3 == i4);  <span class="hljs-comment">// true</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 底层调用valueOf方法，当传入参数不在 -128~127 范围时，直接创建新对象。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i6</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 同上</span><br>    System.out.println(i5 == i6);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i7</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// 从数组里面取值，属于数组对象</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);  <span class="hljs-comment">// new出来的新对象</span><br>    System.out.println(i7 == i8);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i9</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// Integer对象</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i10</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;                  <span class="hljs-comment">// 基本数据类型</span><br>    System.out.println(i9 == i10);  <span class="hljs-comment">// true  只要有基本数据类型，就是判断值是否相等!!!</span><br><br>    <span class="hljs-comment">// 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。</span><br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br>    <br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i13</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i14</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>valueOf()</code>源码：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/valueOf%E6%BA%90%E7%A0%81.png" alt="valueOf源码"></p><p><strong>解读：</strong></p><ul><li>当传入的参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</li><li>当传入的参数不在 -128~127 范围时，直接创建新对象。</li></ul><p><code>**IntegerCache.cache**</code><strong>数组（部分）</strong>：</p><p>该数组由包装类<code>Integer</code>创建，大小为 256，存储了 -128~127</p><p><strong>Character</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">isDigit</span><span class="hljs-params">()</span></span>`方法：确定指定的字符是否为数字，返回`boolean<br></code></pre></td></tr></table></figure><p>示例：判断字符串是否都为数字组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断一个字符串是否都为数字组成</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span> ( !(Character.isDigit(str.charAt(i))) ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础概念</title>
    <link href="/2022/05/24/Java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/05/24/Java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE-EE-ME"><a href="#Java-SE-EE-ME" class="headerlink" title="Java SE EE ME"></a>Java SE EE ME</h1><p>Java SE 就是标准版，包含标准的 JVM 和标准库</p><p>Java EE 是企业版，它只是在 Java SE 的基础上加上了大量的 API 和库，以便方便开发 Web 应用、数据库、消息服务等。</p><p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Java%E7%89%88%E6%9C%AC.png" alt="Java版本"></p><h1 id="JVM-amp-JDK-amp-JRE"><a href="#JVM-amp-JDK-amp-JRE" class="headerlink" title="JVM &amp; JDK &amp; JRE"></a>JVM &amp; JDK &amp; JRE</h1><p><strong>JVM（Java Virtual Machine, Java 虚拟机）</strong>并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p>维基百科上就有常见 JVM 的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">Comparison of Java virtual machinesopen in new window</a> ，感兴趣的可以去看看。并且，你可以在 <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specificationsopen in new window</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JVM%E6%A8%A1%E5%9E%8B.png" alt="JVM模型"></p><p><strong>JDK（Java Development Kit）</strong>是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，还包含了 javac（编译 java 源码的编译器）以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p><p><strong>JRE（Java Runtime Environment）</strong>是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p><h2 id="JDK、JRE-和-JVM-的包含关系"><a href="#JDK、JRE-和-JVM-的包含关系" class="headerlink" title="JDK、JRE 和 JVM 的包含关系"></a>JDK、JRE 和 JVM 的包含关系</h2><p>JDK &#x3D; JRE + 开发工具集（例如 javac，java 编译工具等）</p><p>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）</p><p>如果只想运行开发好的<code>.class</code>文件，只需要 JRE。</p><p>但对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK.png" alt="JDK"></p><p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ <a href="http://openjdk.java.net/jeps/282">jlink</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。详见： <a href="https://javaguide.cn/java/new-features/java9.html">Java 9 新特性概览</a>。</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>官网：<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p><h2 id="配置环境变量path"><a href="#配置环境变量path" class="headerlink" title="配置环境变量path"></a>配置环境变量path</h2><ol><li>环境变量 - 系统变量 - 添加 JAVA_HOME 环境变量，指向 jdk 的安装目录 <code>D:\Program Files\jdk8\jdk1.8.0_333</code></li><li>编辑 path 环境变量，增加 <code>%JAVA_HOME%\bin</code></li><li>为了确保 jre（运行）在你使用 javaIDE 的时候不产生问题，新增配置 <code>%JAVA_HOME%\jre\bin</code></li></ol><p>windows 操作系统是如何搜索硬盘上某个命令？</p><ol><li>首先会从当前目录下搜索</li><li>当前目录搜索不到的话，会从环境变量path指定的路径当中搜索某个命令</li><li>如果都搜索不到，则报错</li></ol><h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><p>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><h1 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h1><ol><li>Java 源码本质上是一个文本文件，需要先用<code>javac</code>把 Xxx.java 编译成字节码文件 Xxx.class，然后，用<code>java</code>命令执行这个字节码文件</li><li>给虚拟机（JVM）传递的参数<code>Hello</code>是我们定义的类名，JVM 会启动<strong>类加载器（ClassLoader）</strong>，ClassLoader 会自动查找对应的 class 文件装载到 JVM 中执行。</li><li>JVM 将 Xxx.class 字节码文件解释成二进制数据。</li><li>操作系统执行二进制和底层硬件平台进行交互。</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C.png" alt="编译与运行"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol><li>编译阶段主要的任务是检查 Java 源程序是否符合Java语法</li><li>符合 Java 语法则生成正常的字节码文件（<code>xxx.class</code>）</li></ol><p>字节码文件中不是纯粹的二进制，这种文件无法在操作系统中直接执行。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac Hello.java<br></code></pre></td></tr></table></figure><ol><li>java 源文件，通过编译器编译成JVM可识别的字节码文件</li><li>通过<code>javac.exe</code>编译工具对<code>Hello.java</code>文件进行编译</li><li>若程序没错，则没有任何提示，并在源文件同目录出现一个<code>Hello.class</code>文件，该文件称为字节码文件，是可以执行的 java 程序</li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>java.exe</code>主要负责运行阶段</p><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java Hello<br></code></pre></td></tr></table></figure><ol><li>有了可执行的 java 程序（<code>.class</code>字节码文件）</li><li>通过运行工具<code>java.exe</code>对字节码文件进行执行，本质是<code>.class</code>装载到 JVM 执行</li></ol><p>注：dos控制台默认简体中文 GBK 编码，若源码有中文，则需要以 chinese 编码保存</p><h2 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h2><ol><li>Java应用程序的执行入口是main()方法。有固定书写格式：public static void main(String[] args){…}</li><li>Java语言严格区分大小写。</li><li>类首字母大写。</li><li>一个源文件中最多只有一个public类。其他类个数不限。[示例1]</li><li>如果源文件中包含一个public类，则文件名必须按该类名命名。</li><li>也可以将mian方法写在非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法。[示例1]</li></ol><p>示例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;yo my nigga!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编译后，每个类都对应一个.class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是皮蛋&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>&#125;<br># 编译 <span class="hljs-keyword">public</span> 类命名的文件<br>javac Hello.java <br><br># 运行里面的 Cat 类<br>java Cat <br></code></pre></td></tr></table></figure><p>在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p><p>　　1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。</p><p>　　2.public类的名称必须完全与含有该编译单元的文件名相同，包含大小写。如果不匹配，同样将得到编译错误。</p><p>　　3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。</p><p>一个编译单元（java文件）可以存在多个类，在编译时产生多个不同的<code>.class</code>文件， <code>.class</code>文件便是程序运行的数据来源。</p><p>java 将 public 类作为每个编译单元的数据接口，只能有一个，不然不能处理存在多个类的 java 文件。当一个编译单元（java文件）有多个非 public 类时，运行时需要对数据来源进行选择。</p><h2 id="Java-API文档"><a href="#Java-API文档" class="headerlink" title="Java API文档"></a>Java API文档</h2><p>API（Application Programming Interface）是Java提供的基本编程接口（java提供的类和相关方法）。中文在线文档：<a href="https://www.matools.com/">https://www.matools.com</a></p><h1 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h1><p>高级编程语言按照程序的执行方式分为两种：</p><ul><li>编译型：编译型语言open in new window 会通过编译器open in new window将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li><li>解释型：解释型语言open in new window会通过解释器open in new window一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li></ul><p><code>.class -&gt; 机器码</code>这一步：</p><ul><li><strong>JVM 类加载器</strong>首先加载<code>.class</code>字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</li></ul><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 <strong>JIT（Just in Time Compilation） 编译器</strong>，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong>。</p><p>🌈 拓展：<a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">有关 JIT 的实现细节: JVM C1、C2 编译器</a></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B-%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AAJavaGuide.png" alt="Java程序转变为机器代码的过程-图片来自JavaGuide"></p><p>Java程序转变为机器代码的过程</p><p>HotSpot 采用了<strong>惰性评估（Lazy Evaluation）</strong>的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h1 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h1><h2 id="什么是AOT？"><a href="#什么是AOT？" class="headerlink" title="什么是AOT？"></a>什么是AOT？</h2><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><p>JIT 与 AOT 两者的关键指标对比：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/AOTvsJIT.png" alt="AOTvsJIT"></p><p>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p>提到 AOT 就不得不提 GraalVMopen in new window 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。感兴趣的同学，可以去看看 GraalVM 的<a href="https://www.graalvm.org/latest/docs/">官方文档</a>。如果觉得官方文档看着比较难理解的话，也可以找一些文章来看看，比如：</p><ul><li><a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">基于静态编译构建微服务应用</a></li><li><a href="https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/%E8%B5%B0%E5%90%91-native-%E5%8C%96springdubbo-aot-%E6%8A%80%E6%9C%AF%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/">走向 Native 化：Spring&amp;Dubbo AOT 技术示例与原理讲解</a></li></ul><h2 id="为什么不全部使用-AOT-呢？"><a href="#为什么不全部使用-AOT-呢？" class="headerlink" title="为什么不全部使用 AOT 呢？"></a>为什么不全部使用 AOT 呢？</h2><p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。</p><p>除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</p><p>举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h1 id="Oracle-JDK-vs-OpenJDK"><a href="#Oracle-JDK-vs-OpenJDK" class="headerlink" title="Oracle JDK vs OpenJDK"></a>Oracle JDK vs OpenJDK</h1><p>首先，2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。</p><p>其次，对于 Java 7 而言，OpenJDK 和 Oracle JDK 是十分接近的。 Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。</p><p>下面这段话摘自 Oracle 官方在 2012 年发表的一个博客：</p><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p><p>最后，简单总结一下 Oracle JDK 和 OpenJDK 的区别：</p><ul><li><strong>是否开源</strong>：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引起很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目：<a href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdkopen in new window</a> 。</li><li><strong>是否免费</strong>：Oracle JDK 会提供免费版本，但一般有时间限制。JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。</li><li><strong>功能性</strong>：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。</li><li><strong>稳定性</strong>：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。</li><li><strong>协议</strong>：Oracle JDK 使用 BCL&#x2F;OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ul><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类（详见Java API文档）</li><li>控制访问范围</li></ol><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ol><li>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package</li><li>import 指令位置放在 package 下面，在类定义前面，可以有多句且没有顺序要求</li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">package</span> com.rwj;  <br><span class="hljs-comment">// package关键字：表示打包</span><br><span class="hljs-comment">// com.rwj：表示包名</span><br><br><span class="hljs-comment">// 导入/引入</span><br><span class="hljs-keyword">import</span> java.util.Scanner;  <span class="hljs-comment">//表示只会引入java.util包下的Scanner类</span><br><span class="hljs-keyword">import</span> java.util.*;  <span class="hljs-comment">//表示将java.util包下的所有类都引入</span><br></code></pre></td></tr></table></figure><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>创建不同的目录&#x2F;文件夹来保存类文件。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>只能包含数字、字母、下划线、小圆点，不能用数字开头，不能是关键字或保留字</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.公司名.项目名.业务模块名<br></code></pre></td></tr></table></figure><p><code>com.sina.crm.user</code> &#x2F;&#x2F;用户模块</p><p><code>com.sina.crm.order</code> &#x2F;&#x2F;订单模块</p><p><code>com.sina.crm.utils</code> &#x2F;&#x2F;工具类</p><h2 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h2><p><code>java.lang.*</code>：lang 包是基本包，默认引入，不需要再手动引入</p><p><code>java.util.*</code>：util 包，系统提供的工具包，工具类，使用 Scanner</p><p><code>java.net.*</code>：网络包，网络开发</p><p><code>java.awt.*</code>：做 java 界面开发，GUI</p><hr><p>参考</p><p><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">Java基础常见面试题总结(上)</a></p><p><a href="https://liaoxuefeng.com/books/java/quick-start/history/index.html">Java历史 - Java教程 - 廖雪峰的官方网站</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
