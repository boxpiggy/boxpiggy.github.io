<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python 访问数据库</title>
    <link href="/2023/10/17/Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/10/17/Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为<code>Connection</code>；</p><p>连接到数据库后，需要打开游标，称之为<code>Cursor</code>，通过<code>Cursor</code>执行 SQL 语句，然后，获得执行结果。</p><p>Python 定义了一套操作数据库的 API 接口，任何数据库要连接到 Python，只需要提供符合 Python 标准的数据库驱动即可。</p><h1 id="一、常用数据库"><a href="#一、常用数据库" class="headerlink" title="一、常用数据库"></a>一、常用数据库</h1><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 是一种嵌入式数据库，它的数据库就是一个文件。由于 SQLite 本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在 iOS 和 Android 的 App 中都可以集成。Python 就内置了 SQLite3。</p><h3 id="导入数据库模块"><a href="#导入数据库模块" class="headerlink" title="导入数据库模块"></a>导入数据库模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">import sqlite3<br></code></pre></td></tr></table></figure><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>在 python 中，使用 sqlite3 创建数据库的连接，当我们指定的数据库文件不存在的时候连接对象会自动创建数据库文件；如果数据库文件已经存在，则连接对象不会再创建数据库文件，而是直接打开该数据库文件。</p><p>连接对象可以是<strong>硬盘</strong>上面的数据库文件，也可以是建立在<strong>内存</strong>（memory）中的，在内存中的数据库执行完任何操作后，都不需要提交事务的(commit)</p><p><code>connect</code>方法返回<code>con</code>对象，即是数据库链接对象，它提供了以下方法：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.cursor()</td><td>创建一个游标对象</td></tr><tr><td>.commit()</td><td>处理事务提交</td></tr><tr><td>.rollback()</td><td>处理事务回滚</td></tr><tr><td>.close()</td><td>关闭一个数据库连接</td></tr></tbody></table><h4 id="在硬盘上建立数据库"><a href="#在硬盘上建立数据库" class="headerlink" title="在硬盘上建立数据库"></a>在硬盘上建立数据库</h4><ul><li>数据库的名称不区分大小写，且以第一次建立时的名字为准。</li><li>不加全路径时，数据库文件会自动建立在工程项目文件夹下。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">con=sqlite3.connect(<span class="hljs-string">&quot;D:\Test.db&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="在内存上建立数据库"><a href="#在内存上建立数据库" class="headerlink" title="在内存上建立数据库"></a>在内存上建立数据库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">con = sqlite3.connect(<span class="hljs-string">&quot;memory&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cur = con.cursor()<br></code></pre></td></tr></table></figure><p>游标对象有以下方法支持数据库操作：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.execute()</td><td>用来执行sql语句</td></tr><tr><td>.executemany()</td><td>用来执行多条sql语句</td></tr><tr><td>.close()</td><td>用来关闭游标</td></tr><tr><td>.fetchone()</td><td>用来从结果中取一条记录，并将游标指向下一条记录</td></tr><tr><td>.fetchmany()</td><td>用来从结果中取多条记录。</td></tr><tr><td>.fetchall()</td><td>用来从结果中取出所以记录。</td></tr><tr><td>.scroll()</td><td>用于游标滚动。</td></tr></tbody></table><p>注意：使用游标的方法返回的数据类型是列表。</p><h3 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h3><h3 id="事务提交或回滚"><a href="#事务提交或回滚" class="headerlink" title="事务提交或回滚"></a>事务提交或回滚</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提交</span><br>con.commit()<br><br><span class="hljs-comment"># 回滚</span><br>con.rollback()<br><br><span class="hljs-comment"># 关闭游标</span><br>cur.close()<br><span class="hljs-comment"># 关闭数据库连接</span><br>con.close()<br></code></pre></td></tr></table></figure><p>注意：一定要先关闭游标，再关闭数据库连接，否则会报错！</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>SQLite 的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用。而MySQL 是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于 SQLite。</p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>由于 MySQL 服务器以独立的进程运行，并通过网络对外服务，所以，需要支持 Python 的 MySQL 驱动来连接到 MySQL 服务器。</p><p>MySQL 官方提供了 mysql-connector-python 驱动，但是安装的时候需要给 <code>pip</code> 命令加上参数<code>--allow-external</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install mysql-connector-python --allow-external mysql-connector-python<br><span class="hljs-comment"># 如果上面的命令安装失败，可以试试另一个驱动：</span><br>pip install mysql-connector<br></code></pre></td></tr></table></figure><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 导入MySQL驱动:</span><br>&gt;&gt;&gt; import mysql.connector<br><br><span class="hljs-comment"># 注意把password设为你的root口令:</span><br>&gt;&gt;&gt; conn = mysql.connector.connect(user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&#x27;password&#x27;</span>, database=<span class="hljs-string">&#x27;test&#x27;</span>)<br>&gt;&gt;&gt; cursor = conn.cursor()<br><br><span class="hljs-comment"># 创建user表:</span><br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;</span>)<br><br><span class="hljs-comment"># 插入一行记录，注意MySQL的占位符是%s:</span><br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;insert into user (id, name) values (%s, %s)&#x27;</span>, [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>])<br>&gt;&gt;&gt; cursor.rowcount<br>1<br><br><span class="hljs-comment"># 提交事务:</span><br>&gt;&gt;&gt; conn.commit()<br>&gt;&gt;&gt; cursor.close()<br><br><span class="hljs-comment"># 运行查询:</span><br>&gt;&gt;&gt; cursor = conn.cursor()<br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;select * from user where id = %s&#x27;</span>, (<span class="hljs-string">&#x27;1&#x27;</span>,))<br>&gt;&gt;&gt; values = cursor.fetchall()<br>&gt;&gt;&gt; values<br>[(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>)]<br><br><span class="hljs-comment"># 关闭Cursor和Connection:</span><br>&gt;&gt;&gt; cursor.close()<br>True<br>&gt;&gt;&gt; conn.close()<br></code></pre></td></tr></table></figure><h1 id="二、使用-ORM-框架"><a href="#二、使用-ORM-框架" class="headerlink" title="二、使用 ORM 框架"></a>二、使用 ORM 框架</h1><h2 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>数据库表是一个二维表，包含多行多列。把一个表的内容用 Python 的数据结构表示出来的话，可以用一个<code>list</code>表示多行，<code>list</code>的每一个元素是 <code>tuple</code>，表示一行记录，比如，包含<code>id</code>和<code>name</code>的<code>use</code> 表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[<br>    (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>),<br>    (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>),<br>    (<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure><p>Python 的 DB-API 返回的数据结构就是像上面这样表示的。</p><p>但是用<code>tuple</code>表示一行很难看出表的结构。如果把一个<code>tuple</code>用 <code>class</code> 实例来表示，就可以更容易地看出表的结构来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br><br>[<br>    User(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>),<br>    User(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>),<br>    User(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure><p>这就是传说中的 ORM 技术：<strong>Object-Relational Mapping</strong>，把<strong>关系数据库的表结构映射到对象上</strong>。</p><p>但是由谁来做这个转换呢？</p><p>所以 ORM 框架应运而生。在 Python 中，最有名的 ORM 框架是 SQLAlchemy。我们来看看 SQLAlchemy 的用法。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install sqlalchemy<br></code></pre></td></tr></table></figure><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SQLAlchemy 的初始化和对象定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入:</span><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, String, create_engine<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker<br><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br><br><span class="hljs-comment"># 创建对象的基类:</span><br>Base = declarative_base()<br><br><span class="hljs-comment"># 定义User对象:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    <span class="hljs-comment"># 表的名字:</span><br>    __tablename__ = <span class="hljs-string">&#x27;user&#x27;</span><br><br>    <span class="hljs-comment"># 表的结构:</span><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br><br><span class="hljs-comment"># 初始化数据库连接:</span><br>engine = create_engine(<span class="hljs-string">&#x27;mysql+mysqlconnector://root:password@localhost:3306/test&#x27;</span>)<br><span class="hljs-comment"># 创建DBSession类型:</span><br>DBSession = sessionmaker(bind=engine)<br></code></pre></td></tr></table></figure><p>以上代码完成 SQLAlchemy 的初始化和具体每个表的class定义。</p><p>create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：</p><p>‘数据库类型+数据库驱动名称:&#x2F;&#x2F;用户名:口令@机器地址:端口号&#x2F;数据库名’</p><p>如果有多个表，就继续定义其他 class，例如 School：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;school&#x27;</span><br>    <span class="hljs-built_in">id</span> = ...<br>    name = ...<br></code></pre></td></tr></table></figure><h4 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h4><p>由于有了 ORM，我们向数据库表中添加一行记录，可以视为添加一个<code>User</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建session对象:</span><br>session = DBSession()<br><span class="hljs-comment"># 创建新User对象:</span><br>new_user = User(<span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;5&#x27;</span>, name=<span class="hljs-string">&#x27;Bob&#x27;</span>)<br><span class="hljs-comment"># 添加到session:</span><br>session.add(new_user)<br><span class="hljs-comment"># 提交即保存到数据库:</span><br>session.commit()<br><span class="hljs-comment"># 关闭session:</span><br>session.close()<br></code></pre></td></tr></table></figure><p>可见，关键是获取<code>session</code>，然后把对象添加到<code>session</code>，最后提交并关闭。</p><p><code>DBSession</code> 对象可视为当前数据库连接。</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>有了ORM，查询出来的可以不再是<code>tuple</code>，而是<code>User</code>对象。SQLAlchemy 提供的查询接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建Session:</span><br>session = DBSession()<br><span class="hljs-comment"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:</span><br>user = session.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span>==<span class="hljs-string">&#x27;5&#x27;</span>).one()<br><span class="hljs-comment"># 打印类型和对象的name属性:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;type:&#x27;</span>, <span class="hljs-built_in">type</span>(user))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, user.name)<br><span class="hljs-comment"># 关闭Session:</span><br>session.close()<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.User&#x27;</span>&gt;<br>name: Bob<br></code></pre></td></tr></table></figure><h4 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h4><p>由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM 框架也可以提供两个对象之间的一对多、多对多等功能。</p><p>例如，如果一个<code>User</code>拥有多个<code>Book</code>，就可以定义一对多关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;user&#x27;</span><br><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br>    <span class="hljs-comment"># 一对多:</span><br>    books = relationship(<span class="hljs-string">&#x27;Book&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;book&#x27;</span><br><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br>    <span class="hljs-comment"># “多”的一方的book表是通过外键关联到user表的:</span><br>    user_id = Column(String(<span class="hljs-number">20</span>), ForeignKey(<span class="hljs-string">&#x27;user.id&#x27;</span>))<br></code></pre></td></tr></table></figure><p>当我们查询一个<code>User</code>对象时，该对象的<code>books</code>属性将返回一个包含若干个<code>Book</code>对象的<code>list</code>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="executemany"><a href="#executemany" class="headerlink" title="executemany()"></a>executemany()</h4><p>在<code>executemany()</code>方法中，参数列表需要是一个可迭代对象，并且每个元素都需要是一个序列（例如列表、元组等）。这是为了支持批量执行多次操作。</p><p>为了满足<code>executemany()</code>方法的要求，需要将每个参数以元组形式传递，即使是只有一个值的情况也不例外。这样可以确保参数列表与 SQL 语句中占位符的数量和顺序相匹配，从而正确地执行批量操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 计算生态</title>
    <link href="/2023/08/18/Python-%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81/"/>
    <url>/2023/08/18/Python-%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><p>PyPEF2：处理pdf文件的工具集</p><p>支持获取信息、分隔&#x2F;整合文件、加密解密等</p><p>完全Python语言实现，不需要额外依赖，功能稳定</p><p>NLTK：自然语言文本处理第三方库</p><p>支持语言文本分类、标记、语法句法、语义解析等</p><p>最好的Python自然语言处理库</p><p>Python-docx：创建或更新Microsoft Word文件的第三方库</p><p>提供创建或更新.doc .docx等文件的计算功能</p><p>增加并配置段落、图片、表格、文字等，功能全面</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p><strong>Numpy</strong>：表达N维数组的最基础库</p><ul><li>C语言实现，对外接口是python语言，计算速度优异</li><li>数据分析及科学计算的基础库</li><li>提供直接的矩阵运算、广播函数、线性代数等功能</li><li>Numpy最基础单元是一个数组，数组是一个变量</li></ul><p><strong>Pandas</strong>：Python数据分析高层次应用库</p><ul><li><p>操作索引即操作数据</p></li><li><p>Python最主要的数据分析功能库，基于Numpy开发</p></li><li><p>Pandas核心提供两个数据结构：</p></li><li><ul><li>Series &#x3D; 索引 + 一维数据</li><li>DataFrame &#x3D; 行列索引 + 二维数据</li></ul></li></ul><p>Pandas 库通过扩展了对一维和二维数据的表示，因而能够形成更高层次对数据的操作，简化数据分析的运行</p><p><strong>SciPy</strong>：数学、科学和工程计算功能库</p><ul><li>提供一批数学算法及工程数据运算功能</li><li>雷系Matlab，可用于如傅里叶变换、信号处理等应用</li><li>Python最主要的科学计算功能库，基于Numpy开发</li></ul><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p><strong>Matplotlib</strong>：高质量的二维数据可视化功能库</p><ul><li>通过 matplotlib.pyplot 子库调用各可视化效果（把所有有效的可视化展示方法汇集到一个子库中，相当于各个子库的快捷方式）</li><li>Python最主要的数据可视化功能库，基于Numpy开发</li></ul><p><strong>Seaborn</strong>：统计类数据可视化功能库</p><ul><li>提供了一批高层次统计类数据可视化展示效果</li><li>主要展示数据间分布、分类和线性关系等内容</li><li>基于Matplotlib开发，支持Numpy和Pandas</li></ul><p><strong>Mayavi</strong>：三维科学数据可视化功能库</p><ul><li>提供了一批易用的3D科学计算数据可视化展示效果</li><li>目前版本是Mayavi2，三维可视化最主要的第三方库</li><li>支持Numpy、TVTK、Traits、Envisage等第三方库</li></ul><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p><strong>Scikit-learn</strong>：机器学习方法工具集</p><ul><li>提供聚类、分类、回归、强化学习等计算功能</li><li>机器学习最基本且最优秀的Python第三方库</li></ul><p><strong>TensorFlow</strong>：AlphaGo背后的机器学习计算框架</p><ul><li>谷歌公司推动的开源机器学习框架</li><li>将数据流图作为基础，图节点代表运算，边代表张亮</li><li>应用机器学习方法的一种方式，支撑谷歌人工智能应用</li></ul><p>深度学习</p><p><strong>MXNet</strong>：基于神经网络的深度学习计算框架</p><ul><li>可用于自动驾驶、机器翻译、语音识别等众多领域</li><li>Python最重要的深度学习计算框架</li></ul><h1 id="从Web解析到网络空间"><a href="#从Web解析到网络空间" class="headerlink" title="从Web解析到网络空间"></a>从Web解析到网络空间</h1><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><p>（如何爬下来）</p><p><strong>Requests</strong></p><ul><li>提供了简单易用的类HTTP协议网络爬虫功能</li><li>支持连接池、SSL、Cookies、HTTP(S)代理等</li><li>Python最主要的页面级网络爬虫功能库</li></ul><p><strong>Scrapy</strong>：优秀的网络爬虫框架</p><ul><li>提供了构建网络爬虫系统的框架功能</li><li>框架可理解为功能半成品，很多基础功能已完成，只需要用户进行扩展开发或者额外配置</li><li>支持批量和定时网页爬取、提供数据处理流程等</li><li>Python最主要且最专业的网络爬虫框架</li></ul><p><strong>pyspider</strong>：</p><ul><li>提供完整的网页爬取系统构建功能</li><li>支持数据库后端、消息队列、优先级、分布式架构等</li><li>Python重要的网络爬虫类第三方库</li></ul><h2 id="Web-信息提取"><a href="#Web-信息提取" class="headerlink" title="Web 信息提取"></a>Web 信息提取</h2><p>（爬下来后如何解析html和xml等内容）</p><p><strong>Beautiful Soup</strong>：HTML和XML的解析库</p><ul><li>又名beautifulsoup4或bs4，可以加载多种解析引擎</li><li>常与网络爬虫库搭配使用，如Scrapy、request等</li><li>将HTML页面以树形结构进行组织，通过下行、上行、平行遍历解析其中的内容</li></ul><p><strong>Re</strong>：正则表达式解析和处理功能库</p><ul><li>提供了定义和解析正则表达式的一批通用功能</li><li>可用于各类场景，包括定点的Web信息提取</li><li>Python主要标准库之一</li></ul><p><strong>Python-Goose</strong>：提取文章类型Web页面的功能库</p><ul><li>提供了对Web页面中文章信息&#x2F;视频等元数据的提取功能</li><li>针对特定类型Web页面，应用覆盖面较广</li><li>Python最主要的Web信息提取库</li></ul><h2 id="Web-网站开发"><a href="#Web-网站开发" class="headerlink" title="Web 网站开发"></a>Web 网站开发</h2><p><strong>Django</strong>：最流行的Web应用框架</p><ul><li>提供了构建Web系统的基本应用框架</li><li>MTV模式：模型（model）、模板（Template）、视图（Views）</li><li>Python最重要的Web应用框架，略微复杂，适合比较专业的网站构建</li></ul><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/python-web.png" alt="python-web"></p><p><strong>Pyramid</strong>：规模适中的Web应用框架</p><ul><li>提供了简单方便构建Web系统的应用框架</li><li>规模适中，适合快速构建并适度扩展类应用</li><li>Python产品级Web应用框架，起步简单可扩展性好</li></ul><p><strong>Flask</strong>：Web应用开发微框架</p><ul><li>提供了最简单构建Web系统的应用框架</li><li>特点是：简单、规模小、快速</li><li>Django &gt; Pyramid &gt; Flask</li></ul><h2 id="网络应用开发"><a href="#网络应用开发" class="headerlink" title="网络应用开发"></a>网络应用开发</h2><p><strong>WeRoBot</strong>：微信公众号开发框架</p><ul><li>提供了解析微信服务器消息及反馈消息的功能</li><li>建立微信机器人的重要技术手段</li></ul><p><strong>aip</strong>：百度AI开放平台接口</p><ul><li>提供了访问百度AI服务的Python功能接口</li><li>语音、人脸、OCR、NLP、知识图谱、图像搜索等领域</li><li>Python百度AI应用的最主要方式</li></ul><p><strong>MyQR</strong>：二维码生成第三方库</p><ul><li>提供了生成二维码的系列功能</li><li>基本二维码、艺术二维码和动态二维码</li></ul><h1 id="从人机交互到艺术设计"><a href="#从人机交互到艺术设计" class="headerlink" title="从人机交互到艺术设计"></a>从人机交互到艺术设计</h1><h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><p><strong>PyQt5</strong>：Qt开发框架的Python接口</p><ul><li>提供了创建Qt5程序的Python API接口</li><li>Qt是非常成熟的跨平台桌面应用开发系统，完备GUI</li><li>推荐的Python GUI开发第三方库</li></ul><p><strong>wxPython</strong>：跨平台GUI开发框架</p><ul><li>提供了专用于Python的跨平台GUI开发框架</li><li>理解数据类型与索引的关系，操作索引即操作数据</li><li>Python最主要的数据分析功能库，基于Numpy开发</li></ul><p><strong>PyGObject</strong>：使用GTK+开发GUI的功能库</p><ul><li>提供了整合GTK+、WebKitGTK+等库的功能</li><li>GTK+：跨平台的一种用户图形界面GUI框架</li><li>实例：Anaconda采用该库开发GUI</li></ul><h2 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h2><p><strong>PyGame</strong>：简单的游戏开发功能库</p><ul><li>提供了基于SDL的简单游戏开发功能及实现引擎</li><li>理解游戏对外部输入的响应机制及角色构建和交互机制</li><li>Python游戏入门最主要的第三方库</li></ul><p><strong>Panda3D</strong>：开源、跨平台的3D渲染和游戏开发库</p><ul><li>一个3D游戏引擎，提供Python和C++接口</li><li>支持很多先进特性：法线贴图、光泽贴图、卡通渲染等</li><li>由迪士尼和卡尼吉梅隆大学共同开发</li></ul><p><strong>cocos2d</strong>：构建2D游戏和图形界面交互式应用的框架</p><ul><li>提供了基于OpenGL的游戏开发图形渲染功能</li><li>支持GPU加速，采用树形结构分层管理游戏对象类型</li><li>适用于2D专业级游戏开发</li></ul><h2 id="虚拟现实"><a href="#虚拟现实" class="headerlink" title="虚拟现实"></a>虚拟现实</h2><p><strong>VR Zero</strong>：在树莓派上开发VR应用的Python库</p><ul><li>提供大量与VR开发相关的功能</li><li>针对树莓派的VR开发库，支持设备小型化，配置简单化</li><li>适合初学者实践VR开发及应用</li></ul><p><strong>pyovr</strong>：Oculus Rift的Python开发接口</p><ul><li>针对Oculus VR设备的Python开发库</li><li>基于成熟的VR设备，提供全套文档，工业级应用设备</li><li>Python+虚拟现实领域探索的一种思路</li></ul><p><strong>Vizard</strong>：基于Python的通用VR开发引擎</p><ul><li>专业的企业级虚拟现实开发引擎</li><li>提供详细的官方文档</li><li>支持多种主流的VR硬件设备，具有一定通用性</li></ul><h2 id="图形艺术"><a href="#图形艺术" class="headerlink" title="图形艺术"></a>图形艺术</h2><p><strong>Quads</strong>：迭代的艺术</p><ul><li>对图片进行四分迭代，形成像素风</li><li>可以生成动图或静图图像</li><li>简单易用，具有很高的展示度</li></ul><p><strong>ascii_art</strong>：ASCII艺术库</p><ul><li>将普通图片转为ASCII艺术风格</li><li>输出可以是纯文本或彩色文本</li><li>可采用图片格式输出</li></ul><p><strong>turtle</strong>：海龟绘图体系</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github + hexo 搭建博客过程</title>
    <link href="/2022/12/26/neo-first-blog/"/>
    <url>/2022/12/26/neo-first-blog/</url>
    
    <content type="html"><![CDATA[<p>我是neo，何梓猪的neo，这是我使用hexo搭建的博客~</p><p>这是我的第一篇博客，我想顺便用来记录我的搭建过程。</p><span id="more"></span><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h3><ul><li><p>Node.js（LTS长期支持版）：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><ul><li>安装后包含两个组件：node 和 npm（包管理器）</li></ul></li><li><p>git</p></li></ul><h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><h3 id="1-3-安装国内镜像源-cnpm"><a href="#1-3-安装国内镜像源-cnpm" class="headerlink" title="1.3 安装国内镜像源 cnpm"></a>1.3 安装国内镜像源 cnpm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org # -g：global 全局安装 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证，查看版本号</span> <br>cnpm -v<br></code></pre></td></tr></table></figure><h3 id="1-4-安装-hexo-框架"><a href="#1-4-安装-hexo-框架" class="headerlink" title="1.4 安装 hexo 框架"></a>1.4 安装 hexo 框架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli # -g：全局安装<br></code></pre></td></tr></table></figure><h2 id="二、博客-初始化与启动"><a href="#二、博客-初始化与启动" class="headerlink" title="二、博客 初始化与启动"></a>二、博客 初始化与启动</h2><h3 id="2-1-hexo-init-初始化博客"><a href="#2-1-hexo-init-初始化博客" class="headerlink" title="2.1 hexo init 初始化博客"></a>2.1 hexo init 初始化博客</h3><ol><li>新建一个存放博客资源的目录 blog</li><li>进入上述的 blog 目录，使用初始化命令：<code>hexo init</code></li></ol><p>初始化后，目录中生成了以下文件：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/blog_dir.png" alt="blog_dir"></p><h3 id="2-2-hexo-s-启动博客"><a href="#2-2-hexo-s-启动博客" class="headerlink" title="2.2 hexo s 启动博客"></a>2.2 hexo s 启动博客</h3><p>使用启动命令 <code>hexo s</code> 或者 <code>hexo server</code> 启动并预览博客。</p><p>启动后在本地的<code>4000</code>端口访问：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">D:\blog&gt;hexo s<br><span class="hljs-keyword">INFO</span> Validating config<br><span class="hljs-keyword">INFO</span> <span class="hljs-keyword">Start</span> processing<br><span class="hljs-keyword">INFO</span> Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span>/. Press Ctr1+C <span class="hljs-keyword">to</span> stop.<br></code></pre></td></tr></table></figure><h2 id="三、博客-新建与发布"><a href="#三、博客-新建与发布" class="headerlink" title="三、博客 新建与发布"></a>三、博客 新建与发布</h2><h3 id="3-1-hexo-n-新建博文"><a href="#3-1-hexo-n-新建博文" class="headerlink" title="3.1 hexo n 新建博文"></a>3.1 hexo n 新建博文</h3><p>使用 <code>hexo n</code> 或 <code>hexo new</code> 新建一篇博客文章：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&#x27;neo-first-blog&#x27;</span><br></code></pre></td></tr></table></figure><p>可见，在<code>\blog\source\_posts\</code>目录下生成了一个 <code>.markdown</code> 格式的文件。</p><p>然后就可以通过编辑该<code>.md</code>文件编辑博客内容。</p><h3 id="3-2-hexo-clean-清除缓存"><a href="#3-2-hexo-clean-清除缓存" class="headerlink" title="3.2 hexo clean 清除缓存"></a>3.2 hexo clean 清除缓存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件<code>db.json</code>和已生成的静态文件<code>public</code>。</p><p>网站显示异常时可以执行这条命令试试。</p><h3 id="3-3-hexo-g-生成"><a href="#3-3-hexo-g-生成" class="headerlink" title="3.3 hexo g 生成"></a>3.3 hexo g 生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g # generate<br></code></pre></td></tr></table></figure><p>生成网站静态文件到默认设置的<code>public</code>文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令。</li></ul><h2 id="四、部署到远端仓库"><a href="#四、部署到远端仓库" class="headerlink" title="四、部署到远端仓库"></a>四、部署到远端仓库</h2><h3 id="4-1-新建仓库"><a href="#4-1-新建仓库" class="headerlink" title="4.1 新建仓库"></a>4.1 新建仓库</h3><p>仓库名必须遵循指定格式：<code>owner.github.io</code>，如：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/repo.png" alt="repo"></p><h3 id="4-2-安装git部署插件"><a href="#4-2-安装git部署插件" class="headerlink" title="4.2 安装git部署插件"></a>4.2 安装git部署插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="4-3-添加配置"><a href="#4-3-添加配置" class="headerlink" title="4.3 添加配置"></a>4.3 添加配置</h3><p>打开本地<code>/blog/_config.yml</code>配置文件，在底部添加配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Deployment</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span><br>deploy:<br>  type: git<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">你的仓库地址</span><br>  repo: git@github.com:boxpiggy/boxpiggy.github.io.git<br>  branch: main<br></code></pre></td></tr></table></figure><h3 id="4-4-部署到远程仓库"><a href="#4-4-部署到远程仓库" class="headerlink" title="4.4 部署到远程仓库"></a>4.4 部署到远程仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d  # deploy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>hexo clean     # 清除缓存<br>hexo generate  # 生成静态文件<br>hexo deploy    # 部署到Github<br></code></pre></td></tr></table></figure><p>自动生成网站静态文件，并部署到设定的仓库。</p><p>需要输入目标仓库的用户名（boxpiggy）和密码（***）</p><p>据说部署前要先配置git全局用户：git config –global user.name “xxx”; git config –global user.email</p><p>每次修改完配置都要保存，然后hexo clean &amp; </p><h2 id="五、自定义主题与插件"><a href="#五、自定义主题与插件" class="headerlink" title="五、自定义主题与插件"></a>五、自定义主题与插件</h2><p>Hexo具有很强的自定义能力，可以打开 Hexo的官网，顶栏上就有 Themes 和 Plugins 的入口。</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>首先需要去 Themes 页面找到一款心仪的主题（可以通过点击图片来访问主题的演示站点），然后点击主题的名称进入主题的 GitHub 页面。</p><p>可以通过<code>git clone</code>命令将其克隆至博客根目录下的<code>themes</code>文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">git clone https:<span class="hljs-comment">//github.com/&lt;username&gt;/&lt;reponame&gt;</span><br></code></pre></td></tr></table></figure><p>或者通过 GitHub 自带的下载，下载源码的<code>zip</code>包，将其解压缩至<code>themes</code>文件夹中。</p><p>详细安装流程查看主题的<code>README.MD</code></p><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><p>每个主题文件夹中，都有着自己的<code>_config.yml</code>，管理着这个主题的一些配置，因此如果想要切换主题，在下载下来后，一定要到文件夹中去查看<code>_config.yml</code>的配置，并进行自己的个性化修改。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>本人使用了 Fluid 主题，<a href="https://hexo.fluid-dev.com/docs/guide/">官方文档</a>。</p><p><strong>安装</strong>（hexo 5.0.0 以上版本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p><strong>指定主题：</strong>修改 _config.yml 站点配置文件中的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">theme: fluid<br></code></pre></td></tr></table></figure><p>清除缓存并本地预览：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hexo c &amp; hexo s<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/fluid.png" alt="fluid"></p><p>图片位于：<code>node_modules\hexo-theme-fluid\source\img\</code>目录下</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>而如果是插件，那么就与主题的安装大不相同了。先找到需要的插件，然后再进入到插件的 GitHub 页面，一般在 <code>README.md</code> 中都会详细介绍如何安装。</p><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="①-hexo部署到gitee后无样式问题"><a href="#①-hexo部署到gitee后无样式问题" class="headerlink" title="① hexo部署到gitee后无样式问题"></a>① hexo部署到gitee后无样式问题</h3><details class="lake-collapse"><summary id="u4ba7e748"><span class="ne-text">参考</span></summary><p id="u08f876ee" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="font-size: 14px"></span><a href="https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank" data-href="https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank" target="_blank" class="ne-link"><span class="ne-text">https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank</span></a></p></details><ol><li>修改 <code>_config.yml</code> 配置，添加 <code>url</code> 和 <code>root</code> 两个配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, ......</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://boxpiggy.gitee.io/kingshit</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/kingshit/</span><br></code></pre></td></tr></table></figure><p><code>url</code> 为 Gitee Pages 上的网址</p><p><code>root </code> 为”仓库名”</p><ol start="2"><li>最后更新 Gitee Pages</li></ol><hr><p><strong>参考教程</strong></p><p><a href="https://www.cnblogs.com/visugar/p/6821777.html">https://www.cnblogs.com/visugar/p/6821777.html</a></p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p><p><a href="https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg">https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg</a></p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&vd_source=8a4e439fa8e8c5283477bc164e9a7126">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=8a4e439fa8e8c5283477bc164e9a7126</a></p><p><a href="https://sspai.com/post/59337">https://sspai.com/post/59337</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数据类型</title>
    <link href="/2022/05/25/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/05/25/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li><p>6 种数字类型：</p></li><li><ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li><p>1 种字符类型：<code>char</code></p></li><li><p>1 种布尔型：<code>boolean</code></p></li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th>类型</th><th>占用存储空间</th><th>默认值</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>byte</td><td>1byte</td><td>0</td><td>-27-128</td><td>27 - 1127</td></tr><tr><td>short</td><td>2byte</td><td>0</td><td>-215-32768</td><td>215 - 132767</td></tr><tr><td>int</td><td>4byte</td><td>0</td><td>-231-2147483648</td><td>231 - 12147483647</td></tr><tr><td>long</td><td>8byte</td><td>0L</td><td>-263……</td><td>263 - 1……</td></tr><tr><td>float</td><td>4byte</td><td>0.0f</td><td>-1.4E-45 -3.403E38</td><td>3.4028235E38</td></tr><tr><td>double</td><td>8byte</td><td>0.0d</td><td>-1.798E308</td><td>1.7976931348623157E308</td></tr><tr><td>char</td><td>2byte</td><td>‘u0000’</td><td>0 \u0000</td><td>65535（216- 1）\uffff</td></tr><tr><td>boolean</td><td>1bit</td><td>false</td><td>false</td><td>true</td></tr></tbody></table><p>像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都 <strong>-1</strong> 了。这是为什么呢？</p><p>这是因为在<strong>二进制补码表示法</strong>中，<strong>最高位是用来表示符号的</strong>（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。</p><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。</p><h2 id="整型-byte、short、int、long"><a href="#整型-byte、short、int、long" class="headerlink" title="整型 - byte、short、int、long"></a>整型 - byte、short、int、long</h2><p><code>byte</code>：字节（1byte）：8位、有符号的，以二进制补码表示的整数</p><p><code>short</code>：短整型（2byte）：16 位、有符号的，以二进制补码表示的整数</p><p><code>int</code>：整型（4byte）：32位、有符号的，以二进制补码表示的整数</p><p><code>long</code>：长整型（8byte）：64 位、有符号的，以二进制补码表示的整数</p><h3 id="整型的使用细节"><a href="#整型的使用细节" class="headerlink" title="整型的使用细节"></a>整型的使用细节</h3><ol><li>Java 的整型常量默认为 <code>int</code> 型，声明 long 型常量须在后加<code>l</code>或<code>L</code>；</li><li>Java 程序中变量声常明为 <code>int</code> 型，除非不足以表示大数，才使用 <code>long</code>；</li><li><code>bit</code>: 计算机中的最小存储单位。 <code>byte</code>: 计算机中基本存储单元，<code>1byte = 8bit</code>。</li></ol><h2 id="浮点型-float、double"><a href="#浮点型-float、double" class="headerlink" title="浮点型 - float、double"></a>浮点型 - float、double</h2><p><code>float</code>：4byte：单精度、32位、符合IEEE 754 标准的浮点数</p><p><code>double</code>：8byte：双精度、64 位、符合 IEEE 754 标准的浮点数</p><h3 id="浮点型使用细节"><a href="#浮点型使用细节" class="headerlink" title="浮点型使用细节"></a>浮点型使用细节</h3><ol><li>浮点数在机器中存放形式，浮点数 &#x3D; 符号位 + 指数位 + 尾数位</li><li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li><li>浮点数默认为<code>double</code>类型，声明<code>float</code>型须在后面加上<code>f</code>或<code>F</code>。（数值加<code>d</code>表示<code>double</code>类型）</li><li>浮点数有两种表示形式：</li></ol><ul><li><ul><li>十进制数形式：如5.12 512.0f .512</li><li>科学计数法形式：如5.12e2（5.12*10^2）</li><li>科学记数法：结尾的”E+数字”表示E之前的数字要乘以10的多少次方。比如，3.14E-3就是3.14 x 10-3 &#x3D;0.00314。</li></ul></li></ul><ol><li>通常使用<code>double</code>型，精度更高</li><li>比较浮点数的时候，不能使用“<code>==</code>”操作符。（计算机 内存存储浮点数使用IEEE754标准，存在精度问题，在存储计算过程中容易引起较小的舍入误差）</li></ol><ul><li><ul><li>使用Math.abs() 方法来计算两个浮点数之间差异的绝对值，如果这个差异在阈值范围之内，我们就认为两个浮点数是相等的。如：Math.abs(num1 - num2) &lt; 0.0001</li><li>使用 BigDecimal 类的 compareTo() 方法对两个数进行比较，该方法将会忽略小数点后的位数。见示例1。（比如说 2.0 和 2.00 的位数不同，但它俩的值是相等的）</li></ul></li></ul><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.0&quot;</span>);<br><br>System.out.println(a.equals(b));  <span class="hljs-comment">//false</span><br>System.out.println(a.compareTo(b) == <span class="hljs-number">0</span>);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="字符型-char"><a href="#字符型-char" class="headerlink" title="字符型 - char"></a>字符型 - char</h2><p><code>char</code>：2byte：单一的 16 位 Unicode 字符</p><h3 id="字符型使用细节"><a href="#字符型使用细节" class="headerlink" title="字符型使用细节"></a>字符型使用细节</h3><ol><li><code>char</code>用单引号<code>&#39; &#39;</code>，<code>String</code>字符串用双引号<code>&quot; &quot;</code></li><li>转义字符 ‘<code>\</code>‘ ，将其后的字符转变为特殊字符型常量。如：<code>char c = &#39;\n&#39;</code></li><li>Java 中，<code>char</code>本质是一个整数，输出时是 unicode 编码对应的字符（因此可直接赋值<code>char</code>一个整数）</li></ol><ul><li><ul><li>Unicode与中文之间的相互转换工具：<a href="https://www.w3cschool.cn/tools/index?name=unicode_chinese">在线Unicode&#x2F;中文转换工具 - 编码转换工具 - W3Cschool</a></li><li><a href="http://tool.chinaz.com/Tools/Unicode.aspx">Unicode编码转换 - 站长工具</a></li></ul></li></ul><ol><li>由3.可得，<code>char</code>类型可进行运算。</li><li>字符型存储到计算机中，需要找到字符对应的码值（整数），比如<code>&#39;a&#39;</code>：</li></ol><ul><li><ul><li>存储：<code>&#39;a&#39;</code> –&gt; 码值 97 –&gt; 二进制 0110 0001 –&gt; 存储</li></ul></li></ul><ol><li>字符编码表：</li></ol><ul><li><ul><li>- ASCII 编码表 1 个字节表示，一个128个字符（实际上一个字节可以表示256个字符，只用了128个）</li><li>Unicode 编码表 固定大小的编码，使用 2 个字节表示，字母和汉字统一占用 2 个字节（但这样浪费空间）。（Unicode兼容ASCII）</li><li>utf-8 编码表：大小可变的编码，使用1-6个字节表示一个符号，字母使用 1 个字节，汉字使用 3 个字节（实际开发用得最多）（Unicode的改进方式，互联网使用最广）</li><li>gbk 可以表示汉字，范围广，字母使用 1 个字节，汉字使用 2 个字节</li><li>gb2312 可以表示汉字，gb2312 &lt; gbk</li><li>big5 码，繁体中文，tw hk</li></ul></li></ul><h2 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型 - boolean"></a>布尔型 - boolean</h2><p><code>boolean</code>：1bit： 1 位，作为一种标志来记录 true&#x2F;false 情况</p><p>（准确讲是1byte，计算机处理数据的最小单位是 1 个字节）</p><p>事实上：boolean 占用多少字节取决于虚拟机本身的实现，《Java 虚拟机规范》提议：</p><ul><li>如果 boolean 是 “单独使用”：boolean 被编译为 int 类型，占 4 个字节</li><li>如果 boolean 是以 “boolean 数组” 的形式使用：boolean 占 1 个字节</li></ul><h3 id="布尔型细节"><a href="#布尔型细节" class="headerlink" title="布尔型细节"></a>布尔型细节</h3><ol><li>Java中不可以用 0 或者非 0 整数替代 false 和 true，这点和C、php等语言不同。</li></ol><h1 id="Java-类型转换"><a href="#Java-类型转换" class="headerlink" title="Java 类型转换"></a>Java 类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>自动类型转换：</strong>低精度数据类型 自动转换为 高精度数据类型：</p><ul><li>char –&gt; int –&gt; long –&gt; float –&gt; double</li><li>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</li></ul><p><strong>示例2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span>;  <span class="hljs-comment">//true char --&gt; int</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;  <span class="hljs-comment">//true int --&gt; double</span><br></code></pre></td></tr></table></figure><h3 id="自动类型转换细节"><a href="#自动类型转换细节" class="headerlink" title="自动类型转换细节"></a>自动类型转换细节</h3><ol><li>多种类型得数据混合运算时，系统自动将所有数据转换成精度（容量）最大的数据类型，然后再进行计算：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1.2</span>;  <span class="hljs-comment">//double 11.2</span><br></code></pre></td></tr></table></figure><ol><li>当把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错。</li><li>（<code>byte</code>, <code>short</code>） 和 <code>char</code> 之间不会相互自动转换。</li><li><code>byte</code>, <code>short</code>, <code>char</code> 三者可以计算，在计算时首先转换为 <code>**int**</code> 类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b1 + s;     <span class="hljs-comment">// √ 因为：b1 + s =&gt; int</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> b1 + b2;  <span class="hljs-comment">// × 因为：b1 + b3 =&gt; int</span><br></code></pre></td></tr></table></figure><ol><li>boolean 不参与转换</li><li>自动提升原则：表达式结果的类型自动提升为<strong>操作数中最大的类型</strong>。</li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。需要加上强制转换符()，但可能造成精度降低或溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(s + b);  <span class="hljs-comment">//由于(s+b)=&gt;int，因此要强制转换成short才不报错</span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型和String类型的转换"><a href="#基本数据类型和String类型的转换" class="headerlink" title="基本数据类型和String类型的转换"></a>基本数据类型和String类型的转换</h3><ol><li><strong>基本类型转String类型</strong></li></ol><p>方法：直接拼接个双引号””</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><ol><li><strong>String类型转基本类型</strong></li></ol><p>方法：通过基本类型的包装类调用<code>parseXX</code>方法即可（每一个基本类型都对应一个包装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;24&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br></code></pre></td></tr></table></figure><p><code>String</code>转换成<code>char</code> &#x3D;&#x3D;&gt; 得到字符串的第一个字符 （利用<code>charAt(n)</code>方法，将字符串的第<code>n</code>个字符取出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(s.charAt(<span class="hljs-number">0</span>))  <span class="hljs-comment">//s.charAt(0) 得到字符串s的第一个字符&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure><ol><li><strong>注意</strong></li></ol><ul><li>将<code>String</code>类型转成基本数据类型时，要确保<code>String</code>类型能够转成有效的数据，比如可以把<code>&quot;123&quot;</code>转成一个整数，但是不能把<code>&quot;shit&quot;</code>转成一个整数。</li><li>如果格式不正确，就会抛出异常，程序终止。</li></ul><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul><li>在进行基本的数据计算时，开发者可以直接使用基本数据类型。</li><li>但是当需要和Java其他对象结合使用，如存入集合中，就需要将基础数据类型实例封装为Java对象，</li><li>为了面向对象的这一特性，基本数据类型中的每一个类型在<code>java.lang</code>包中都有一个包装类，即将每个基本类型都包装成了一个类。八种基本类型对应包装类：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</li></ul><hr><table>    <tr>        <td>基本数据类型</td>        <td>包装类</td>        <td>接口</td>        <td>父类</td>        <td>接口</td>        <td>父类</td>    </tr>    <tr>        <td>boolean</td>        <td>Boolean</td>        <td rowspan="8">Comparable</td>        <td rowspan="2">—</td>        <td rowspan="8">Serializable</td>        <td rowspan="8">Object</td>    </tr>    <tr>        <td>char</td>        <td>Character</td>    </tr>    <tr>        <td>byte</td>        <td>Byte</td>        <td rowspan="6">Number</td>    </tr>    <tr>        <td>short</td>        <td>Short</td>    </tr>    <tr>        <td>int</td>        <td>Integer</td>    </tr>    <tr>        <td>long</td>        <td>Long</td>    </tr>    <tr>        <td>float</td>        <td>Float</td>    </tr>    <tr>        <td>double</td>        <td>Double</td>    </tr></table><h2 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h2><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中 [1]。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p>[1] 为什么说是<strong>几乎</strong>所有对象实例都存在于堆中呢？ </p><p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>更多参考：<a href="https://www.yuque.com/kingshit/java/khlmi9x1su7i6vr6">JIT逃逸分析</a></p><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 成员变量，存放在堆中</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">// 被 static 修饰，也存放在堆中，但属于类，不属于对象</span><br>    <span class="hljs-comment">// JDK1.7 静态变量从永久代移动了 Java 堆中</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 局部变量，存放在栈中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>; <span class="hljs-comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本数据类型和包装类转换"><a href="#基本数据类型和包装类转换" class="headerlink" title="基本数据类型和包装类转换"></a>基本数据类型和包装类转换</h2><ol><li>jdk5 前的手动装箱和拆箱方式。（装箱：基本类型 -&gt; 包装类型；拆箱：包装类型 -&gt; 基本类型）</li><li>jdk5 及以后的自动装箱和拆箱方式。</li><li>自动装箱底层调用的是<code>valueOf</code>方法，比如<code>Integer.valueOf()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer3</span> <span class="hljs-operator">=</span> n2;<br><span class="hljs-comment">//底层使用的是 Integer.valueOf(n2); </span><br><span class="hljs-comment">// valueOf本质是 当在 -128~127 时，直接返回；否则 new Integer(i); 详见</span><br><br><span class="hljs-comment">//自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> integer3;<br><span class="hljs-comment">//底层使用的是 integer2.intValue()，return integer3对象的value</span><br></code></pre></td></tr></table></figure><h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p><strong>装箱：</strong>将基本类型用它们对应的引用类型包装起来</p><p><strong>拆箱：</strong>将包装类型转换为基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱 等价于 Integer i = Integer.valueOf(10)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱 等价于 int n = i.intValue();</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><h2 id="浮点数运算的精度丢失风险"><a href="#浮点数运算的精度丢失风险" class="headerlink" title="浮点数运算的精度丢失风险"></a>浮点数运算的精度丢失风险</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.8f</span> - <span class="hljs-number">1.7f</span>;<br>System.out.println(a);  <span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);  <span class="hljs-comment">// 0.099999905</span><br>System.out.println(a == b);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>原因：</strong>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><p>更多内容详见：<a href="https://www.yuque.com/kingshit/wz61vk/yxked8f04twgtmnl">浮点数</a></p><h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到<strong>货币</strong>的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(c);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.2 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.20 */</span><br><span class="hljs-comment">// 比较内容，不是比较值</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* false */</span><br><span class="hljs-comment">// 比较值相等用compareTo，相等返回0</span><br>System.out.println(<span class="hljs-number">0</span> == x.compareTo(y)); <span class="hljs-comment">/* true */</span><br></code></pre></td></tr></table></figure><p>关于 <code>BigDecimal</code> 的详细介绍，参考：<a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a>。</p><h2 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h2><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><p>在 Java 中，64 位 long 整型是最大的整数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span><br>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h2 id="String类型和包装类转换"><a href="#String类型和包装类转换" class="headerlink" title="String类型和包装类转换"></a>String类型和包装类转换</h2><p>包装类（Integer 为例） -&gt; String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//方式一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;  <br><span class="hljs-comment">//底层创建一个基于i对象的值的String对象，i对象的类型并没有改变</span><br><br><span class="hljs-comment">//方式二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> i.toString();  <span class="hljs-comment">//</span><br><br><span class="hljs-comment">//方式三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> String.valueOf(i);  <br><span class="hljs-comment">//底层还是跟方式二一样调用toString： </span><br><span class="hljs-comment">// return (obj == null) ? &quot;null&quot; : obj.toString()</span><br></code></pre></td></tr></table></figure><p>String -&gt; 包装类（Integer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">//方式一：调用包装类的转换方法parseXxx()</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.parseInt(str);  <span class="hljs-comment">//底层：调用parseInt(s, 10); 参数radix:10表示输出十进制整数</span><br><br><span class="hljs-comment">//方式二：调用Integer构造器</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str);  <span class="hljs-comment">//底层还是跟方式一一样：this.value = parseInt(s, 10); </span><br></code></pre></td></tr></table></figure><h2 id="包装类缓存机制"><a href="#包装类缓存机制" class="headerlink" title="包装类缓存机制"></a>包装类缓存机制</h2><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128, 127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0, 127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p><strong>所有整型包装类对象之间值的比较，全部使用</strong> <code>**equals**</code> <strong>方法比较。</strong></p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    System.out.println(i1 == j2);  <span class="hljs-comment">// false  new出来的是不同的对象</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 底层调用valueOf方法，当传入参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 等价于 Integer i4 = Integer.valueOf(127)</span><br>    System.out.println(i3 == i4);  <span class="hljs-comment">// true</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 底层调用valueOf方法，当传入参数不在 -128~127 范围时，直接创建新对象。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i6</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 同上</span><br>    System.out.println(i5 == i6);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i7</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// 从数组里面取值，属于数组对象</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);  <span class="hljs-comment">// new出来的新对象</span><br>    System.out.println(i7 == i8);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i9</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// Integer对象</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i10</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;                  <span class="hljs-comment">// 基本数据类型</span><br>    System.out.println(i9 == i10);  <span class="hljs-comment">// true  只要有基本数据类型，就是判断值是否相等!!!</span><br><br>    <span class="hljs-comment">// 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。</span><br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br>    <br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i13</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i14</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>valueOf()</code>源码：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/valueOf%E6%BA%90%E7%A0%81.png" alt="valueOf源码"></p><p><strong>解读：</strong></p><ul><li>当传入的参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</li><li>当传入的参数不在 -128~127 范围时，直接创建新对象。</li></ul><p><code>**IntegerCache.cache**</code><strong>数组（部分）</strong>：</p><p>该数组由包装类<code>Integer</code>创建，大小为 256，存储了 -128~127</p><p><strong>Character</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">isDigit</span><span class="hljs-params">()</span></span>`方法：确定指定的字符是否为数字，返回`boolean<br></code></pre></td></tr></table></figure><p>示例：判断字符串是否都为数字组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断一个字符串是否都为数字组成</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span> ( !(Character.isDigit(str.charAt(i))) ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础概念</title>
    <link href="/2022/05/24/Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/05/24/Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE-EE-ME"><a href="#Java-SE-EE-ME" class="headerlink" title="Java SE EE ME"></a>Java SE EE ME</h1><p>Java SE 就是标准版，包含标准的 JVM 和标准库</p><p>Java EE 是企业版，它只是在 Java SE 的基础上加上了大量的 API 和库，以便方便开发 Web 应用、数据库、消息服务等。</p><p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Java%E7%89%88%E6%9C%AC.png" alt="Java版本"></p><h1 id="JVM-amp-JDK-amp-JRE"><a href="#JVM-amp-JDK-amp-JRE" class="headerlink" title="JVM &amp; JDK &amp; JRE"></a>JVM &amp; JDK &amp; JRE</h1><p><strong>JVM（Java Virtual Machine, Java 虚拟机）</strong>并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p>维基百科上就有常见 JVM 的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">Comparison of Java virtual machinesopen in new window</a> ，感兴趣的可以去看看。并且，你可以在 <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specificationsopen in new window</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JVM%E6%A8%A1%E5%9E%8B.png" alt="JVM模型"></p><p><strong>JDK（Java Development Kit）</strong>是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，还包含了 javac（编译 java 源码的编译器）以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p><p><strong>JRE（Java Runtime Environment）</strong>是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p><h2 id="JDK、JRE-和-JVM-的包含关系"><a href="#JDK、JRE-和-JVM-的包含关系" class="headerlink" title="JDK、JRE 和 JVM 的包含关系"></a>JDK、JRE 和 JVM 的包含关系</h2><p>JDK &#x3D; JRE + 开发工具集（例如 javac，java 编译工具等）</p><p>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）</p><p>如果只想运行开发好的<code>.class</code>文件，只需要 JRE。</p><p>但对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK.png" alt="JDK"></p><p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ <a href="http://openjdk.java.net/jeps/282">jlink</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。详见： <a href="https://javaguide.cn/java/new-features/java9.html">Java 9 新特性概览</a>。</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>官网：<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p><h2 id="配置环境变量path"><a href="#配置环境变量path" class="headerlink" title="配置环境变量path"></a>配置环境变量path</h2><ol><li>环境变量 - 系统变量 - 添加 JAVA_HOME 环境变量，指向 jdk 的安装目录 <code>D:\Program Files\jdk8\jdk1.8.0_333</code></li><li>编辑 path 环境变量，增加 <code>%JAVA_HOME%\bin</code></li><li>为了确保 jre（运行）在你使用 javaIDE 的时候不产生问题，新增配置 <code>%JAVA_HOME%\jre\bin</code></li></ol><p>windows 操作系统是如何搜索硬盘上某个命令？</p><ol><li>首先会从当前目录下搜索</li><li>当前目录搜索不到的话，会从环境变量path指定的路径当中搜索某个命令</li><li>如果都搜索不到，则报错</li></ol><h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><p>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><h1 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h1><ol><li>Java 源码本质上是一个文本文件，需要先用<code>javac</code>把 Xxx.java 编译成字节码文件 Xxx.class，然后，用<code>java</code>命令执行这个字节码文件</li><li>给虚拟机（JVM）传递的参数<code>Hello</code>是我们定义的类名，JVM 会启动<strong>类加载器（ClassLoader）</strong>，ClassLoader 会自动查找对应的 class 文件装载到 JVM 中执行。</li><li>JVM 将 Xxx.class 字节码文件解释成二进制数据。</li><li>操作系统执行二进制和底层硬件平台进行交互。</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C.png" alt="编译与运行"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol><li>编译阶段主要的任务是检查 Java 源程序是否符合Java语法</li><li>符合 Java 语法则生成正常的字节码文件（<code>xxx.class</code>）</li></ol><p>字节码文件中不是纯粹的二进制，这种文件无法在操作系统中直接执行。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac Hello.java<br></code></pre></td></tr></table></figure><ol><li>java 源文件，通过编译器编译成JVM可识别的字节码文件</li><li>通过<code>javac.exe</code>编译工具对<code>Hello.java</code>文件进行编译</li><li>若程序没错，则没有任何提示，并在源文件同目录出现一个<code>Hello.class</code>文件，该文件称为字节码文件，是可以执行的 java 程序</li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>java.exe</code>主要负责运行阶段</p><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java Hello<br></code></pre></td></tr></table></figure><ol><li>有了可执行的 java 程序（<code>.class</code>字节码文件）</li><li>通过运行工具<code>java.exe</code>对字节码文件进行执行，本质是<code>.class</code>装载到 JVM 执行</li></ol><p>注：dos控制台默认简体中文 GBK 编码，若源码有中文，则需要以 chinese 编码保存</p><h2 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h2><ol><li>Java应用程序的执行入口是main()方法。有固定书写格式：public static void main(String[] args){…}</li><li>Java语言严格区分大小写。</li><li>类首字母大写。</li><li>一个源文件中最多只有一个public类。其他类个数不限。[示例1]</li><li>如果源文件中包含一个public类，则文件名必须按该类名命名。</li><li>也可以将mian方法写在非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法。[示例1]</li></ol><p>示例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;yo my nigga!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编译后，每个类都对应一个.class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是皮蛋&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>&#125;<br># 编译 <span class="hljs-keyword">public</span> 类命名的文件<br>javac Hello.java <br><br># 运行里面的 Cat 类<br>java Cat <br></code></pre></td></tr></table></figure><p>在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p><p>　　1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。</p><p>　　2.public类的名称必须完全与含有该编译单元的文件名相同，包含大小写。如果不匹配，同样将得到编译错误。</p><p>　　3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。</p><p>一个编译单元（java文件）可以存在多个类，在编译时产生多个不同的<code>.class</code>文件， <code>.class</code>文件便是程序运行的数据来源。</p><p>java 将 public 类作为每个编译单元的数据接口，只能有一个，不然不能处理存在多个类的 java 文件。当一个编译单元（java文件）有多个非 public 类时，运行时需要对数据来源进行选择。</p><h2 id="Java-API文档"><a href="#Java-API文档" class="headerlink" title="Java API文档"></a>Java API文档</h2><p>API（Application Programming Interface）是Java提供的基本编程接口（java提供的类和相关方法）。中文在线文档：<a href="https://www.matools.com/">https://www.matools.com</a></p><h1 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h1><p>高级编程语言按照程序的执行方式分为两种：</p><ul><li>编译型：编译型语言open in new window 会通过编译器open in new window将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li><li>解释型：解释型语言open in new window会通过解释器open in new window一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li></ul><p><code>.class -&gt; 机器码</code>这一步：</p><ul><li><strong>JVM 类加载器</strong>首先加载<code>.class</code>字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</li></ul><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 <strong>JIT（Just in Time Compilation） 编译器</strong>，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong>。</p><p>🌈 拓展：<a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">有关 JIT 的实现细节: JVM C1、C2 编译器</a></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B-%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AAJavaGuide.png" alt="Java程序转变为机器代码的过程-图片来自JavaGuide"></p><p>Java程序转变为机器代码的过程</p><p>HotSpot 采用了<strong>惰性评估（Lazy Evaluation）</strong>的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h1 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h1><h2 id="什么是AOT？"><a href="#什么是AOT？" class="headerlink" title="什么是AOT？"></a>什么是AOT？</h2><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><p>JIT 与 AOT 两者的关键指标对比：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/AOTvsJIT.png" alt="AOTvsJIT"></p><p>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p>提到 AOT 就不得不提 GraalVMopen in new window 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。感兴趣的同学，可以去看看 GraalVM 的<a href="https://www.graalvm.org/latest/docs/">官方文档</a>。如果觉得官方文档看着比较难理解的话，也可以找一些文章来看看，比如：</p><ul><li><a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">基于静态编译构建微服务应用</a></li><li><a href="https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/%E8%B5%B0%E5%90%91-native-%E5%8C%96springdubbo-aot-%E6%8A%80%E6%9C%AF%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/">走向 Native 化：Spring&amp;Dubbo AOT 技术示例与原理讲解</a></li></ul><h2 id="为什么不全部使用-AOT-呢？"><a href="#为什么不全部使用-AOT-呢？" class="headerlink" title="为什么不全部使用 AOT 呢？"></a>为什么不全部使用 AOT 呢？</h2><p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。</p><p>除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</p><p>举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h1 id="Oracle-JDK-vs-OpenJDK"><a href="#Oracle-JDK-vs-OpenJDK" class="headerlink" title="Oracle JDK vs OpenJDK"></a>Oracle JDK vs OpenJDK</h1><p>首先，2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。</p><p>其次，对于 Java 7 而言，OpenJDK 和 Oracle JDK 是十分接近的。 Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。</p><p>下面这段话摘自 Oracle 官方在 2012 年发表的一个博客：</p><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p><p>最后，简单总结一下 Oracle JDK 和 OpenJDK 的区别：</p><ul><li><strong>是否开源</strong>：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引起很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目：<a href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdkopen in new window</a> 。</li><li><strong>是否免费</strong>：Oracle JDK 会提供免费版本，但一般有时间限制。JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。</li><li><strong>功能性</strong>：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。</li><li><strong>稳定性</strong>：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。</li><li><strong>协议</strong>：Oracle JDK 使用 BCL&#x2F;OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ul><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类（详见Java API文档）</li><li>控制访问范围</li></ol><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ol><li>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package</li><li>import 指令位置放在 package 下面，在类定义前面，可以有多句且没有顺序要求</li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">package</span> com.rwj;  <br><span class="hljs-comment">// package关键字：表示打包</span><br><span class="hljs-comment">// com.rwj：表示包名</span><br><br><span class="hljs-comment">// 导入/引入</span><br><span class="hljs-keyword">import</span> java.util.Scanner;  <span class="hljs-comment">//表示只会引入java.util包下的Scanner类</span><br><span class="hljs-keyword">import</span> java.util.*;  <span class="hljs-comment">//表示将java.util包下的所有类都引入</span><br></code></pre></td></tr></table></figure><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>创建不同的目录&#x2F;文件夹来保存类文件。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>只能包含数字、字母、下划线、小圆点，不能用数字开头，不能是关键字或保留字</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.公司名.项目名.业务模块名<br></code></pre></td></tr></table></figure><p><code>com.sina.crm.user</code> &#x2F;&#x2F;用户模块</p><p><code>com.sina.crm.order</code> &#x2F;&#x2F;订单模块</p><p><code>com.sina.crm.utils</code> &#x2F;&#x2F;工具类</p><h2 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h2><p><code>java.lang.*</code>：lang 包是基本包，默认引入，不需要再手动引入</p><p><code>java.util.*</code>：util 包，系统提供的工具包，工具类，使用 Scanner</p><p><code>java.net.*</code>：网络包，网络开发</p><p><code>java.awt.*</code>：做 java 界面开发，GUI</p><hr><p>参考</p><p><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">Java基础常见面试题总结(上)</a></p><p><a href="https://liaoxuefeng.com/books/java/quick-start/history/index.html">Java历史 - Java教程 - 廖雪峰的官方网站</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
