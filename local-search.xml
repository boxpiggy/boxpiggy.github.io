<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python 访问数据库</title>
    <link href="/2023/10/17/Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/10/17/Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为<code>Connection</code>；</p><p>连接到数据库后，需要打开游标，称之为<code>Cursor</code>，通过<code>Cursor</code>执行 SQL 语句，然后，获得执行结果。</p><p>Python 定义了一套操作数据库的 API 接口，任何数据库要连接到 Python，只需要提供符合 Python 标准的数据库驱动即可。</p><h1 id="一、常用数据库"><a href="#一、常用数据库" class="headerlink" title="一、常用数据库"></a>一、常用数据库</h1><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 是一种嵌入式数据库，它的数据库就是一个文件。由于 SQLite 本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在 iOS 和 Android 的 App 中都可以集成。Python 就内置了 SQLite3。</p><h3 id="导入数据库模块"><a href="#导入数据库模块" class="headerlink" title="导入数据库模块"></a>导入数据库模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">import sqlite3<br></code></pre></td></tr></table></figure><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>在 python 中，使用 sqlite3 创建数据库的连接，当我们指定的数据库文件不存在的时候连接对象会自动创建数据库文件；如果数据库文件已经存在，则连接对象不会再创建数据库文件，而是直接打开该数据库文件。</p><p>连接对象可以是<strong>硬盘</strong>上面的数据库文件，也可以是建立在<strong>内存</strong>（memory）中的，在内存中的数据库执行完任何操作后，都不需要提交事务的(commit)</p><p><code>connect</code>方法返回<code>con</code>对象，即是数据库链接对象，它提供了以下方法：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.cursor()</td><td>创建一个游标对象</td></tr><tr><td>.commit()</td><td>处理事务提交</td></tr><tr><td>.rollback()</td><td>处理事务回滚</td></tr><tr><td>.close()</td><td>关闭一个数据库连接</td></tr></tbody></table><h4 id="在硬盘上建立数据库"><a href="#在硬盘上建立数据库" class="headerlink" title="在硬盘上建立数据库"></a>在硬盘上建立数据库</h4><ul><li>数据库的名称不区分大小写，且以第一次建立时的名字为准。</li><li>不加全路径时，数据库文件会自动建立在工程项目文件夹下。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">con=sqlite3.connect(<span class="hljs-string">&quot;D:\Test.db&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="在内存上建立数据库"><a href="#在内存上建立数据库" class="headerlink" title="在内存上建立数据库"></a>在内存上建立数据库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">con = sqlite3.connect(<span class="hljs-string">&quot;memory&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cur = con.cursor()<br></code></pre></td></tr></table></figure><p>游标对象有以下方法支持数据库操作：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.execute()</td><td>用来执行sql语句</td></tr><tr><td>.executemany()</td><td>用来执行多条sql语句</td></tr><tr><td>.close()</td><td>用来关闭游标</td></tr><tr><td>.fetchone()</td><td>用来从结果中取一条记录，并将游标指向下一条记录</td></tr><tr><td>.fetchmany()</td><td>用来从结果中取多条记录。</td></tr><tr><td>.fetchall()</td><td>用来从结果中取出所以记录。</td></tr><tr><td>.scroll()</td><td>用于游标滚动。</td></tr></tbody></table><p>注意：使用游标的方法返回的数据类型是列表。</p><h3 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h3><h3 id="事务提交或回滚"><a href="#事务提交或回滚" class="headerlink" title="事务提交或回滚"></a>事务提交或回滚</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提交</span><br>con.commit()<br><br><span class="hljs-comment"># 回滚</span><br>con.rollback()<br><br><span class="hljs-comment"># 关闭游标</span><br>cur.close()<br><span class="hljs-comment"># 关闭数据库连接</span><br>con.close()<br></code></pre></td></tr></table></figure><p>注意：一定要先关闭游标，再关闭数据库连接，否则会报错！</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>SQLite 的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用。而MySQL 是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于 SQLite。</p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>由于 MySQL 服务器以独立的进程运行，并通过网络对外服务，所以，需要支持 Python 的 MySQL 驱动来连接到 MySQL 服务器。</p><p>MySQL 官方提供了 mysql-connector-python 驱动，但是安装的时候需要给 <code>pip</code> 命令加上参数<code>--allow-external</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install mysql-connector-python --allow-external mysql-connector-python<br><span class="hljs-comment"># 如果上面的命令安装失败，可以试试另一个驱动：</span><br>pip install mysql-connector<br></code></pre></td></tr></table></figure><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 导入MySQL驱动:</span><br>&gt;&gt;&gt; import mysql.connector<br><br><span class="hljs-comment"># 注意把password设为你的root口令:</span><br>&gt;&gt;&gt; conn = mysql.connector.connect(user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&#x27;password&#x27;</span>, database=<span class="hljs-string">&#x27;test&#x27;</span>)<br>&gt;&gt;&gt; cursor = conn.cursor()<br><br><span class="hljs-comment"># 创建user表:</span><br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;</span>)<br><br><span class="hljs-comment"># 插入一行记录，注意MySQL的占位符是%s:</span><br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;insert into user (id, name) values (%s, %s)&#x27;</span>, [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>])<br>&gt;&gt;&gt; cursor.rowcount<br>1<br><br><span class="hljs-comment"># 提交事务:</span><br>&gt;&gt;&gt; conn.commit()<br>&gt;&gt;&gt; cursor.close()<br><br><span class="hljs-comment"># 运行查询:</span><br>&gt;&gt;&gt; cursor = conn.cursor()<br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;select * from user where id = %s&#x27;</span>, (<span class="hljs-string">&#x27;1&#x27;</span>,))<br>&gt;&gt;&gt; values = cursor.fetchall()<br>&gt;&gt;&gt; values<br>[(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>)]<br><br><span class="hljs-comment"># 关闭Cursor和Connection:</span><br>&gt;&gt;&gt; cursor.close()<br>True<br>&gt;&gt;&gt; conn.close()<br></code></pre></td></tr></table></figure><h1 id="二、使用-ORM-框架"><a href="#二、使用-ORM-框架" class="headerlink" title="二、使用 ORM 框架"></a>二、使用 ORM 框架</h1><h2 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>数据库表是一个二维表，包含多行多列。把一个表的内容用 Python 的数据结构表示出来的话，可以用一个<code>list</code>表示多行，<code>list</code>的每一个元素是 <code>tuple</code>，表示一行记录，比如，包含<code>id</code>和<code>name</code>的<code>use</code> 表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[<br>    (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>),<br>    (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>),<br>    (<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure><p>Python 的 DB-API 返回的数据结构就是像上面这样表示的。</p><p>但是用<code>tuple</code>表示一行很难看出表的结构。如果把一个<code>tuple</code>用 <code>class</code> 实例来表示，就可以更容易地看出表的结构来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br><br>[<br>    User(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>),<br>    User(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>),<br>    User(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure><p>这就是传说中的 ORM 技术：<strong>Object-Relational Mapping</strong>，把<strong>关系数据库的表结构映射到对象上</strong>。</p><p>但是由谁来做这个转换呢？</p><p>所以 ORM 框架应运而生。在 Python 中，最有名的 ORM 框架是 SQLAlchemy。我们来看看 SQLAlchemy 的用法。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install sqlalchemy<br></code></pre></td></tr></table></figure><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SQLAlchemy 的初始化和对象定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入:</span><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, String, create_engine<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker<br><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br><br><span class="hljs-comment"># 创建对象的基类:</span><br>Base = declarative_base()<br><br><span class="hljs-comment"># 定义User对象:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    <span class="hljs-comment"># 表的名字:</span><br>    __tablename__ = <span class="hljs-string">&#x27;user&#x27;</span><br><br>    <span class="hljs-comment"># 表的结构:</span><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br><br><span class="hljs-comment"># 初始化数据库连接:</span><br>engine = create_engine(<span class="hljs-string">&#x27;mysql+mysqlconnector://root:password@localhost:3306/test&#x27;</span>)<br><span class="hljs-comment"># 创建DBSession类型:</span><br>DBSession = sessionmaker(bind=engine)<br></code></pre></td></tr></table></figure><p>以上代码完成 SQLAlchemy 的初始化和具体每个表的class定义。</p><p>create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：</p><p>‘数据库类型+数据库驱动名称:&#x2F;&#x2F;用户名:口令@机器地址:端口号&#x2F;数据库名’</p><p>如果有多个表，就继续定义其他 class，例如 School：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;school&#x27;</span><br>    <span class="hljs-built_in">id</span> = ...<br>    name = ...<br></code></pre></td></tr></table></figure><h4 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h4><p>由于有了 ORM，我们向数据库表中添加一行记录，可以视为添加一个<code>User</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建session对象:</span><br>session = DBSession()<br><span class="hljs-comment"># 创建新User对象:</span><br>new_user = User(<span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;5&#x27;</span>, name=<span class="hljs-string">&#x27;Bob&#x27;</span>)<br><span class="hljs-comment"># 添加到session:</span><br>session.add(new_user)<br><span class="hljs-comment"># 提交即保存到数据库:</span><br>session.commit()<br><span class="hljs-comment"># 关闭session:</span><br>session.close()<br></code></pre></td></tr></table></figure><p>可见，关键是获取<code>session</code>，然后把对象添加到<code>session</code>，最后提交并关闭。</p><p><code>DBSession</code> 对象可视为当前数据库连接。</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>有了ORM，查询出来的可以不再是<code>tuple</code>，而是<code>User</code>对象。SQLAlchemy 提供的查询接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建Session:</span><br>session = DBSession()<br><span class="hljs-comment"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:</span><br>user = session.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span>==<span class="hljs-string">&#x27;5&#x27;</span>).one()<br><span class="hljs-comment"># 打印类型和对象的name属性:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;type:&#x27;</span>, <span class="hljs-built_in">type</span>(user))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, user.name)<br><span class="hljs-comment"># 关闭Session:</span><br>session.close()<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.User&#x27;</span>&gt;<br>name: Bob<br></code></pre></td></tr></table></figure><h4 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h4><p>由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM 框架也可以提供两个对象之间的一对多、多对多等功能。</p><p>例如，如果一个<code>User</code>拥有多个<code>Book</code>，就可以定义一对多关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;user&#x27;</span><br><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br>    <span class="hljs-comment"># 一对多:</span><br>    books = relationship(<span class="hljs-string">&#x27;Book&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;book&#x27;</span><br><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br>    <span class="hljs-comment"># “多”的一方的book表是通过外键关联到user表的:</span><br>    user_id = Column(String(<span class="hljs-number">20</span>), ForeignKey(<span class="hljs-string">&#x27;user.id&#x27;</span>))<br></code></pre></td></tr></table></figure><p>当我们查询一个<code>User</code>对象时，该对象的<code>books</code>属性将返回一个包含若干个<code>Book</code>对象的<code>list</code>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="executemany"><a href="#executemany" class="headerlink" title="executemany()"></a>executemany()</h4><p>在<code>executemany()</code>方法中，参数列表需要是一个可迭代对象，并且每个元素都需要是一个序列（例如列表、元组等）。这是为了支持批量执行多次操作。</p><p>为了满足<code>executemany()</code>方法的要求，需要将每个参数以元组形式传递，即使是只有一个值的情况也不例外。这样可以确保参数列表与 SQL 语句中占位符的数量和顺序相匹配，从而正确地执行批量操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 计算生态</title>
    <link href="/2023/08/18/Python-%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81/"/>
    <url>/2023/08/18/Python-%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><p>PyPEF2：处理pdf文件的工具集</p><p>支持获取信息、分隔&#x2F;整合文件、加密解密等</p><p>完全Python语言实现，不需要额外依赖，功能稳定</p><p>NLTK：自然语言文本处理第三方库</p><p>支持语言文本分类、标记、语法句法、语义解析等</p><p>最好的Python自然语言处理库</p><p>Python-docx：创建或更新Microsoft Word文件的第三方库</p><p>提供创建或更新.doc .docx等文件的计算功能</p><p>增加并配置段落、图片、表格、文字等，功能全面</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p><strong>Numpy</strong>：表达N维数组的最基础库</p><ul><li>C语言实现，对外接口是python语言，计算速度优异</li><li>数据分析及科学计算的基础库</li><li>提供直接的矩阵运算、广播函数、线性代数等功能</li><li>Numpy最基础单元是一个数组，数组是一个变量</li></ul><p><strong>Pandas</strong>：Python数据分析高层次应用库</p><ul><li><p>操作索引即操作数据</p></li><li><p>Python最主要的数据分析功能库，基于Numpy开发</p></li><li><p>Pandas核心提供两个数据结构：</p></li><li><ul><li>Series &#x3D; 索引 + 一维数据</li><li>DataFrame &#x3D; 行列索引 + 二维数据</li></ul></li></ul><p>Pandas 库通过扩展了对一维和二维数据的表示，因而能够形成更高层次对数据的操作，简化数据分析的运行</p><p><strong>SciPy</strong>：数学、科学和工程计算功能库</p><ul><li>提供一批数学算法及工程数据运算功能</li><li>雷系Matlab，可用于如傅里叶变换、信号处理等应用</li><li>Python最主要的科学计算功能库，基于Numpy开发</li></ul><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p><strong>Matplotlib</strong>：高质量的二维数据可视化功能库</p><ul><li>通过 matplotlib.pyplot 子库调用各可视化效果（把所有有效的可视化展示方法汇集到一个子库中，相当于各个子库的快捷方式）</li><li>Python最主要的数据可视化功能库，基于Numpy开发</li></ul><p><strong>Seaborn</strong>：统计类数据可视化功能库</p><ul><li>提供了一批高层次统计类数据可视化展示效果</li><li>主要展示数据间分布、分类和线性关系等内容</li><li>基于Matplotlib开发，支持Numpy和Pandas</li></ul><p><strong>Mayavi</strong>：三维科学数据可视化功能库</p><ul><li>提供了一批易用的3D科学计算数据可视化展示效果</li><li>目前版本是Mayavi2，三维可视化最主要的第三方库</li><li>支持Numpy、TVTK、Traits、Envisage等第三方库</li></ul><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p><strong>Scikit-learn</strong>：机器学习方法工具集</p><ul><li>提供聚类、分类、回归、强化学习等计算功能</li><li>机器学习最基本且最优秀的Python第三方库</li></ul><p><strong>TensorFlow</strong>：AlphaGo背后的机器学习计算框架</p><ul><li>谷歌公司推动的开源机器学习框架</li><li>将数据流图作为基础，图节点代表运算，边代表张亮</li><li>应用机器学习方法的一种方式，支撑谷歌人工智能应用</li></ul><p>深度学习</p><p><strong>MXNet</strong>：基于神经网络的深度学习计算框架</p><ul><li>可用于自动驾驶、机器翻译、语音识别等众多领域</li><li>Python最重要的深度学习计算框架</li></ul><h1 id="从Web解析到网络空间"><a href="#从Web解析到网络空间" class="headerlink" title="从Web解析到网络空间"></a>从Web解析到网络空间</h1><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><p>（如何爬下来）</p><p><strong>Requests</strong></p><ul><li>提供了简单易用的类HTTP协议网络爬虫功能</li><li>支持连接池、SSL、Cookies、HTTP(S)代理等</li><li>Python最主要的页面级网络爬虫功能库</li></ul><p><strong>Scrapy</strong>：优秀的网络爬虫框架</p><ul><li>提供了构建网络爬虫系统的框架功能</li><li>框架可理解为功能半成品，很多基础功能已完成，只需要用户进行扩展开发或者额外配置</li><li>支持批量和定时网页爬取、提供数据处理流程等</li><li>Python最主要且最专业的网络爬虫框架</li></ul><p><strong>pyspider</strong>：</p><ul><li>提供完整的网页爬取系统构建功能</li><li>支持数据库后端、消息队列、优先级、分布式架构等</li><li>Python重要的网络爬虫类第三方库</li></ul><h2 id="Web-信息提取"><a href="#Web-信息提取" class="headerlink" title="Web 信息提取"></a>Web 信息提取</h2><p>（爬下来后如何解析html和xml等内容）</p><p><strong>Beautiful Soup</strong>：HTML和XML的解析库</p><ul><li>又名beautifulsoup4或bs4，可以加载多种解析引擎</li><li>常与网络爬虫库搭配使用，如Scrapy、request等</li><li>将HTML页面以树形结构进行组织，通过下行、上行、平行遍历解析其中的内容</li></ul><p><strong>Re</strong>：正则表达式解析和处理功能库</p><ul><li>提供了定义和解析正则表达式的一批通用功能</li><li>可用于各类场景，包括定点的Web信息提取</li><li>Python主要标准库之一</li></ul><p><strong>Python-Goose</strong>：提取文章类型Web页面的功能库</p><ul><li>提供了对Web页面中文章信息&#x2F;视频等元数据的提取功能</li><li>针对特定类型Web页面，应用覆盖面较广</li><li>Python最主要的Web信息提取库</li></ul><h2 id="Web-网站开发"><a href="#Web-网站开发" class="headerlink" title="Web 网站开发"></a>Web 网站开发</h2><p><strong>Django</strong>：最流行的Web应用框架</p><ul><li>提供了构建Web系统的基本应用框架</li><li>MTV模式：模型（model）、模板（Template）、视图（Views）</li><li>Python最重要的Web应用框架，略微复杂，适合比较专业的网站构建</li></ul><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/python-web.png" alt="python-web"></p><p><strong>Pyramid</strong>：规模适中的Web应用框架</p><ul><li>提供了简单方便构建Web系统的应用框架</li><li>规模适中，适合快速构建并适度扩展类应用</li><li>Python产品级Web应用框架，起步简单可扩展性好</li></ul><p><strong>Flask</strong>：Web应用开发微框架</p><ul><li>提供了最简单构建Web系统的应用框架</li><li>特点是：简单、规模小、快速</li><li>Django &gt; Pyramid &gt; Flask</li></ul><h2 id="网络应用开发"><a href="#网络应用开发" class="headerlink" title="网络应用开发"></a>网络应用开发</h2><p><strong>WeRoBot</strong>：微信公众号开发框架</p><ul><li>提供了解析微信服务器消息及反馈消息的功能</li><li>建立微信机器人的重要技术手段</li></ul><p><strong>aip</strong>：百度AI开放平台接口</p><ul><li>提供了访问百度AI服务的Python功能接口</li><li>语音、人脸、OCR、NLP、知识图谱、图像搜索等领域</li><li>Python百度AI应用的最主要方式</li></ul><p><strong>MyQR</strong>：二维码生成第三方库</p><ul><li>提供了生成二维码的系列功能</li><li>基本二维码、艺术二维码和动态二维码</li></ul><h1 id="从人机交互到艺术设计"><a href="#从人机交互到艺术设计" class="headerlink" title="从人机交互到艺术设计"></a>从人机交互到艺术设计</h1><h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><p><strong>PyQt5</strong>：Qt开发框架的Python接口</p><ul><li>提供了创建Qt5程序的Python API接口</li><li>Qt是非常成熟的跨平台桌面应用开发系统，完备GUI</li><li>推荐的Python GUI开发第三方库</li></ul><p><strong>wxPython</strong>：跨平台GUI开发框架</p><ul><li>提供了专用于Python的跨平台GUI开发框架</li><li>理解数据类型与索引的关系，操作索引即操作数据</li><li>Python最主要的数据分析功能库，基于Numpy开发</li></ul><p><strong>PyGObject</strong>：使用GTK+开发GUI的功能库</p><ul><li>提供了整合GTK+、WebKitGTK+等库的功能</li><li>GTK+：跨平台的一种用户图形界面GUI框架</li><li>实例：Anaconda采用该库开发GUI</li></ul><h2 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h2><p><strong>PyGame</strong>：简单的游戏开发功能库</p><ul><li>提供了基于SDL的简单游戏开发功能及实现引擎</li><li>理解游戏对外部输入的响应机制及角色构建和交互机制</li><li>Python游戏入门最主要的第三方库</li></ul><p><strong>Panda3D</strong>：开源、跨平台的3D渲染和游戏开发库</p><ul><li>一个3D游戏引擎，提供Python和C++接口</li><li>支持很多先进特性：法线贴图、光泽贴图、卡通渲染等</li><li>由迪士尼和卡尼吉梅隆大学共同开发</li></ul><p><strong>cocos2d</strong>：构建2D游戏和图形界面交互式应用的框架</p><ul><li>提供了基于OpenGL的游戏开发图形渲染功能</li><li>支持GPU加速，采用树形结构分层管理游戏对象类型</li><li>适用于2D专业级游戏开发</li></ul><h2 id="虚拟现实"><a href="#虚拟现实" class="headerlink" title="虚拟现实"></a>虚拟现实</h2><p><strong>VR Zero</strong>：在树莓派上开发VR应用的Python库</p><ul><li>提供大量与VR开发相关的功能</li><li>针对树莓派的VR开发库，支持设备小型化，配置简单化</li><li>适合初学者实践VR开发及应用</li></ul><p><strong>pyovr</strong>：Oculus Rift的Python开发接口</p><ul><li>针对Oculus VR设备的Python开发库</li><li>基于成熟的VR设备，提供全套文档，工业级应用设备</li><li>Python+虚拟现实领域探索的一种思路</li></ul><p><strong>Vizard</strong>：基于Python的通用VR开发引擎</p><ul><li>专业的企业级虚拟现实开发引擎</li><li>提供详细的官方文档</li><li>支持多种主流的VR硬件设备，具有一定通用性</li></ul><h2 id="图形艺术"><a href="#图形艺术" class="headerlink" title="图形艺术"></a>图形艺术</h2><p><strong>Quads</strong>：迭代的艺术</p><ul><li>对图片进行四分迭代，形成像素风</li><li>可以生成动图或静图图像</li><li>简单易用，具有很高的展示度</li></ul><p><strong>ascii_art</strong>：ASCII艺术库</p><ul><li>将普通图片转为ASCII艺术风格</li><li>输出可以是纯文本或彩色文本</li><li>可采用图片格式输出</li></ul><p><strong>turtle</strong>：海龟绘图体系</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github + hexo 搭建博客过程</title>
    <link href="/2022/12/26/neo-first-blog/"/>
    <url>/2022/12/26/neo-first-blog/</url>
    
    <content type="html"><![CDATA[<p>我是neo，何梓猪的neo，这是我使用hexo搭建的博客~</p><p>这是我的第一篇博客，我想顺便用来记录我的搭建过程。</p><span id="more"></span><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h3><ul><li><p>Node.js（LTS长期支持版）：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><ul><li>安装后包含两个组件：node 和 npm（包管理器）</li></ul></li><li><p>git</p></li></ul><h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><h3 id="1-3-安装国内镜像源-cnpm"><a href="#1-3-安装国内镜像源-cnpm" class="headerlink" title="1.3 安装国内镜像源 cnpm"></a>1.3 安装国内镜像源 cnpm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org # -g：global 全局安装 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证，查看版本号</span> <br>cnpm -v<br></code></pre></td></tr></table></figure><h3 id="1-4-安装-hexo-框架"><a href="#1-4-安装-hexo-框架" class="headerlink" title="1.4 安装 hexo 框架"></a>1.4 安装 hexo 框架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli # -g：全局安装<br></code></pre></td></tr></table></figure><h2 id="二、博客-初始化与启动"><a href="#二、博客-初始化与启动" class="headerlink" title="二、博客 初始化与启动"></a>二、博客 初始化与启动</h2><h3 id="2-1-hexo-init-初始化博客"><a href="#2-1-hexo-init-初始化博客" class="headerlink" title="2.1 hexo init 初始化博客"></a>2.1 hexo init 初始化博客</h3><ol><li>新建一个存放博客资源的目录 blog</li><li>进入上述的 blog 目录，使用初始化命令：<code>hexo init</code></li></ol><p>初始化后，目录中生成了以下文件：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/blog_dir.png" alt="blog_dir"></p><h3 id="2-2-hexo-s-启动博客"><a href="#2-2-hexo-s-启动博客" class="headerlink" title="2.2 hexo s 启动博客"></a>2.2 hexo s 启动博客</h3><p>使用启动命令 <code>hexo s</code> 或者 <code>hexo server</code> 启动并预览博客。</p><p>启动后在本地的<code>4000</code>端口访问：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">D:\blog&gt;hexo s<br><span class="hljs-keyword">INFO</span> Validating config<br><span class="hljs-keyword">INFO</span> <span class="hljs-keyword">Start</span> processing<br><span class="hljs-keyword">INFO</span> Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span>/. Press Ctr1+C <span class="hljs-keyword">to</span> stop.<br></code></pre></td></tr></table></figure><h2 id="三、博客-新建与发布"><a href="#三、博客-新建与发布" class="headerlink" title="三、博客 新建与发布"></a>三、博客 新建与发布</h2><h3 id="3-1-hexo-n-新建博文"><a href="#3-1-hexo-n-新建博文" class="headerlink" title="3.1 hexo n 新建博文"></a>3.1 hexo n 新建博文</h3><p>使用 <code>hexo n</code> 或 <code>hexo new</code> 新建一篇博客文章：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&#x27;neo-first-blog&#x27;</span><br></code></pre></td></tr></table></figure><p>可见，在<code>\blog\source\_posts\</code>目录下生成了一个 <code>.markdown</code> 格式的文件。</p><p>然后就可以通过编辑该<code>.md</code>文件编辑博客内容。</p><h3 id="3-2-hexo-clean-清除缓存"><a href="#3-2-hexo-clean-清除缓存" class="headerlink" title="3.2 hexo clean 清除缓存"></a>3.2 hexo clean 清除缓存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件<code>db.json</code>和已生成的静态文件<code>public</code>。</p><p>网站显示异常时可以执行这条命令试试。</p><h3 id="3-3-hexo-g-生成"><a href="#3-3-hexo-g-生成" class="headerlink" title="3.3 hexo g 生成"></a>3.3 hexo g 生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g # generate<br></code></pre></td></tr></table></figure><p>生成网站静态文件到默认设置的<code>public</code>文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令。</li></ul><h2 id="四、部署到远端仓库"><a href="#四、部署到远端仓库" class="headerlink" title="四、部署到远端仓库"></a>四、部署到远端仓库</h2><h3 id="4-1-新建仓库"><a href="#4-1-新建仓库" class="headerlink" title="4.1 新建仓库"></a>4.1 新建仓库</h3><p>仓库名必须遵循指定格式：<code>owner.github.io</code>，如：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/repo.png" alt="repo"></p><h3 id="4-2-安装git部署插件"><a href="#4-2-安装git部署插件" class="headerlink" title="4.2 安装git部署插件"></a>4.2 安装git部署插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="4-3-添加配置"><a href="#4-3-添加配置" class="headerlink" title="4.3 添加配置"></a>4.3 添加配置</h3><p>打开本地<code>/blog/_config.yml</code>配置文件，在底部添加配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Deployment</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span><br>deploy:<br>  type: git<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">你的仓库地址</span><br>  repo: git@github.com:boxpiggy/boxpiggy.github.io.git<br>  branch: main<br></code></pre></td></tr></table></figure><h3 id="4-4-部署到远程仓库"><a href="#4-4-部署到远程仓库" class="headerlink" title="4.4 部署到远程仓库"></a>4.4 部署到远程仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d  # deploy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>hexo clean     # 清除缓存<br>hexo generate  # 生成静态文件<br>hexo deploy    # 部署到Github<br></code></pre></td></tr></table></figure><p>自动生成网站静态文件，并部署到设定的仓库。</p><p>需要输入目标仓库的用户名（boxpiggy）和密码（***）</p><p>据说部署前要先配置git全局用户：git config –global user.name “xxx”; git config –global user.email</p><p>每次修改完配置都要保存，然后hexo clean &amp; </p><h2 id="五、自定义主题与插件"><a href="#五、自定义主题与插件" class="headerlink" title="五、自定义主题与插件"></a>五、自定义主题与插件</h2><p>Hexo具有很强的自定义能力，可以打开 Hexo的官网，顶栏上就有 Themes 和 Plugins 的入口。</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>首先需要去 Themes 页面找到一款心仪的主题（可以通过点击图片来访问主题的演示站点），然后点击主题的名称进入主题的 GitHub 页面。</p><p>可以通过<code>git clone</code>命令将其克隆至博客根目录下的<code>themes</code>文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">git clone https:<span class="hljs-comment">//github.com/&lt;username&gt;/&lt;reponame&gt;</span><br></code></pre></td></tr></table></figure><p>或者通过 GitHub 自带的下载，下载源码的<code>zip</code>包，将其解压缩至<code>themes</code>文件夹中。</p><p>详细安装流程查看主题的<code>README.MD</code></p><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><p>每个主题文件夹中，都有着自己的<code>_config.yml</code>，管理着这个主题的一些配置，因此如果想要切换主题，在下载下来后，一定要到文件夹中去查看<code>_config.yml</code>的配置，并进行自己的个性化修改。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>本人使用了 Fluid 主题，<a href="https://hexo.fluid-dev.com/docs/guide/">官方文档</a>。</p><p><strong>安装</strong>（hexo 5.0.0 以上版本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p><strong>指定主题：</strong>修改 _config.yml 站点配置文件中的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">theme: fluid<br></code></pre></td></tr></table></figure><p>清除缓存并本地预览：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hexo c &amp; hexo s<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/fluid.png" alt="fluid"></p><p>图片位于：<code>node_modules\hexo-theme-fluid\source\img\</code>目录下</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>而如果是插件，那么就与主题的安装大不相同了。先找到需要的插件，然后再进入到插件的 GitHub 页面，一般在 <code>README.md</code> 中都会详细介绍如何安装。</p><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="①-hexo部署到gitee后无样式问题"><a href="#①-hexo部署到gitee后无样式问题" class="headerlink" title="① hexo部署到gitee后无样式问题"></a>① hexo部署到gitee后无样式问题</h3><details class="lake-collapse"><summary id="u4ba7e748"><span class="ne-text">参考</span></summary><p id="u08f876ee" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="font-size: 14px"></span><a href="https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank" data-href="https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank" target="_blank" class="ne-link"><span class="ne-text">https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank</span></a></p></details><ol><li>修改 <code>_config.yml</code> 配置，添加 <code>url</code> 和 <code>root</code> 两个配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, ......</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://boxpiggy.gitee.io/kingshit</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/kingshit/</span><br></code></pre></td></tr></table></figure><p><code>url</code> 为 Gitee Pages 上的网址</p><p><code>root </code> 为”仓库名”</p><ol start="2"><li>最后更新 Gitee Pages</li></ol><hr><p><strong>参考教程</strong></p><p><a href="https://www.cnblogs.com/visugar/p/6821777.html">https://www.cnblogs.com/visugar/p/6821777.html</a></p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p><p><a href="https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg">https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg</a></p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&vd_source=8a4e439fa8e8c5283477bc164e9a7126">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=8a4e439fa8e8c5283477bc164e9a7126</a></p><p><a href="https://sspai.com/post/59337">https://sspai.com/post/59337</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>实用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面向对象</title>
    <link href="/2022/06/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/06/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、面向对象和面向过程的区别"><a href="#一、面向对象和面向过程的区别" class="headerlink" title="一、面向对象和面向过程的区别"></a>一、面向对象和面向过程的区别</h1><p>面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：</p><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>相较于 POP，OOP 开发的程序一般具有下面这些优点：</p><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><p>在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。</p><p>求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案</p><p><strong>面向对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-comment">// 定义圆的半径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算圆的面积</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算圆的周长</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPerimeter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * Math.PI * radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个半径为3的圆</span><br>        <span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">3.0</span>);<br><br>        <span class="hljs-comment">// 输出圆的面积和周长</span><br>        System.out.println(<span class="hljs-string">&quot;圆的面积为：&quot;</span> + circle.getArea());<br>        System.out.println(<span class="hljs-string">&quot;圆的周长为：&quot;</span> + circle.getPerimeter());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了一个 Circle 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。</p><p><strong>面向过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义圆的半径</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.0</span>;<br><br>        <span class="hljs-comment">// 计算圆的面积和周长</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.PI * radius * radius;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">perimeter</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * Math.PI * radius;<br><br>        <span class="hljs-comment">// 输出圆的面积和周长</span><br>        System.out.println(<span class="hljs-string">&quot;圆的面积为：&quot;</span> + area);<br>        System.out.println(<span class="hljs-string">&quot;圆的周长为：&quot;</span> + perimeter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长。</p><h1 id="二、面向对象三大特征"><a href="#二、面向对象三大特征" class="headerlink" title="二、面向对象三大特征"></a>二、面向对象三大特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><p>就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作【方法】，才能对数据进行操作</p><p><strong>步骤</strong></p><ol><li>对属性进行私有化private 【不能直接修改属性】</li><li>提供一个公共的 public set 方法，用于对属性判断并赋值 public void</li><li>提供一个公共的 public get 方法，用于获取属性的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <span class="hljs-comment">// id属性私有化</span><br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">// name属性私有化</span><br><br>    <span class="hljs-comment">//获取id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-comment">//设置id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-comment">//获取name的方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-comment">//设置name的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造器 与 set 结合</strong></p><p>将 set 方法写在构造器中，仍然可以进行数据验证</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8Eset%E7%BB%93%E5%90%88.png" alt="构造器与set结合"></p><h2 id="继承（Extends）"><a href="#继承（Extends）" class="headerlink" title="继承（Extends）"></a>继承（Extends）</h2><p>继承可以解决代码复用。当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类无需重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承父类即可。</p><p>子类自动拥有父类定义的属性和方法。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="重要规则"><a href="#重要规则" class="headerlink" title="重要规则"></a>重要规则</h3><ol><li>子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过父类提供的公共方法去访问；</li><li>子类必须调用父类的构造器，完成对父类的初始化；</li><li>当创建子类对象时，不管使用子类哪个构造器，默认情况下总会去调用父类的无参构造器（<code>super();</code>）；（示例1）</li><li>如果父类没有无参构造器，则必须在子类的构造器中使用<code>super</code>去指定使用父类哪个构造器完成对父类的初始化工作，否则编译不通过；（示例2）</li><li>如果希望指定去调用父类的某个构造器，则显式地调用一下：<code>super(参数列表);</code></li><li><code>super</code>在使用时，必须放在构造器第一行；（<code>super</code>只能在构造器中使用）</li><li><code>super()</code> 和 <code>this()</code> 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>父类构造器的调用不限于直接父类！将一直往上追溯直到<code>Object</code>类（顶级父类）</li><li>java 是单继承机制：子类只能继承一个父类；</li><li>不能滥用继承关系，子类和父类之间必须满足 is-a 的逻辑关系。（Person is a Music? Music extends Person × Cat is a Animal? Cat extends Animal √ ）</li></ol><p><strong>示例2-1</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.png" alt="构造器调用顺序"></p><p><strong>示例2-2</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%8C%87%E5%AE%9A%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="指定父类构造器"></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="继承内存分析"></p><p><strong>分析：</strong></p><p>（1）首先看子类是否有该属性；</p><p>（2）如果子类有，并且可以访问，则返回信息；（父类相同的属性就无法访问了）</p><p>（3）如果子类没有，就看父类有没有，如果父类有，并且可以访问，就返回信息；</p><p>（4）如果父类没有，就按照（3）的规则，继续找上级父类，知道 Object……</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>代表父类的引用，用于访问父类的属性、方法、构造器。</p><p><strong>调用父类的构造器的好处：</strong>分工明确，父类属性由父类初始化，子类属性由子类初始化。</p><p><strong>基本语法</strong></p><p>访问父类的属性（除<code>private</code>以外），<code>super.field;</code></p><p>访问父类的方法（除<code>private</code>以外），<code>super.method();</code></p><p>访问父类的构造器，<code>super(参数列表);</code> （只能放在构造器第一句，只能出现一句）</p><p><strong>重要规则</strong></p><ol><li><p>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过<code>super</code>。如果没有重名，使用<code>super</code>、<code>this</code>、直接访问是一样的效果。</p></li><li><ol><li><strong>查找同名方法和属性的规则：</strong></li><li>先找本类，如果有，则调用</li><li>如果本类没有，找上一级父类（有，并可以调用，则调用）</li><li>如果父类没有，继续往上找，直到<code>Object</code>类</li><li><code>method()</code>和<code>this.method()</code>等价遵循以上规则，<code>super.method()</code>则直接跳过本类查找父类</li></ol></li><li><p><code>super</code>的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名成员，则遵循就近原则。</p></li></ol><p><strong>super 和 this 的比较</strong></p><table><thead><tr><th></th><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>1</td><td>访问属性</td><td>访问本类中的属性，如果本类没有此属性，则从父类中继续查找</td><td>从父类开始查找属性</td></tr><tr><td>2</td><td>调用方法</td><td>访问本类中的方法，如果本类没有此方法，则从父类中继续查找</td><td>从父类开始查找方法</td></tr><tr><td>3</td><td>调用构造器</td><td>调用本类构造器，必须放在构造器首行</td><td>调用父类构造器，必须放在子类构造器首行</td></tr><tr><td>4</td><td>特殊</td><td>表示当前对象</td><td>子类中访问父类对象</td></tr></tbody></table><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>方法或对象具有多种形态</p><ol><li><p>方法的多态：方法重写和重载就体现多态</p></li><li><p>对象的多态（核心）：</p></li><li><ol><li>一个对象的编译类型和运行类型可以不一致； 如：<code>Animal animal = new Dog();</code></li><li>编译类型在定义对象时，就确定了，不能改变；</li><li>运行类型是可以变化的，可通过<code>getClass()</code>查看运行类型；</li><li>编译类型看定义时<code>=</code>号的左边，运行类型看<code>=</code>号的右边</li></ol></li></ol><h3 id="多态的特点"><a href="#多态的特点" class="headerlink" title="多态的特点"></a>多态的特点</h3><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p><strong>本质：</strong>父类的引用指向了子类的对象</p><p><strong>语法：</strong><code>父类类型 引用名 = new 子类类型();</code></p><p><strong>向上转型调用方法的规则如下：</strong></p><ol><li>可以调用父类中的所有成员（遵守访问权限）；不能调用子类中的特有成员；</li><li>在<strong>编译期</strong>，只能调用父类中声明的方法，但在<strong>运行期</strong>，实际执行的是子类重写父类的方法；</li><li>在编译阶段，能调用哪些成员，是由编译类型来决定的（编译器）；</li><li>最终运行效果看子类的具体实现。</li></ol><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;动物&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;sleep&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;run&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;eat&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;cat eat fish&quot;</span>);&#125;  <span class="hljs-comment">//重写eat方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;cat catch mouse&quot;</span>);&#125;  <span class="hljs-comment">//Cat类特有的catchMouse方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        animal.eat();  <span class="hljs-comment">//输出：cat eat fish</span><br>        animal.run();  <span class="hljs-comment">//输出：run</span><br>        animal.show();  <span class="hljs-comment">//输出：hello</span><br>        animal.sleep();  <span class="hljs-comment">//输出：sleep</span><br>        animal.catchMouse();  <span class="hljs-comment">//报错，因为在编译阶段，能调用哪些成员，是由编译类型来决定的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>语法：<code>子类类型  引用名  =  (子类类型)父类引用;</code></p><ol><li>只能强转父类的引用，不能强转父类的对象；</li><li>要求父类的引用必须指向的是当前目标类型的对象；</li><li>当向下转型后，可以调用子类类型中所有的成员。</li></ol><p>编译类型和运行类型不一致才需要向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//续上示例3</span><br><span class="hljs-comment">//若要调用Cat的 catchMouse方法</span><br><span class="hljs-comment">//向下转型</span><br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal;<br>cat.catchMouse();  <span class="hljs-comment">//输出：cat catch mouse</span><br></code></pre></td></tr></table></figure><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><ol><li><strong>属性</strong>没有重写之说，属性的值看<strong>编译类型</strong>。（示例4）</li></ol><p><strong>示例4</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Base</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>        System.out.println(base.count);  <span class="hljs-comment">//输出 10</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; &#125;<br></code></pre></td></tr></table></figure><ol><li><code>instanceof</code> 比较操作符：用于判断对象的运行类型，是否为XX类型或者XX类的子类型。（示例5）</li></ol><p><strong>示例5</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//续上（示例4）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Sub</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>        System.out.println(sub <span class="hljs-keyword">instanceof</span> Sub);  <span class="hljs-comment">//true</span><br>        System.out.println(sub <span class="hljs-keyword">instanceof</span> Base);  <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><ol><li>当调用对象<strong>方法</strong>时，该方法会和该对象的内存地址&#x2F;运行类型绑定</li><li>当调用对象<strong>属性</strong>时，没有动态绑定机制，哪里声明，哪里使用。</li></ol><p><strong>示例6</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicBinding</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        System.out.println(a.sum());  <span class="hljs-comment">// 30</span><br>        System.out.println(a.sum1());  <span class="hljs-comment">// 20</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getI() + <span class="hljs-number">10</span>;  <span class="hljs-comment">//调用运行类型的 getI() 方法 </span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//先找局部变量，局部变量没有i，再找属性，属性有则返回 i+10=&gt;10+10</span><br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">10</span>;  <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">//public int sum() &#123;</span><br>    <span class="hljs-comment">//    return i + 20;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">//属性没有动态绑定机制，哪里声明就使用哪里的，使用的是B类的属性i = 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h3><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</p><p><strong>示例7</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// Student对象 和 Teacher对象，统一放在数组中，并调用每个对象的say方法</span><br>    Person[] persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[<span class="hljs-number">3</span>];<br>    persons[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">20</span>);<br>    persons[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;shit&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-number">99</span>);<br>    persons[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;boxpig&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20000</span>);<br><br>    <span class="hljs-comment">//循环遍历多态数组，调用say</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; persons.length; i++) &#123;<br>        <span class="hljs-comment">//persons[i] 编译类型是Person，运行类型是根据实际情况由JVM判断</span><br>        System.out.println(persons[i].say());  <span class="hljs-comment">//动态绑定机制</span><br>        <span class="hljs-comment">// 使用类型判断+向下转型</span><br>        <span class="hljs-comment">// 判断persons[i] 的运行类型是不是Student</span><br>        <span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Student) &#123;  <br>            <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) persons[i];  <span class="hljs-comment">//向下转型</span><br>            student.study();<br>            <span class="hljs-comment">//以上等价于 ((Student) persons[i]).study();</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (persons[i] <span class="hljs-keyword">instanceof</span> Teacher)&#123;<br>            ((Teacher) persons[i]).teach();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;你的类型有误...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p>方法定义的形参类型为父类类型，实参类型允许为子类类型。</p><h1 id="三、接口与抽象类"><a href="#三、接口与抽象类" class="headerlink" title="三、接口与抽象类"></a>三、接口与抽象类</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名 &#123;<br>    <span class="hljs-comment">//属性 总是(自带) public static final</span><br>    <span class="hljs-comment">//方法（ 1.抽象方法   2.默认实现方法   3.静态方法 ）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//接口中的抽象方法，public abstract可以省略</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;我是默认实现方法&quot;</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;我是静态方法&quot;</span>); &#125;<br>&#125;<br><br>class 类名 implements 接口 &#123;<br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-comment">//必须实现的接口的抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认方法和静态方法是 jdk8 新增，jdk7 以前接口内所有方法均无方法体，即都是抽象方法。</li><li>接口中的<strong>方法</strong>会被隐式的指定为 <code>public abstract</code></li><li>接口中的<strong>变量</strong>会被隐式的指定为 <code>public static final</code> 变量</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>由于自带<code>static</code>，接口中属性的访问语法：<code>接口名.属性名</code></li><li>一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是<code>public</code>；（IDEA快捷键：ctrl+i 或 alt shift enter）</li><li>抽象类实现接口，可以不用实现抽象方法；</li><li>接口支持多继承；（一个接口不能继承其他类，但是可以继承多个别的接口）</li><li>一个类可以同时实现多个接口；</li><li>接口的修饰符只能是 public 和 默认，这点和类一样。</li></ul><h3 id="为什么需要接口？"><a href="#为什么需要接口？" class="headerlink" title="为什么需要接口？"></a>为什么需要接口？</h3><ul><li>接口比抽象类还要抽象，可以更加规范地对子类进行约束，全面地实现了：规范和具体实现的分离。</li><li>接口就是规范，定义的是一组规则。本质是契约。</li><li>项目的具体需求是多变的，开发要以不变（规范）应万变。因此开发项目往往都是面向接口编程。</li></ul><p><strong>实现类可以不必覆写</strong><code>**default**</code><strong>方法。</strong><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><h3 id="接口的多态性"><a href="#接口的多态性" class="headerlink" title="接口的多态性"></a>接口的多态性</h3><p>接口引用可以指向实现了该接口的对象实例。</p><p>示例3-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IF</span> <span class="hljs-variable">if01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();    <span class="hljs-comment">//接口类型的变量 if01 可以指向 实现了IF接口的对象实例</span><br>        <span class="hljs-type">IF</span> <span class="hljs-variable">if02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>示例3-2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Camera</span> <span class="hljs-variable">camera</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        <span class="hljs-comment">//把手机、相机对象接入计算机</span><br>        computer.work(camera);<br>        computer.work(phone);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br>    <span class="hljs-comment">//1. UsbInterface usbInterface 形参是接口类型 UsbInterface</span><br>    <span class="hljs-comment">//2. 可以接收（实现了UsbInterface接口的类的）对象实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(UsbInterface usbInterface)</span> &#123;<br>        <span class="hljs-comment">//通过接口来调用方法</span><br>        usbInterface.start();<br>        usbInterface.stop();    <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//USB接口，规定接口的相关规范（方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//手机实现USB接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//相机实现USB接口</span><br></code></pre></td></tr></table></figure><p>示例3-3（多态数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//多态数组 -&gt; 接口类型数组</span><br>        Usb[] usbs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Usb</span>[<span class="hljs-number">2</span>];<br>        usbs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        usbs[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        <span class="hljs-comment">//输出数组对象的方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; usbs.length; i++) &#123;<br>            usbs[i].work();  <span class="hljs-comment">//动态绑定...</span><br>            <span class="hljs-keyword">if</span> (usbs[i] instance of Phone) &#123;  <span class="hljs-comment">//判断运行类型是否为Phone，是才调用手机特有的call方法</span><br>                ((Phone) usbs[i]).call();  <span class="hljs-comment">//向下转型            </span><br>            &#125;        <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Usb</span>&#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>; &#125;  <span class="hljs-comment">//usb接口，规定了work方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;手机可以打电话&quot;</span>); &#125;  <span class="hljs-comment">//手机特有的call方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;手机工作中...&quot;</span>); &#125;  <span class="hljs-comment">//实现手机的work方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;相机工作中...&quot;</span>); &#125;  <span class="hljs-comment">//实现相机的work方法</span><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>手机工作中...<br>手机可以打电话<br>相机工作中...<br></code></pre></td></tr></table></figure><p>接口的多态传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfacePolyPass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 接口类型的变量 可以指向 实现了该接口的类的对象</span><br>        <span class="hljs-type">IA</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>        <span class="hljs-comment">// 如果IB继承了IA接口，而Apple类实现了IB接口，那实际上相当于Apple类也实现了IA接口</span><br>        <span class="hljs-type">IB</span> <span class="hljs-variable">ib</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IA</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IB</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>没有任何方法的接口被称为标记接口。</p><p>标记接口是计算机科学中的一种设计思路，用于给那些面向对象的编程语言描述对象。因为编程语言本身并不支持为类维护元数据，而标记接口可以用作描述类的元数据，弥补了这个功能上的缺失。对于实现了标记接口的类，我们就可以在运行时通过反射机制去获取元数据。</p><p>以<code>Serializable</code>接口为例，如果一个类实现了这个接口，则表示这个类可以被序列化。因此，我们实际上是通过了<code>Serializable</code>这个接口给该类标记了【可被序列化】的元数据，打上了【可被序列化】的标签。这也是标记&#x2F;标签接口名字的由来。</p><p>在Java中，标记接口主要有以下两种目的：</p><ol><li>建立一个公共的父接口。比如<code>EventListener</code>接口，一个由几十个其它接口扩展的Java API，当一个接口继承了EventListener接口，Java虚拟机（JVM）就知道该接口将要被用于一个事件的代理方案。同样的，你可以使用一个标记接口来建立一组接口的父接口。</li><li>向一个类添加数据类型。这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法（因为标记接口根本就没有方法），但是该类通过 Java 的<strong>多态性</strong>可以变成一个接口类型。</li></ol><p>更多的，一些容器例如 Ejb 容器，Servlet 容器或运行时环境依赖标记接口识别类是否需要进行某种处理，比如<code>Serialialbe</code>接口标记类需要进行序列化操作。</p><p>当然了，在现在 Spring 流行的时代，注解（Annotation）已经成为了最好的维护元数据的方式。因为注解能声明在包、类、字段、方法、局部变量、方法参数等之上，既灵活又方便地起到维护元数据的目的。</p><h3 id="Java-8-新增"><a href="#Java-8-新增" class="headerlink" title="Java 8 新增"></a>Java 8 新增</h3><p>Java 8 引入的<code>default</code>方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method in the interface.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 8 引入的<code>static</code>方法无法在实现类中被覆盖，只能通过接口名直接调用（ <code>MyInterface.staticMethod()</code>），类似于类中的静态方法。<code>static</code>方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method in the interface.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 9 允许在接口中使用 <code>private</code> 方法。<code>private</code>方法可以用于在接口内部共享代码，不对外暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-comment">// default 方法</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        commonMethod();<br>    &#125;<br><br>    <span class="hljs-comment">// static 方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        commonMethod();<br>    &#125;<br><br>    <span class="hljs-comment">// 私有静态方法，可以被 static 和 default 方法调用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commonMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a private method used internally.&quot;</span>);<br>    &#125;<br><br>      <span class="hljs-comment">// 实例私有方法，只能被 default 方法调用。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceCommonMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a private instance method used internally.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>是一种模板模式。抽象类为所有子类提供一个通用模板，子类可以在这个模板的基础上进行扩展。</p><p>通过抽象类，可以避免子类设计的随意性。通过抽象类，严格限制子类的设计，使子类之间更加通用。</p><p>抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>有抽象方法的类只能定义为抽象类，抽象类不一定包含抽象方法；</li><li>抽象类不能实例化，即不能用<code>new</code>来实例化抽象类；</li><li>抽象类可以有任何成员（属性、方法、构造方法）【抽象类本质还是类】，但是构造方法不能用来new实例，只能用来被子类调用；</li><li>抽象类只能用来继承；</li><li>如果一个类继承了抽象类，则它必须<strong>实现</strong>抽象类的<strong>所有</strong>抽象方法，除非也声明为抽象类。即抽象方法必须被子类实现。</li><li>抽象方法不能有主体，即不能实现；（不能有{大括号}）</li><li>抽象方法不能用<code>private</code>、<code>final</code>和<code>static</code>来修饰，因为这些关键字都是和重写相违背。</li></ul><h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>把方法的设计与实现分离</p><p>设计：这个类有什么方法、方法的声明（方法名、返回值、形参）</p><p>实现：具体的方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-comment">//抽象类</span><br>    String str; <span class="hljs-comment">//可定义属性</span><br>    <span class="hljs-comment">// 抽象方法，不定义run()方法 (加abstract关键字，不要大括号&#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>; <br><br>    <span class="hljs-comment">// 可定义普通方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;呼吸&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 可以定义构造方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;创造一个动物&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本质是：</p><ul><li>上层代码只定义规范（例如：abstract class Person）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>需求：</strong></p><ol><li>有多个类，完成不同的任务job</li><li>要求统计得到各自完成任务的时间</li></ol><p><strong>设计一个抽象类（Template），能完成如下功能：</strong></p><ol><li>编写方法<code>calculateTime()</code>，可以计算某段代码的耗时时间</li><li>编写抽象方法<code>job()</code></li><li>编写一个子类<code>Sub</code>，继承抽象类<code>Template</code>，并实现<code>job</code>方法</li><li>编写一个测试类<code>TestTemplate</code>进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类//抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span> &#123;  <br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-comment">//实现方法，调用job方法，统计job方法的耗时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateTime</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//得到开始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        job();  <span class="hljs-comment">//动态绑定机制</span><br><br>        <span class="hljs-comment">//得到结束时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;任务执行时间：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//子类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ajob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;<br>    <span class="hljs-comment">//计算任务A</span><br>    <span class="hljs-comment">//1+2+3+...+100000</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//实现了父类Template的抽象方法job</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000000</span>; i++) &#123;<br>            num += i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//子类B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bjob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;<br>    <span class="hljs-comment">//计算任务B</span><br>    <span class="hljs-comment">//1*2*3*...*800000</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">800000</span>; i++) &#123;<br>            num *= i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类和接口的异同点"><a href="#抽象类和接口的异同点" class="headerlink" title="抽象类和接口的异同点"></a>抽象类和接口的异同点</h2><p>接口和抽象类的共同点</p><p><strong>实例化</strong>：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</p><p><strong>抽象方法</strong>：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</p><p>接口和抽象类的区别</p><p><strong>设计目的</strong>：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p><p><strong>继承和实现</strong>：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。</p><p><strong>成员变量</strong>：接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（private, protected, public），可以在子类中被重新定义或赋值。</p><p><strong>方法</strong>： </p><ul><li>Java 8 之前，接口中的方法默认是 <code>public abstract</code> ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 default（默认） 方法和 static （静态）方法。 自 Java 9 起，接口可以包含 private 方法。</li><li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li></ul><h1 id="四、类与对象"><a href="#四、类与对象" class="headerlink" title="四、类与对象"></a>四、类与对象</h1><h2 id="类与对象关系"><a href="#类与对象关系" class="headerlink" title="类与对象关系"></a>类与对象关系</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="类与对象的关系"></p><h2 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a>属性&#x2F;成员变量</h2><ol><li>从概念或叫法上看：成员变量 &#x3D; 属性 &#x3D; 字段（field）。</li><li>属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象、数组）。</li><li>属性的定义语法：访问修饰符 属性类型 属性名  示例：<code>protected String name;</code>。</li><li>属性的定义类型可以为任意类型，包括基本类型和引用类型。</li><li>属性如果没有赋值，有默认值，规则和数组一致：int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u0000, boolean false, String null;</li></ol><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><ol><li>先声明后创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Cat cat;<br>cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><ul><li>对象名 cat 在栈指向一个空的空间</li><li>在堆开辟空间，同时分配地址（只要有数据空间，就会有地址），把地址赋给 cat 对象名</li></ul><ol><li>直接创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>先在<strong>方法区</strong>加载<code>Cat</code>类信息（<strong>属性</strong>和<strong>方法</strong>信息，只会加载一次）；</li><li>在堆中分配空间，进行默认初始化；</li><li>把地址赋给<code>whiteCat</code>，<code>whiteCat</code>就指向对象；</li><li>进行指定初始化，比如  <code>whiteCat.name = &quot;小白&quot;;</code> <code>whiteCat.age = 6;``whiteCat.color = &quot;white&quot;;</code></li></ol><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="类与对象的内存布局"></p><p><strong>⚠</strong> <strong>JDK1.7 ，字符串常量池和静态变量从永久代（方法区）移动了 Java 堆中</strong></p><p>永久代是方法区的具体实现，和堆一样都是由 JVM 管理的运行时数据区域，但堆有更高的 GC 回收效率，因此把需要大量进行字符串回收的字符串常量池移到堆中。</p><p>JDK1.8 ，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存，不受 JVM 内存的限制。</p><p>详见：<a href="https://www.yuque.com/kingshit/java/crf342hk3xb326g3">Java内存区域详解</a></p><h3 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h3><p><strong>栈</strong>：一般存放基本数据类型（局部变量）</p><p><strong>堆</strong>：存放对象（Cat cat，数组等）</p><p><strong>方法区</strong>：常量池（常量，比如字符串），类加载信息</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%EF%BC%88jdk1.7%E4%BB%A5%E5%89%8D%EF%BC%89.png" alt="类与对象内存分配机制（jdk1.7以前）"></p><h3 id="对象创建的流程分析"><a href="#对象创建的流程分析" class="headerlink" title="对象创建的流程分析"></a>对象创建的流程分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="对象创建的流程分析"></p><p>jdk 1.7以前</p><p><strong>流程分析：</strong></p><ol><li>加载类信息（Xxx.class），只会加载一次</li><li>在堆中分配空间（地址）</li><li>完成对象初始化（默认初始化、显式初始化、构造器初始化）</li><li>把对象在堆中的地址返回给对象的引用（对象名）</li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="方法调用机制"><a href="#方法调用机制" class="headerlink" title="方法调用机制"></a>方法调用机制</h3><p>方法执行会开辟一个独立的栈空间，方法执行完毕该空间就会释放。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6.png" alt="方法调用机制"></p><center>（jdk 1.7以前）</center><p><strong>同一类中的方法调用</strong>：直接调用</p><p><strong>跨类中的方法调用</strong>：需要先创建对象，通过对象名调用</p><h3 id="成员方法的定义"><a href="#成员方法的定义" class="headerlink" title="成员方法的定义"></a>成员方法的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">访问修饰符 返回数据类型 方法名(形参列表...)&#123;  <span class="hljs-comment">// 方法体</span><br>    语句；<br>    返回值；<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>访问修饰符：控制方法使用的范围，public、protected、默认（不写）、private</p></li><li><p>形参列表：表示成员方法输入 ；</p></li><li><ol><li>可以有0或多个参数，用逗号分隔；</li><li>参数类型可以为任意类型，包括基本和引用类型；</li><li>调用带参数的方法时，一定要对应着参数列表传入相同类型或兼容类型的参数；</li><li>方法定义时的参数成为形式参数（形参&#x2F;虚参）；方法调用时传入的参数成为实际参数（实参）；实参和形参的类型要一致或兼容，个数、顺序也要一致；</li></ol></li><li><p>返回数据类型：表示成员方法输出，void 表示没有返回值：</p></li><li><ol><li>一个方法最多有一个返回值；（如果要返回多个值，可以声明数组类型）</li><li>返回类型可以为任意类型，包括基本和引用类型；</li><li>如果方法声明了返回数据类型，则方法体中最后的执行语句必须为 return 值；而且要求返回值类型必须和return的值类型一致或兼容</li><li>如果方法是 void，不能有返回值，方法体中可以没有 return 语句，或者只写 return；</li></ol></li><li><p>方法体：表示为了实现某一功能代码块；</p></li><li><ol><li>写完成功能的具体语句，可以为输入输出、变量、运算、分支、循环、方法调用等，但不能再定义方法，即方法不能嵌套定义。</li></ol></li><li><p><code>return</code> 语句不是必须的。</p></li></ol><h3 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p><code>AA</code>类中编写一个方法<code>swap</code>，接收两个整数，在方法中交换两个数，主方法中声明两个数，调用<code>swap</code>方法，看两数是否发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>        <span class="hljs-type">AA</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>();<br>        aa.swap(a, b);<br>        System.out.println(<span class="hljs-string">&quot;main方法：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:8, b:24</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a和b交换前：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:8, b:24</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>        a = b;<br>        b = tmp;<br>        System.out.println(<span class="hljs-string">&quot;a和b交换后：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:24, b:8</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong>基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png" alt="基本数据类型传参机制"></p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>B类中编写一个方法test100，可以接收一个数组，在方法中修改该数组，看原数组是否变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BB</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BB</span>();<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        bb.test100(arr);<br>        <span class="hljs-comment">// 打印数组</span><br>        System.out.println(<span class="hljs-string">&quot;main中的数组：&quot;</span>);  <span class="hljs-comment">// 100 2 3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test100</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;test100中的数组：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong>引用类型，传递的是地址（其实传递也是值，但值是地址），可以通过形参影响实参</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png" alt="引用类型传参机制"></p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>JVM 会给每个对象分配<code>this</code>，代表当前对象。</p><p>简单的说，哪个对象调用，<code>this</code>就代表哪个对象。</p><p><strong>示例</strong></p><p>由于 java 是在虚拟机上跑的，地址是虚拟机的地址，无法直接获取对象的地址。</p><p><code>hashCode()</code>方法会针对不同对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThisTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;皮蛋&quot;</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// 输出dog1对象的哈希值（根据对象内部地址转换）</span><br>        System.out.println(<span class="hljs-string">&quot;dog1 的 hashCode= &quot;</span> + dog1.hashCode());<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;皮球&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 输出dog2对象的哈希值</span><br>        System.out.println(<span class="hljs-string">&quot;dog2 的 hashCode= &quot;</span> + dog2.hashCode());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">27</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">// 构造器</span><br>        <span class="hljs-comment">// 把构造方法的实参赋给属性</span><br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">//this.name 就是当前对象的属性name</span><br>        <span class="hljs-built_in">this</span>.age = age;   <span class="hljs-comment">//this.age 就是当前对象的属性age</span><br>        <span class="hljs-comment">// 测试：当调用构造器初始化对象的时候，输出当前this的哈希值</span><br>        System.out.println(<span class="hljs-string">&quot;this.hashCode= &quot;</span> + <span class="hljs-built_in">this</span>.hashCode());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 成员方法，输出属性x信息</span><br>        System.out.println(name + <span class="hljs-string">&quot;\t&quot;</span> + age + <span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="输出结果"></p><p>由于<code>this</code>指向当前对象，因此<code>this</code>的地址与当前对象地址相同</p><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/this%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="this内存分析"></p><p>jdk 1.7以前</p><p>可以简单理解成（虽然现实可能不会这样）：在对象创建完成后，在堆内隐藏了一个this属性，指向对象本身。</p><h3 id="this-用法"><a href="#this-用法" class="headerlink" title="this 用法"></a>this 用法</h3><ol><li><code>this</code>关键字可以用来访问本类的属性、方法、构造器；</li><li><code>this</code>用于区分当前类的属性和局部变量；</li><li>访问成员方法的语法：<code>this.方法名(参数列表);</code> </li><li>访问构造器语法：<code>this(参数列表);</code>  注意只能在构造器中使用（即只能在构造器中访问另一个构造器），并只能放置在第一条语句；</li><li><code>this</code>不能在类定义的外部使用，只能在类定义的方法中使用。</li></ol><h1 id="五、深拷贝和浅拷贝？什么是引用拷贝？"><a href="#五、深拷贝和浅拷贝？什么是引用拷贝？" class="headerlink" title="五、深拷贝和浅拷贝？什么是引用拷贝？"></a>五、深拷贝和浅拷贝？什么是引用拷贝？</h1><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝的示例代码如下，我们这里实现了<code>Cloneable</code>接口，并重写了<code>clone()</code>方法。</p><p><code>clone()</code>方法的实现很简单，就是直接调用的是父类<code>Object</code>的<code>clone()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Address) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-keyword">return</span> person;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// true</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code>的克隆对象和<code>person1</code>使用的仍然是同一个<code>Address</code> 对象。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>简单对<code>Person</code>类的<code>clone()</code>方法进行修改，连带着要把<code>Person</code>对象内部的<code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        person.setAddress(person.getAddress().clone());<br>        <span class="hljs-keyword">return</span> person;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// false</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出，显然<code>person1</code>的克隆对象和<code>person1</code>包含的<code>Address</code>对象已经是不同的了。</p><h2 id="什么是引用拷贝？"><a href="#什么是引用拷贝？" class="headerlink" title="什么是引用拷贝？"></a>什么是引用拷贝？</h2><p>简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/shallow&deep-copy.png" alt="shallow&amp;deep-copy"></p><h1 id="六、static类变量和类方法"><a href="#六、static类变量和类方法" class="headerlink" title="六、static类变量和类方法"></a>六、<code>static</code>类变量和类方法</h1><h2 id="6-1-静态变量（类变量）"><a href="#6-1-静态变量（类变量）" class="headerlink" title="6.1 静态变量（类变量）"></a>6.1 静态变量（类变量）</h2><p>当我们需要让某个类的所有对象都共享一个变量时，就可以使用。比如：定义学生类，统计所有学生共交多少钱。</p><h3 id="6-1-1-基本概念"><a href="#6-1-1-基本概念" class="headerlink" title="6.1.1 基本概念"></a>6.1.1 基本概念</h3><p><strong>类变量</strong>也叫<strong>静态变量&#x2F;静态属性</strong>，是该类所有对象共享的变量。任何一个该类的对象去访问或修改它时，取到的和修改的都是同一个变量。</p><h3 id="6-1-2-语法"><a href="#6-1-2-语法" class="headerlink" title="6.1.2 语法"></a>6.1.2 语法</h3><p>定义：<code>访问修饰符 static 数据类型 变量名;</code> 【推荐】  或  <code>static 访问修饰符 数据类型 变量名</code></p><p>访问：<code>类名.类变量名</code> 【推荐】或  <code>对象名.类变量名</code></p><h3 id="6-1-3-类变量特点"><a href="#6-1-3-类变量特点" class="headerlink" title="6.1.3 类变量特点"></a>6.1.3 类变量特点</h3><ol><li><code>static</code>变量是同一个类所有对象共享；</li><li><code>static</code>变量是随着类的加载而创建，只执行一次，所以没有创建对象实例也可以访问。</li><li>类变量的访问，也必须遵守相关访问权限</li><li>类变量的生命周期随着类的加载开始，随着类的消亡而销毁。</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8F%98%E9%87%8F.png" alt="类变量"></p><p>jdk 1.7以前（from hsp）</p><blockquote><p><strong>2024-8-3更正上图</strong>：</p><p>方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。而<strong>字符串常量池</strong>、<strong>静态变量</strong> JDK1.7 开始就从永久代（即方法区）移动到了 Java 堆中。（上图的静态域，按我理解是存储静态变量的区域）</p><p>![JDK 1.7](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK</a> 1.7.png)</p></blockquote><h2 id="6-2-静态方法（类方法）"><a href="#6-2-静态方法（类方法）" class="headerlink" title="6.2 静态方法（类方法）"></a>6.2 静态方法（类方法）</h2><p><strong>类方法</strong>也叫<strong>静态方法</strong>。实际开发往往将一些通用的方法设计成静态方法，这样就不需要创建对象就可以使用，提高开发效率。</p><h3 id="6-2-1-语法"><a href="#6-2-1-语法" class="headerlink" title="6.2.1 语法"></a>6.2.1 语法</h3><p>定义：<code>访问修饰符 static 数据返回类型 方法名() &#123; &#125;</code></p><p>调用：<code>类名.类方法名</code>  或  <code>对象名.类方法名</code></p><p>特点</p><ol><li><p>静态方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：</p></li><li><ol><li>静态方法中无this参数；</li><li>普通方法中隐含this参数</li></ol></li><li><p>静态方法可以通过类名调用，也可以通过对象名调用</p></li><li><p>静态方法不中允许使用和对象相关的关键字，比如<code>this</code>和<code>super</code>。</p></li><li><p><strong>静态方法</strong>只能访问静态成员；<strong>普通成员</strong>方法可以访问静态成员和非静态成员。</p></li></ol><h2 id="6-3-main方法"><a href="#6-3-main方法" class="headerlink" title="6.3 main方法"></a>6.3 main方法</h2><p>1）<code>main</code>方法是虚拟机（JVM）调用；</p><p>2）JVM 需要调用类得<code>main()</code>方法，所以该方法得访问权限必须是<code>public</code>；</p><p>3）JVM 在执行<code>main()</code>方法时不必创建对象，所以该方法必须是<code>static</code>；</p><p>4）该方法接收<code>String</code>类型得数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数；</p><p>5）命令：<code>java 运行的类名 arg1 arg2 arg3</code>；</p><p>6）<code>main</code>方法遵循静态方法规则。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/main%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82.png" alt="main方法传参"></p><p>示例6-1：（idea中)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个参数：&quot;</span> + args[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%A4%BA%E4%BE%8B6-1%E7%BB%93%E6%9E%9C.png" alt="示例6-1结果"></p><h1 id="七、代码块"><a href="#七、代码块" class="headerlink" title="七、代码块"></a>七、代码块</h1><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><ul><li><strong>代码块（Code block）</strong>又称为<strong>初始化块</strong>，属于类中的成员【即是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过<code>&#123;&#125;</code>包围起来。</li><li>和方法不同，代码块没有方法名、返回、参数，只有方法体。</li><li>不用通过对象或类显示调用，而是加载类的时候，或创建对象时隐式调用。</li></ul><h2 id="7-2-基本语法"><a href="#7-2-基本语法" class="headerlink" title="7.2 基本语法"></a>7.2 基本语法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[ 修饰符 ] &#123; 代码 &#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>使用<code>static</code>修饰叫<strong>静态代码块</strong>，使用<code>Synchronized</code>修饰叫<strong>同步代码块</strong>；</li><li>分号（<code>;</code>）可以省略。</li></ol><h2 id="7-3-分类"><a href="#7-3-分类" class="headerlink" title="7.3 分类"></a>7.3 分类</h2><p>根据其位置和声明的不同，可以分为：</p><ul><li>局部代码块</li><li>构造代码块</li><li>同步代码块</li><li>静态代码块</li></ul><h3 id="7-3-1-局部代码块"><a href="#7-3-1-局部代码块" class="headerlink" title="7.3.1 局部代码块"></a>7.3.1 局部代码块</h3><p>在方法中出现，可以限定变量生命周期，及早释放，提高内存利用率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 局部代码块</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(number);<br>    &#125;<br>    <span class="hljs-comment">// 找不到number变量</span><br>    <span class="hljs-comment">// System. out.println(number);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-2-构造代码块"><a href="#7-3-2-构造代码块" class="headerlink" title="7.3.2 构造代码块"></a>7.3.2 构造代码块</h3><ul><li>在类中方法外出现，每次调用构造方法都会执行，并且在构造方法前执行。</li><li>相当于另外一种形式的构造器（堆构造器的补充机制），可以做初始化操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlock</span> &#123;<br>    <span class="hljs-comment">// 构造代码块，在方法外出现</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;number1: &quot;</span> + number1);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeBlock</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在构造方法后出现，但构造代码块优先于构造方法执行</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;number2: &quot;</span> + number2);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//构造代码块测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">codeBlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-comment">// 注意：构造代码块通过构造方法自动调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">number1: <span class="hljs-number">10</span><br>number2: <span class="hljs-number">100</span><br>这是构造方法<br></code></pre></td></tr></table></figure><p>因此，构造代码块依赖于构造方法，而且优先于构造方法执行。即实例对象建立，才会运行构造代码块，类不能调用构造代码块。</p><p><strong>构造代码块与构造函数的区别：</strong>构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。</p><p>也就是说，<strong>构造代码块中定义的是不同对象共性的初始化内容</strong>。如果多个构造器中都有重复的语句，可以抽取到构造初始化块中，提高代码的重用性。</p><h3 id="7-3-3-同步代码块"><a href="#7-3-3-同步代码块" class="headerlink" title="7.3.3 同步代码块"></a>7.3.3 同步代码块</h3><p>被 Java 中<code>Synchronized</code>关键词修饰的代码块。</p><blockquote><p><code>Synchronized</code>关键词不仅仅可以用来修饰代码块，与此同时也可以用来修饰方法，是一种线程同步机制，被<code>Synchronized</code>关键词修饰的代码块会被加上内置锁。</p></blockquote><p><strong>作用：</strong>在很多场景，我们没有必要去同步整个方法，而只需要同步部分代码即可，也就是使用同步代码块（JDK源码中有很多应用）。</p><p><code>Synchronized</code>同步代码块是一种高开销的操作，因此我们应该尽量减少被同步的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (CodeBlock.class) &#123;<br>            System.out.print(<span class="hljs-string">&quot;同步代码块!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，静态代码是属于类而不是属于对象的，因此使用<code>Synchronized</code>来修饰静态方法和静态对象的时候，类下的所有对象都会被锁定。</p><h3 id="7-3-4-静态代码块"><a href="#7-3-4-静态代码块" class="headerlink" title="7.3.4 静态代码块"></a>7.3.4 静态代码块</h3><p>使用<code>static</code>修饰的代码块，在类中方法外出现。</p><ul><li>随着<strong>类的加载</strong>而执行，并且只会<strong>执行一次</strong>。</li><li>静态块优先于各种代码块以及构造函数。</li><li>此外静态代码块不能访问普通变量，只能直接调用静态成员。</li></ul><p><strong>作用：</strong>对类进行初始化。</p><p><strong>类什么时候被加载？</strong></p><ol><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时（静态属性、静态方法）</li></ol><h2 id="7-4-执行顺序"><a href="#7-4-执行顺序" class="headerlink" title="7.4 执行顺序"></a>7.4 执行顺序</h2><p><strong>执行时机</strong></p><ul><li><strong>静态代码块</strong>：在类加载到JVM时初始化，且只被执行一次。</li><li><strong>构造代码块</strong>：在创建实例时，会被隐式的调用。每创建一次（每调用构造方法），构造代码块就会执行一次，构造代码块执行的顺序优先于构造器。</li></ul><h3 id="7-4-1-一个类中代码块执行顺序"><a href="#7-4-1-一个类中代码块执行顺序" class="headerlink" title="7.4.1 一个类中代码块执行顺序"></a>7.4.1 一个类中代码块执行顺序</h3><p>创建一个对象时，在一个类调用顺序是：</p><ol><li>执行静态代码块和静态属性的初始化；</li><li>执行构造代码块和普通属性的初始化；</li><li>执行构造方法；</li></ol><blockquote><p>代码块和属性初始化执行优先级一样，若有多个则按照代码定义顺序执行。</p></blockquote><p><strong>总结</strong></p><p><strong>加载类信息</strong>（加载静态代码块和静态属性初始化） -&gt; <strong>创建对象</strong>（加载普通代码块和普通属性初始化） -&gt; <strong>调用构造器</strong></p><h3 id="7-4-2-继承中代码块执行顺序"><a href="#7-4-2-继承中代码块执行顺序" class="headerlink" title="7.4.2 继承中代码块执行顺序"></a>7.4.2 继承中代码块执行顺序</h3><ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）；</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）；</li><li>父类的构造代码块和普通属性（优先级一样，按定义顺序执行）；</li><li>父类的构造方法</li><li>子类的构造代码块和普通属性（优先级一样，按定义顺序执行）；</li><li>子类的构造方法</li></ol><p><strong>总结</strong></p><p>**加载类信息(父→子)**（加载静态代码块和静态属性初始化）-&gt; (父类)<strong>加载构造代码块和普通属性初始化</strong> -&gt; (父类)<strong>调用构造器</strong>  -&gt; (子类)<strong>加载构造代码块和普通属性初始化</strong> -&gt; (子类)<strong>调用构造器</strong></p><blockquote><p>构造器的最前面隐含了<code>super()</code>和<code>&#123;普通代码块&#125;</code>。</p></blockquote><h1 id="八、对象初始化详细过程"><a href="#八、对象初始化详细过程" class="headerlink" title="八、对象初始化详细过程"></a>八、对象初始化详细过程</h1><h2 id="8-1-一个类及其对象初始化的过程"><a href="#8-1-一个类及其对象初始化的过程" class="headerlink" title="8.1 一个类及其对象初始化的过程"></a>8.1 一个类及其对象初始化的过程</h2><h3 id="什么时候需要初始化一个类"><a href="#什么时候需要初始化一个类" class="headerlink" title="什么时候需要初始化一个类"></a>什么时候需要初始化一个类</h3><p>首次创建某个对象时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <br></code></pre></td></tr></table></figure><p>首次访问某个类的静态方法或者静态字段时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Dog.staticFields;<br></code></pre></td></tr></table></figure><p>Java 解释器就会去找类的路径，定位已经编译好的 Dog.class 文件。</p><h3 id="获得类的资源"><a href="#获得类的资源" class="headerlink" title="获得类的资源"></a>获得类的资源</h3><p>然后 jvm 就会载入 <code>Dog.class</code>，生成一个<code>class</code>对象。这个时候如果有静态的方法或者变量，静态初始化动作都会被执行。这个时候要注意啦，静态初始化在程序运行过程中只会在 Class 对象首次加载的时候运行一次。这些资源都会放在 jvm 的<strong>方法区</strong>。</p><p><strong>方法区</strong>又叫<strong>静态区</strong>，跟堆一样，被所有的线程共享。</p><p>方法区中包含的都是在整个程序中永远唯一的元素，包含所有的 class 和 static 变量。</p><h3 id="初始化对象-Dog-dog-new-Dog"><a href="#初始化对象-Dog-dog-new-Dog" class="headerlink" title="初始化对象 Dog dog = new Dog()"></a>初始化对象 <code>Dog dog = new Dog()</code></h3><ol><li>第一次创建<code>Dog</code>对象先执行上面的一二步</li><li>在堆上为<code>Dog</code>对象分配足够的存储空间，所有属性和方法都被设置成默认值(数字为 0，字符为<code>null</code>，布尔为<code>false</code>，而所有引用被设置成<code>null</code>）</li><li>执行构造函数检查是否有父类，如果有父类会先调用父类的构造函数，这里假设 <code>Dog</code> 没有父类，执行默认值字段的赋值即方法的初始化动作。</li><li>执行构造函数。</li></ol><h2 id="8-2-有父类情况下的初始化"><a href="#8-2-有父类情况下的初始化" class="headerlink" title="8.2 有父类情况下的初始化"></a>8.2 有父类情况下的初始化</h2><p>假设: <code>Dog extends Animal</code></p><ol><li>执行第一步，找出<code>Dog.class</code>文件，接着在加载过程中发现他有一个基类（通过<code>extends</code> 关键字），于是先执行<code>Animal</code>类的第一二步，加载<code>Animal</code>类的静态变量和方法，加载结束之后再加载子类<code>Dog</code>的静态变量和方法。</li></ol><p>如果<code>Animal</code>类还有父类就以此类推，最终的基类叫做根基类。</p><blockquote><p>因为子类的<code>static</code>初始化可能会依赖于父类的静态资源，所以要先加载父类的静态资源。</p></blockquote><ol><li>接着要 <code>new Dog</code> 对象，先为<code>Dog</code>对象分配存储空间 -&gt; 到<code>Dog</code>的构造函数 -&gt; 创建默认的属性。这里其构造函数里面的第一行有个隐含的<code>super()</code>，即父类构造函数，所以这时会跳转到父类<code>Animal</code>的构造函数。</li></ol><p>Java 会帮我们完成构造函数的补充，Dog 实际隐式的构造函数如下:</p><ol><li>父类<code>Animal</code>执行构造函数前也是分配存储空间 -&gt; 到其构造函数 -&gt; 创建默认的属性 -&gt; 发现已经没有父类了，这个时候就给它的默认的属性赋值和方法的初始化。</li><li>接着执行构造函数余下的部分，结束后跳转到子类<code>Dog</code>的构造函数。</li><li>子类<code>Dog</code>对默认属性和方法分别进行赋值和初始化，接着完成构造函数接下来的部分。</li></ol><p><strong>为什么要执行父类 Animal 的构造方法才继续子类 Dog 的属性及方法赋值？</strong></p><p>因为子类 Dog 的非静态变量和方法的初始化有可能使用到其父类 Animal 的属性或方法，所以子类构造默认的属性和方法之后不应该进行赋值，而要跳转到父类的构造方法完成父类对象的构造之后，才来对自己的属性和方法进行初始化。</p><p>这也是为什么子类的构造函数显示调用父类构造函数 super() 时要强制写在第一行的原因，程序需要跳转到父类构造函数完成父类对象的构造后才能执行子类构造函数的余下部分。</p><p><strong>为什么对属性和方法初始化之后再执行构造函数其他的部分？</strong></p><p>因为构造函数中的显式部分有可能使用到对象的属性和方法。</p><blockquote><p><a href="https://www.runoob.com/w3cnote/java-init-object-process.html">Java 对象初始化详细过程 | 菜鸟教程</a></p></blockquote><h2 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3 总结"></a>8.3 总结</h2><h1 id="九、内部类"><a href="#九、内部类" class="headerlink" title="九、内部类"></a>九、内部类</h1><p>一个类的内部又完整嵌套了另一个类结构，被嵌套的（里面的）类成为内部类（inner class），嵌套其他类的（外面的）类称为外部类（outer class）。</p><p>内部类是类的第五大成员【属性、方法、构造器、代码块、内部类】</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>内部类最大特点是<strong>可以直接访问私有属性</strong>，并且可以体现类与类直接的包含关系。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>定义在外部类局部位置上</strong>（比如方法内）：</p><ol><li>局部内部类（有类名）</li><li>匿名内部类（没有类名，重点!!!!!!!）</li></ol><p><strong>定义在外部类的成员位置上：</strong></p><ol><li>成员内部类（没用<code>static</code>修饰）</li><li>静态内部类（有用<code>static</code>修饰）</li></ol><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在外部类的局部位置，比如方法、代码块中，并且有类名，本质仍然是一个类。</p><p><strong>重要规则</strong></p><ol><li>不能添加访问修饰符（由于它地位就是一个局部变量，局部变量不能使用修饰符），但是可以使用final修饰。</li><li>可以直接访问外部类的所有成员。</li><li>作用域：仅仅在定义它的方法或代码块中。</li><li>局部内部类 —&gt; 访问 —&gt; 外部类成员【访问方式：直接访问】</li><li>外部类 —&gt; 访问 —&gt; 局部内部类成员【访问方式：创建对象再访问】（且必须在作用域内）示例9-1</li><li>外部其他类 — 不能访问 —&gt; 局部内部类（因为局部内部类地位相当于局部变量）</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，使用：<strong>外部类名.this.成员</strong>（本质是外部类的对象，即哪个对象调用了m1）</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>定义在外部类的局部位置，比如方法、代码块中，并且没有类名，本质仍然是一个类，同时还是一个对象</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类or接口(参数列表) &#123;<br>    类体<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>因为匿名内部类<strong>既是一个类的定义</strong>，同时也<strong>本身也是一个对象</strong>，</p><p>所以从语法上看，它既有定义类的特征，也有创建对象的特征（对前面代码分析可以看出这个特点），因此可以调用匿名内部类方法。</p><p>示例9-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousInnerClassDetail</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Outer05</span> <span class="hljs-variable">outer05</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer05</span>();<br>        outer05.f1();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer05</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;  <span class="hljs-comment">//外部类属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//外部类方法</span><br>        <span class="hljs-comment">//(1) 创建一个基于类的匿名内部类</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//可以直接访问外部类的所有成员，包括私有的</span><br>                System.out.println(<span class="hljs-string">&quot;匿名内部类重写了hi方法 n1= &quot;</span> + n1);<br>            &#125;<br>        &#125;;<br>        person.hi();  <span class="hljs-comment">//动态绑定，运行类型是 Outer05$1</span><br><br>        <span class="hljs-comment">//(2) 也可以直接调用(本质：匿名内部类本身也是返回对象)</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>        &#125;.ok(<span class="hljs-string">&quot;shit&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person hi()&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ok</span><span class="hljs-params">(String str)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;输出&quot;</span> + str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重要规则（与局部内部类相似）</strong></p><ol><li>不能添加访问修饰符，因为它的地位就是一个局部变量</li><li>可以直接访问外部类的所有成员，包含私有的</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>匿名内部类 —&gt; 访问 —&gt; 外部类成员【访问方式：直接访问】</li><li>外部其他类 —&gt; 不能访问 —&gt; 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（<code>外部类名.this.成员</code>）访问</li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在外部类的成员位置，并且没有<code>static</code>修饰。</p><p><strong>重要规则</strong></p><ol><li><p>可以添加任意访问修饰符</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>成员内部类 –&gt; 访问 –&gt; 外部类成员成员【访问方式：直接访问】</p></li><li><p>外部类 –&gt; 访问 —&gt; 成员内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类 —&gt; 访问 —&gt; 成员内部类</p></li><li><ol><li>① 利用外部类创建内部类对象，再访问；【例：<code>Outer.Inner inner = outer.new Inner();</code>】（<code>**outer.new Inner();**</code> 相当于把 <code>new Inner()</code> 当作<code>outer</code>对象的成员）</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>()<br></code></pre></td></tr></table></figure><ol><li><ol><li>② 在外部类中编写一个方法，返回内部类的对象。例：</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">Inner</span> getInnerInstance() &#123;     <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();  &#125; <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.getInnerInstance();<br></code></pre></td></tr></table></figure><ol><li><ol><li>③ <code>new Outer().new Inner();</code> 相当于①，只是把<code>Outer outer = new Outer();</code> 合并了。</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>().<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); <span class="hljs-keyword">Outer</span> <span class="hljs-keyword">outer</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>(); <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br></code></pre></td></tr></table></figure><ol><li>如果外部类和成员内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，使用：<code>**外部类名.this.成员**</code></li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义在外部类的成员位置，有static修饰。</p><p><strong>重要规则（与成员内部类相似）</strong></p><ol><li><p>可以添加任意访问修饰符</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>静态内部类 –&gt; 访问 –&gt; 外部类成员【访问方式：直接访问所有的静态成员】</p></li><li><p>外部类 –&gt; 访问 —&gt; 静态内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类 —&gt; 访问 —&gt; 成员内部类</p></li><li><ol><li>方式①：利用外部类创建内部类对象，再访问；【例：<code>Outer.Inner inner = new Outer.Inner();</code>】<code>**new Outer.Inner();**</code> 因为静态内部类是静态成员，可以直接通过类名访问</li><li>方式②：在外部类中编写一个方法，返回内部类的对象。【例：<code>public static Inner getInner() &#123; return new Inner(); &#125;``Outer.Inner inner = Outer.getInner();</code> 】（非静态也可以）</li></ol></li><li><p>如果外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，使用：<strong>外部类名.成员</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberInnerClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer08</span> <span class="hljs-variable">outer08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer08</span>();<br>        outer08.t1();<br><br>        <span class="hljs-comment">//第一种 成员内部类</span><br>        <span class="hljs-comment">//Outer08.Inner08 inner08 = outer08.new Inner08();</span><br>        <br>        <span class="hljs-comment">//第一种 静态内部类</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer08</span>.Inner08();<br><br>        <span class="hljs-comment">//第二种</span><br>        <span class="hljs-comment">//在外部类中，编写一个方法，返回 Inner08 对象</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance</span> <span class="hljs-operator">=</span> outer08.getInner08Instance();<br>        <span class="hljs-comment">//在外部类中，编写一个静态方法，返回 Inner08 对象</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance_</span> <span class="hljs-operator">=</span> Outer08.getInner08Instance_();<br>        <br>        inner08Instance.say();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer08</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><br>    <span class="hljs-comment">//1.定义在外部类的成员位置上</span><br>    <span class="hljs-comment">//2.可以添加任意访问修饰符，因为它就是一个成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner08</span> &#123;  <span class="hljs-comment">//成员内部类</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">66</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;n1=&quot;</span> + n1 + <span class="hljs-string">&quot; name=&quot;</span> + name + <span class="hljs-string">&quot; 外部类n1=&quot;</span> + Outer08.n1);  <span class="hljs-comment">//直接访问所有的静态成员</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Inner08 <span class="hljs-title function_">getInner08Instance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Inner08 <span class="hljs-title function_">getInner08Instance_</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//静态方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//使用成员内部类</span><br>        <span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>        inner08.say();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 方法</title>
    <link href="/2022/06/07/Java-%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/07/Java-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><p><strong>方法的返回值</strong> 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p><p>按照方法的返回值和参数类型将方法分为以下几种：</p><ul><li>无参数无返回值的方法</li><li>有参数无返回值的方法</li><li>有返回值无参数的方法</li><li>有返回值有参数的方法</li></ul><h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><h3 id="1）调用方式"><a href="#1）调用方式" class="headerlink" title="1）调用方式"></a>1）调用方式</h3><p>在外部调用静态方法时，可以使用<code>类名.方法名</code>的方式，也可以使用<code>对象.方法名</code>的方式[1]，而实例方法只有<code>对象.方法名</code>这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><h3 id="2）访问类成员是否存在限制"><a href="#2）访问类成员是否存在限制" class="headerlink" title="2）访问类成员是否存在限制"></a>2）访问类成员是否存在限制</h3><ul><li>静态方法在访问本类的成员时，<strong>只允许访问静态成员</strong>（即静态成员变量和静态方法），<strong>不允许访问实例成员</strong>（即实例成员变量和实例方法）</li><li>实例方法不存在以上这个限制。</li></ul><p>[1] 不建议使用 <code>对象.方法名</code> 的方式来调用静态方法，容易混淆。静态方法不属于类的某个对象而是属于这个类。</p><h2 id="静态方法为何不能调用非静态成员"><a href="#静态方法为何不能调用非静态成员" class="headerlink" title="静态方法为何不能调用非静态成员?"></a>静态方法为何不能调用非静态成员?</h2><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul><h1 id="方法重载和重写"><a href="#方法重载和重写" class="headerlink" title="方法重载和重写"></a>方法重载和重写</h1><p><strong>重载：</strong>java 允许同一个类中，多个同名方法的存在，但要求形参列表不一致。这样，同样的一个方法能够根据输入数据的不同，做出不同的处理。（好处：减轻了起名、记名的麻烦）</p><p><strong>重写：</strong>当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法。</p><h2 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h2><p>如果多个方法（比如 <code>StringBuilder</code> 的构造方法）有<strong>相同的名字</strong>、<strong>不同的参数</strong>， 便产生了<strong>重载</strong>。</p><p><strong>规则：</strong></p><ol><li>方法名：必须相同</li><li>形参列表：必须不同（形参类型 或 个数 或 顺序，至少一种不一样，参数名无所谓）</li><li>返回类型：无要求，不是方法重载的必要条件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br></code></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好（这个过程被称为**重载解析(overloading resolution)**）。Java 允许重载任何方法， 而不只是构造器方法。</p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><h2 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h2><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><p><strong>要求：</strong></p><ol><li><strong>方法名、参数列表</strong>必须相同。</li><li>子类方法<strong>返回值类型</strong>应比父类方法返回值类型更小或相等。</li><li><strong>抛出的异常范围</strong>小于等于父类。</li><li><strong>访问修饰符范围</strong>大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private</code>&#x2F;<code>final</code>&#x2F;<code>static</code> 则子类就不能重写该方法，但是被<code>static</code>修饰的方法能够被再次声明。</li><li>构造方法无法被重写。</li></ol><p><strong>综上：</strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》，<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892open in new window</a> ）：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>⚠关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><h2 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h2><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是<strong>允许在调用方法时传入不定长度的参数</strong>。</p><p>比如下面这个方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，可变参数<strong>只能作为函数的最后一个参数</strong>，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(String arg1, String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><ul><li>答案是会<strong>优先匹配固定参数的方法</strong>，因为固定参数的方法匹配度更高。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableLengthArgument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String s : args) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String arg1, String arg2)</span> &#123;<br>        System.out.println(arg1 + arg2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        printVariable(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        printVariable(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">ab<br>a<br>b<br>c<br>d<br></code></pre></td></tr></table></figure><p>另外，Java 的<strong>可变参数编译后实际会被转换成一个****数组</strong>，我们看编译后生成的 class文件就可以看出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableLengthArgument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String... args)</span> &#123;<br>        String[] var1 = args;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> args.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var3 &lt; var2; ++var3) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> var1[var3];<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h1><h2 id="方法递归调用内存分析"><a href="#方法递归调用内存分析" class="headerlink" title="方法递归调用内存分析"></a>方法递归调用内存分析</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8.png" alt="方法递归调用"></p><h2 id="重要规则"><a href="#重要规则" class="headerlink" title="重要规则"></a>重要规则</h2><ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li><li>方法的局部变量是独立的，不会相互影响</li><li>如果方法中使用的是引用类型变量（比如数组、对象），就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则将无限递归，出现<code>StackOverflowError</code>，死龟了</li><li>当一个方法执行完毕，或者遇到<code>return</code>，就会返回，遵守谁调用就将结果返回给谁，同时当方法执行完毕或返回时，该方法也就执行完毕。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一般形式</span><br>func(mode)&#123;    <br>    <span class="hljs-keyword">if</span>(endCondition) &#123;      <span class="hljs-comment">//递归出口</span><br>          end;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>         func(mode_small)  <span class="hljs-comment">//调用本身，递归</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经典算法题：八皇后问题</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>在 java 编程中，主要的变量就是<strong>属性（成员变量）</strong>和<strong>局部变量</strong>。</p><h2 id="java作用域的规则"><a href="#java作用域的规则" class="headerlink" title="java作用域的规则"></a>java作用域的规则</h2><p>属性和局部变量可以重名，访问时遵循就近原则</p><h2 id="全局变量（属性-成员变量）"><a href="#全局变量（属性-成员变量）" class="headerlink" title="全局变量（属性\成员变量）"></a>全局变量（属性\成员变量）</h2><ol><li>作用域为整个整体；</li><li>可以不赋值，直接使用（因为有默认值）；</li><li><strong>生命周期较长</strong>，伴随着对象创建而创建、销毁而销毁；</li><li>可以被本类使用，或其他类使用（通过对象调用）；</li><li>可以加修饰符。</li></ol><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ol><li>一般是指在成员方法内定义的变量。（后面讲的{代码块}中的变量也是局部变量），作用域为定义它的代码块中；</li><li>必须赋值后，才能使用（因为没有默认值）；</li><li><strong>生命周期较短</strong>，伴随它的代码块的执行而创建、结束而销毁，即在一次方法调用过程中；</li><li>只能在本类对应的方法中使用；</li><li>不可以加修饰符。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>           <br>        t1.test(); <span class="hljs-comment">// 第1种跨类访问对象属性的方式</span><br><br>                t1.test2(p1); <span class="hljs-comment">// 第2种跨类访问对象属性的方式</span><br><br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(p.name);<br>    &#125;    <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(Person p)</span> &#123;<br>        System.out.println(p.name);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;kobe&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="构造方法-x2F-构造器"><a href="#构造方法-x2F-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h1><p>构造方法，是类的一种特殊方法，主要作用是完成<strong>对新对象的初始化</strong>。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">访问修饰符 方法名(形参列表) &#123; 方法体<span class="hljs-comment">; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol><li><p>没有返回值（不用也不能写void）</p></li><li><p>方法名 和 类名 相同</p></li><li><p>参数列表 和 成员方法 一样的规则</p></li><li><p>构造器是完成对象的初始化，并不是创建对象</p></li><li><p>创建对象时，系统会自动调用该类的构造器</p></li><li><p>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器），比如 Person(){}。（可使用<code>javap</code>反编译看看）</p></li><li><ol><li><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E9%BB%98%E8%AE%A4%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="默认无参构造器"></li></ol></li><li><p>一旦自定义了构造器，默认的构造器就被覆盖，就不能再使用默认的无参构造器，除非显式定义一下，即：Dog(){} </p></li><li><ol><li><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="有参构造器"></li></ol></li></ol><hr><p>参考</p><ul><li>韩顺平Java基础课</li><li><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">Java基础常见面试题总结(上)</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基本语法</title>
    <link href="/2022/05/30/Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/05/30/Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、运算符"><a href="#一、运算符" class="headerlink" title="一、运算符"></a>一、运算符</h1><h2 id="算术运算符（重点看-x2F-）"><a href="#算术运算符（重点看-x2F-）" class="headerlink" title="算术运算符（重点看 &#x2F; % ++ ）"></a>算术运算符（重点看 &#x2F; % ++ ）</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="%运算符"></a>%运算符</h3><p><strong>作用：</strong>取模、取余</p><p><strong>本质：</strong><code>a % b = a - a / b * b</code> </p><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="++运算符"></a>++运算符</h3><p><strong>作用：</strong>自增</p><p>作为独立式使用</p><ul><li>前++和后++完全等价于<code>i = i + 1</code>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自增</span><br>i++;  <br><span class="hljs-comment">// 等价于 </span><br>++i;<br><span class="hljs-comment">// 等价于 </span><br>i = i + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>作为表达式使用</p><ul><li>前++（++i）： 先自增后赋值</li><li>后++（i++）： 先赋值后自增</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> ++j;  <span class="hljs-comment">//等价于 j=j+1; k=j; --&gt; j==9, k==9</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j++;  <span class="hljs-comment">//等价于 k=j; j=j+1;  --&gt; j==9, k==8</span><br></code></pre></td></tr></table></figure><p>面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//面试题1：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;             <span class="hljs-comment">//i -&gt; 1</span><br>i = i++;               <span class="hljs-comment">// 规则使用临时变量：(1)temp = i; (2)i = i + 1; (3)i = temp;</span><br>System.out.println(i)  <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">//面试题2：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;             <span class="hljs-comment">// i -&gt; 1</span><br>i = ++i;               <span class="hljs-comment">// (1)i = i + 1; (2)temp = i; (3)i = temp;</span><br>System.out.println(i)  <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// tips:自己给自己赋值要用到临时变量</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&lt;</th><th>&gt;</th><th>&lt;&#x3D;</th><th>&gt;&#x3D;</th><th>instanceof</th></tr></thead><tbody><tr><td>相等于</td><td>不等于</td><td>小于</td><td>大于</td><td>小于等于</td><td>大于等于</td><td>检查是否是类的对象</td></tr></tbody></table><p>结果都是boolean值，true 或 false</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>（1）短路与 &amp;&amp;，短路或 ||，取反 !</p><p>（2）逻辑与 &amp;，逻辑或 |，逻辑异或^</p><table><thead><tr><th>a</th><th>b</th><th>a&amp;b</th><th>a&amp;&amp;b</th><th>a|b</th><th>a||b</th><th>!a</th><th>a^b</th></tr></thead><tbody><tr><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>√</td><td>×</td><td>×</td><td>×</td><td>√</td><td>√</td><td>×</td><td>√</td></tr><tr><td>×</td><td>√</td><td>×</td><td>×</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>√</td><td>×</td></tr></tbody></table><ol><li>结果都是<code>boolean</code>值，<code>true</code> 或 <code>false</code></li><li>开发中一般使用短路操作 <code>&amp;&amp;</code> 和 <code>||</code>，效率高</li></ol><ul><li><ul><li>短路与<code>&amp;&amp;</code>：如果第一个条件为<code>false</code>，则第二个条件不会判断，最终结果为<code>false</code></li><li>短路或<code>||</code>：如果第一个条件为<code>true</code>，则第二个条件不会判断，最终结果为<code>true</code></li></ul></li></ul><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, y = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (x++==<span class="hljs-number">6</span> &amp; ++y==<span class="hljs-number">6</span>) &#123;  <span class="hljs-comment">//x先比较后自增，第一个条件为false，y先自增后比较，第二个条件为true</span><br>    x = <span class="hljs-number">11</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;x=&quot;</span> + x + <span class="hljs-string">&quot;,y=&quot;</span> + y);  <span class="hljs-comment">// x=6, y=6</span><br></code></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符就是将某个运算后的值，赋给指定的变量</p><ul><li>基本赋值运算符：<code>=</code></li><li>复合赋值运算符：<code>+=</code>，<code>-=</code>，<code>/=</code>，<code>%=</code> 等</li></ul><p>特点：</p><ol><li>左边是变量，右边可以是变量、表达式、常量值</li><li>a +&#x3D; b;  等价于 a &#x3D; a + b; 其他以此类推</li><li>复合赋值运算符会自动进行类型转换</li></ol><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>b += <span class="hljs-number">3</span>;  <span class="hljs-comment">// 等价于 b = (byte)(b + 3) </span><br>b++;     <span class="hljs-comment">// 等价于 b = (byte)(b + 1)</span><br></code></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为<code>true</code>，运算后的结果是表达式1；反之<code>false</code>结果为表达式2（口诀：一眼丁真）</p><p>示例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">24</span>;<br><br><span class="hljs-comment">// 由于true，执行了表达式1（a++），不执行表达式2（b--），</span><br><span class="hljs-comment">// 因此a先返回值给res再自增，b--不执行</span><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> a &lt; b ? a++ : b--;  <br><br>System.out.println(<span class="hljs-string">&quot;a=&quot;</span> + a + <span class="hljs-string">&quot;b=&quot;</span> + b + <span class="hljs-string">&quot;res=&quot;</span> + res)<br><span class="hljs-comment">//a=9，b=24，res=8</span><br></code></pre></td></tr></table></figure><p>细节：</p><ol><li>表达式1 和 表达式2 要为可以赋给接收变量的类型（或可以自动转换&#x2F; 或强制转换）</li><li>三元运算符本质是 if–else 语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> a &gt; b ? a++ : --b;<br>等价于<br><span class="hljs-keyword">if</span> (a &gt; b) res = a++;<br><span class="hljs-keyword">else</span> res = --b;<br></code></pre></td></tr></table></figure><p>⚠️<strong>区别：</strong></p><p>三元运算符是一个整体！if 和 else 是独立语句块！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于三元运算符是一个整体，表达式1 和 表达式2 要自动转换为同一种类型</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.0</span>);  <br>System.out.println(obj1);  <span class="hljs-comment">//输出：1.0</span><br><br><span class="hljs-comment">// 根据编译器提示： &quot;true ? new Integer(1) : new Double(2.0)&quot;   </span><br><span class="hljs-comment">// 可以简化为-&gt;  &quot;(double) new Integer(1)&quot;  </span><br><span class="hljs-comment">// 可以移除包装-&gt;   &quot;(double) 1&quot;</span><br><br><span class="hljs-comment">//---------------------------------------</span><br><br>Object obj2;<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)<br>    obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br>    obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.0</span>);<br>System.out.println(obj2);  <span class="hljs-comment">//输出：1</span><br></code></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p><h1 id="二、进制转换"><a href="#二、进制转换" class="headerlink" title="二、进制转换"></a>二、进制转换</h1><h2 id="整数的四种表达方式"><a href="#整数的四种表达方式" class="headerlink" title="整数的四种表达方式"></a>整数的四种表达方式</h2><p>二进制(BIN)：<code>0,1</code>，以<code>0b</code>或<code>0B</code>开头。                  <code>int n1 = 0b1010;</code></p><p>十进制(DEC)：<code>0-9</code>。                                  <code>int n2 = 1010;</code></p><p>八进制(OCT)：<code>0-7</code>，以数字<code>0</code>开头。                    <code>int n3 = 01010;</code></p><p>十六进制(HEX)：<code>0-9</code>及<code>A(10)-F(15)</code>；以<code>0x</code>或<code>0X</code>开头。  <code>int n4 = 0x10101;</code></p><h2 id="Java-进制转换"><a href="#Java-进制转换" class="headerlink" title="Java 进制转换"></a>Java 进制转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 十转二</span><br>bin_num = Integer.toBinaryString(dec_num);<br><span class="hljs-comment">// 十转八</span><br>oct_num = Integer.toOctalString(dec_num);<br><span class="hljs-comment">// 十转十六</span><br>hex_num = Integer.toHexString(dec_num);<br></code></pre></td></tr></table></figure><h2 id="二进制（八进制、十六进制）转十进制"><a href="#二进制（八进制、十六进制）转十进制" class="headerlink" title="二进制（八进制、十六进制）转十进制"></a>二进制（八进制、十六进制）转十进制</h2><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>2</strong>的（位数-1）次方，然后求和。</p><p>例：0b1011 &#x3D; 1 * 20 + 1 * 21 + 0 * 82 + 1 * 23 &#x3D; 1 + 2 + 0 + 8 &#x3D; 11</p><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>8</strong>的（位数-1）次方，然后求和。</p><p>例：0234 &#x3D; 4 * 80 + 3 * 81 + 2 * 82 &#x3D; 4 + 24 + 128 &#x3D; 156</p><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>16</strong>的（位数-1）次方，然后求和。</p><p>例：0x23A &#x3D; 10 * 160 + 3 * 161 + 2 * 162 &#x3D; 10 + 48 + 512 &#x3D; 570</p><h2 id="十进制转二进制（八进制、十六进制同理）"><a href="#十进制转二进制（八进制、十六进制同理）" class="headerlink" title="十进制转二进制（八进制、十六进制同理）"></a>十进制转二进制（八进制、十六进制同理）</h2><p>“<strong>除2取余，逆序排列</strong>”：将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来。</p><p>例：十进制34转成二进制：  &#x3D;0B00100010</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="十进制转二进制"></p><h2 id="二进制转八进制（十六进制）"><a href="#二进制转八进制（十六进制）" class="headerlink" title="二进制转八进制（十六进制）"></a>二进制转八进制（十六进制）</h2><p>从低位开始，将二进制数每三位（每四位）一组，转成对应的八进制（十六进制）数即可。</p><p>例：0b1101(D)0101(5) &#x3D; 0xD5</p><p><strong>二转十六进制诀窍：</strong>二进制每四位视为“8421”码，1101即为1个8，1个4，0个2，1个1相加，结果为13，即D</p><h2 id="八进制（十六进制）转二进制"><a href="#八进制（十六进制）转二进制" class="headerlink" title="八进制（十六进制）转二进制"></a>八进制（十六进制）转二进制</h2><p>将<strong>八进制</strong>数每1位，转成对应的一个<font color="red">3</font>位二进制数。</p><p>例：0237转成二进制：0<font color="green">2(010)</font><font color="orange">3(011)</font><font color="blue">7(111)</font> &#x3D; 0b10011111</p><p>将<strong>十六进制</strong>数每1位，转成对应的一个<font color="red">4</font>位二进制数。</p><p>例：0x23B转成二进制：0x<font color="green">2(0010)</font><font color="orange">3(0011)</font><font color="blue">B(1011)</font> &#x3D; 0b001000111011 （快速计算”B”的二进制技巧：11 &#x3D; 15(1111) - 4(0100) &#x3D; B &#x3D; 11(1011) ）</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>原码表示范围：-127~127</p><p>反码表示范围：-127~127</p><p>补码表示范围：-128~127</p><p><strong>总结</strong>：</p><ol><li>二进制的最高位是符号位：0表示正数，1表示负数（）</li><li>正数的原码、反码、补码都一样（正数三码合一）</li><li>负数的反码 &#x3D; 它的原码符号位不变，其他位取反（0-&gt;1 1-&gt;0）</li><li>负数的补码 &#x3D; 它的反码 + 1（负数的反码 &#x3D; 它的补码 - 1）（补 &#x3D; 反 + 1）</li><li>负数的原码 &#x3D; 【它的反码 符号位不变，其他位取反】 &#x3D; 【（它的补码 - 1）符号位不变，其他位取反】&#x3D; 【它的绝对值(正数)的原码符号位变为0】</li><li>负数 &#x3D; 其绝对值的原码最高位取1（原码）的 补码（原码取反+1）</li><li>0的反码、补码都是0</li><li>java没有无符号数</li><li>在计算机运算的时候，都是以补码的方式来运算的</li><li>当我们看<strong>运算结果</strong>时，要看它的原码</li></ol><p><strong>计算机中，负数表达形式</strong></p><p>负数二进制以补码形式表达，</p><ol><li>把这个负数的绝对值转换为二进制，即求原码 （ |-24| &#x3D; 24 &#x3D; 00011000 ）</li><li>把原码取反，即求反码（ ~00011000 &#x3D; 11100111 ）</li><li>把反码加1，即求补码（ 11101000 &#x3D; -24(补码) ）</li></ol><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol><li>java中7个位运算：&amp;、|、^、~、&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;</li><li>按位与&amp;：两位为1，结果为1，否则为0</li><li>按位或|：有一个为1，则结果为1，否则为0</li><li>按位异或^：同0异1</li><li>按位取反~：0变1，1变0</li></ol><p><strong>示例：</strong></p><p>求<code>~-2</code>的结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(~-<span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ol><li>先得到-2的原码：10000000 00000000 00000000 00000010</li><li>再得-2的反码：  11111111 11111111 11111111 11111101（&#x3D;原码符号位不变，其他位取反）</li><li>再得-2的补码：  11111111 11111111 11111111 11111110（&#x3D;反码+1）</li><li><del>-2操作：       00000000 00000000 00000000 00000001（</del>-2：对-2的补码进行取反操作）</li><li>运算后的原码：   00000000 00000000 00000000 00000001（1）</li></ol><p><strong>示例：</strong></p><p>求<code>~2</code>的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(~<span class="hljs-number">2</span>); <span class="hljs-comment">//-3</span><br></code></pre></td></tr></table></figure><ol><li>先得到2的补码：00000000 00000000 00000000 00000010（正数三码都一样）</li><li><del>2操作：       11111111 11111111 11111111 11111101（运算后的补码）（</del>2：对2的补码进行取反操作）</li><li>运算后的反码：  11111111 11111111 11111111 11111100（负数反码 &#x3D; 它的补码-1）</li><li>运算后的原码：   10000000 00000000 00000000 00000011（-3）</li></ol><p>算术右移<code>&gt;&gt;</code>：向右移若干位，符号位不变，低位溢出丢弃，高位补符号位（符号位补溢出的高位，即正数高位补 0，负数高位补 1）</p><p><code>x &gt;&gt; n</code>，相当于 x 除以 2 的 n 次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-number">15</span>&gt;&gt;<span class="hljs-number">2</span>;<br><span class="hljs-comment">// 15 =&gt; 0000 1111 =&gt; 0000 0011 </span><br><span class="hljs-comment">// 本质 15 / 2 / 2 = 3 </span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> -<span class="hljs-number">15</span> &gt;&gt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 1111 0001 &gt;&gt; 0000 0010 = 1111 1100(-4)</span><br></code></pre></td></tr></table></figure><p>算术左移<code>&lt;&lt;</code>：向左移若干位，符号位不变，低位补0，高位丢弃。</p><p><code>x &lt;&lt; n</code>，相当于 x 乘以 2 的 n 次方(不溢出的情况下)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">3</span>; <br><span class="hljs-comment">//4 =&gt; 0000 0100 -&gt; 0010 0000 </span><br><span class="hljs-comment">// (本质 4 * 2 * 2 * 2 = 32) (4&lt;&lt;3 =&gt; 4 * 2^3)</span><br></code></pre></td></tr></table></figure><p>无符号右移<code>&gt;&gt;&gt;</code>：忽略符号位，空位都以0补齐。</p><p>移位操作符实际上只支持<code>int</code>和<code>long</code>类型，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p><h2 id="移位的位数超过数值所占有的位数"><a href="#移位的位数超过数值所占有的位数" class="headerlink" title="移位的位数超过数值所占有的位数"></a>移位的位数超过数值所占有的位数</h2><p>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。</p><p>也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0），左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。</p><p>当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p><p>也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x &gt;&gt;&gt;42</code>等同于<code>x &gt;&gt;&gt; 10</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>System.out.println(<span class="hljs-string">&quot;初始数据：&quot;</span> + i);<br>System.out.println(<span class="hljs-string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));<br>i &lt;&lt;= <span class="hljs-number">42</span>;  <span class="hljs-comment">// 等价于 i &lt;&lt;= 10; 42 % 32 = 10</span><br>System.out.println(<span class="hljs-string">&quot;左移 10 位后的数据 &quot;</span> + i);  <br>System.out.println(<span class="hljs-string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">初始数据：-<span class="hljs-number">1</span><br>初始数据对应的二进制字符串：<span class="hljs-number">11111111111111111111111111111111</span><br>左移 <span class="hljs-number">10</span> 位后的数据 -<span class="hljs-number">1024</span><br>左移 <span class="hljs-number">10</span> 位后的数据对应的二进制字符 <span class="hljs-number">11111111111111111111110000000000</span><br></code></pre></td></tr></table></figure><h2 id="问题：为何使用原码、反码、补码"><a href="#问题：为何使用原码、反码、补码" class="headerlink" title="问题：为何使用原码、反码、补码"></a>问题：为何使用原码、反码、补码</h2><p>我们上面说过，原码、反码、补码的表示对于正数来说都是一样的，而对于负数来说，三种码的表示确是完全不同的，那大家是否会有个疑问：如果原码才是我们人类可以识别并用于直接计算的表示方式，那为什么还会有反码和补码？计算机直接存储原码不就完事了？</p><p>在解决这些问题前，我们先来了解计算机的底层概念，我们人脑可以很轻松的知道机器数的第一位是符号位，但对于计算机基础电路设计来说判别第一位是符号位是非常难和复杂的事情，为了让计算机底层设计更加简单，人们开始探索将符号位参与运算，并且采用只保留加法的方法，我们知道减去一个数，等于加上这个数的负数，即：1-1 &#x3D; 1 + (-1) &#x3D; 0，这样让计算机运算就更加简单了，并且也让符号位参与到运算中去。</p><p><strong>使用原码运算</strong></p><p>计算十进制表达式：<code>1-1 = 0</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 原：[ 1000 0010 ] &#x3D; -2</p><p>如果用原码表示，让符号位也参与计算，对于减法来说，结果是不正确的。这也是计算机内部在存储数据时不使用原码的原因，为了解决这一问题，出现了反码。</p><p><strong>使用反码运算</strong></p><p>计算十进制表达式：<code>1-1 = 0</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 反：[ 0000 0001 ] + 反：[ 1111 1110 ]</p><p>&#x3D; 反：[ 1111 1111 ] &#x3D; 原： [ 1000 0000 ] &#x3D; -0</p><p>通过计算我们发现用反码计算减法，结果的真值部分是正确的。而唯一的问题出现在”0”这个特殊的数值上，虽然人们理解上**+0和-0**是一样的，但是0带符号是没有任何意义的，而且会有 [0000 0000] 原和 [1000 0000] 原两个编码表示0。为了解决这一问题，出现了补码。</p><p><strong>使用补码运算</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 补：[ 0000 0001 ] + 补：[ 1111 1111 ]</p><p>&#x3D; 补： [ 0000 0000 ] &#x3D; 原： [ 0000 0000 ] &#x3D; 0</p><p>这样0用 [0000 0000] 表示，而以前出现问题的-0则不存在了，而且人们还发现可以用[1000 0000]表示-128，-128的推算过程如下：</p><p>(-1) + (-127) &#x3D; -128</p><p>&#x3D; 原：[1000 0001] + 原：[ 1111 1111 ]</p><p>&#x3D; 补：[ 1111 1111 ] + 补：[ 1000 0001 ]</p><p>&#x3D; 补：[ 1000 0000 ]</p><p><strong>注意：</strong>因为实际上是使用以前的-0的补码来表示-128，所以**-128并没有原码和反码表示**，只要补码是[1000 0000]，其十进制数值就为-128。</p><p>因为补码能多存储一个-128，而且在计算机底层中存储的是补码，所以在计算机中一个8位的二进制数的存储范围是用补码表示的[-128,127]，而不是用原码或反码表示的[-127,127]。这也可以解释为什么计算机中一个字节的取值范围是[-128,127]。</p><p>这样也能够回答我们开始提出的问题了，原码、反码、补码的使用，是人们<strong>为了让符号位能参与运算并让计算机底层运算更加简单</strong>而设计出来的数据存储表示方式。</p><h1 id="三、标识符与关键字"><a href="#三、标识符与关键字" class="headerlink" title="三、标识符与关键字"></a>三、标识符与关键字</h1><p>标识符就是一个名字。（标识符：阿牛茶餐厅、美宜佳）</p><p>关键字是被赋予特殊含义的标识符。（关键字：医院、警察局、学校…）</p><p><code>default</code>关键字</p><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul><p>⚠️ 注意：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p><p>官方文档：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java提供了四种访问控制修饰符号，用于控制方法和属性的访问权限：</p><ol><li>公开级别：用<code>public</code>修饰，对外公开；</li><li>受保护级别：用<code>protected</code>修饰，对子类和同一个包中的类公开；</li><li>默认级别：没有修饰符号，向同一个包的类公开；</li><li>私有级别：用<code>private</code>修饰，只有类本身可以访问，不对外公开。</li></ol><h3 id="访问范围"><a href="#访问范围" class="headerlink" title="访问范围"></a>访问范围</h3><table><thead><tr><th>访问级别</th><th>访问控制修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>公开</td><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>受保护</td><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>默认</td><td>-</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>私有</td><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>修饰符可以用来修饰类中的属性、成员方法以及类；</li><li>只有默认的和<code>public</code>才能修饰类，并且遵循上述访问权限的特点</li><li>子类</li><li>成员方法的访问规则和属性一样</li></ol><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>可以修饰类、属性、方法、局部变量。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>1）当不希望类被继承时；</p><p>2）不希望父类的某个方法被子类覆盖&#x2F;重写override时；</p><p>3）当不希望类的某个属性的值被修改时；</p><p>4）当不希望某个局部变量被修改时。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>1）<code>final</code>修饰的属性又叫常量，一般用XX_XX_XX命名</p><p>2）<code>final</code>修饰的属性在定义时，必须赋初值，赋值可以在类定义属性时、构造器中、代码块中；</p><p>3）如果<code>final</code>修饰的属性是静态的，则初始化的位置只能是定义时、在静态代码块中（不能在构造器中赋值）</p><p>4）如果一个类已经是<code>final</code>类，就没有必要将方法修饰成<code>final</code>了。</p><p>5）<code>final</code>不能修饰构造器。</p><p>6）<code>**final**</code><strong>和</strong><code>**static**</code><strong>往往搭配使用，不会导致类加载（底层编译器做了优化处理），效率更高</strong>。</p><p>7）包装类（<code>Integer</code>、<code>Double</code>等都是<code>final</code>），<code>String</code>也是<code>final</code>类。</p><h1 id="四、控制结构"><a href="#四、控制结构" class="headerlink" title="四、控制结构"></a>四、控制结构</h1><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><p>程序从上到下逐行执行，中间没有任何判断和跳转。</p><p>Java定义变量时采用合法的前向引用。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="分支控制if-else"><a href="#分支控制if-else" class="headerlink" title="分支控制if-else"></a>分支控制if-else</h2><p>让程序有选择的执行，分支控制有三种（单分支、双分支、多分支）</p><p>嵌套分支：分支嵌套最好不要超过3层（可读性差）</p><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单分支：当条件表达式为true时，就会执行&#123; &#125;的代码。（如果&#123;&#125;中只有一条语句，可以省略&#123;&#125;，但建议写上）</span><br><span class="hljs-keyword">if</span>(条件表达式)&#123;<br>    执行代码块;<br>&#125;<br><br><span class="hljs-comment">//双分支：当条件表达式为true时，就会执行&#123;代码块1&#125;，否则执行&#123;代码块2&#125;。（如果&#123;代码块&#125;中只有一条语句，可以省略&#123;&#125;，但建议写上）</span><br><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    代码块<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    代码块<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">//多分支：当条件表达式1为true时，就会执行&#123;代码块1&#125;，当条件表达式1为false时，再判断条件表达式2是否成立，以此类推，都不成立则执行&#123;代码块n&#125;。（多分支可以没有else）</span><br><span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">1</span>) &#123;<br>    代码块<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123;<br>    代码块<span class="hljs-number">2</span>;<br>&#125;<br>......<br><span class="hljs-keyword">else</span> &#123;<br>    代码块n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="switch分支结构"><a href="#switch分支结构" class="headerlink" title="switch分支结构"></a>switch分支结构</h2><p><strong>规则：</strong></p><ol><li>case 语句中的<code>value</code>的数据类型必须与表达式变量的数据类型相同，而且只能是<strong>常量</strong>或者<strong>字面常量；</strong>（或是表达式可以自动转换成可以与<code>case</code>的<code>value</code>相互比较的类型。）</li><li>switch表达式中的返回值必须是：<code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code>、<code>enum</code>、<code>String</code>；</li><li>表达式对应一个值；</li><li>当变量的值与 <code>case</code> 语句的值相等时，那么 <code>case</code> 语句之后的语句开始执行，直到 <code>break</code> 语句出现才会跳出 switch 语句；</li><li><code>case</code>常量1：当表达式的值等于<code>value1</code>，就执行语句块1；如果没有匹配<code>value1</code>，就继续匹配case <code>value2</code>；如果一个都没匹配上，执行<code>default</code>；</li><li><code>case</code> 语句不必须要包含 <code>break</code> 语句。如果没有 <code>break</code> 语句出现，程序会继续执行下一条 <code>case</code> 语句，直到出现 <code>break</code> 语句。（穿透）。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (expression) &#123;<br>    <span class="hljs-keyword">case</span> value1:<br>        <span class="hljs-comment">//语句块1;  //可省略</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value2:<br>        <span class="hljs-comment">//语句块2;</span><br>    <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//default语句块;</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/switch%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="switch控制结构"></p><h2 id="for-循环控制"><a href="#for-循环控制" class="headerlink" title="for 循环控制"></a>for 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>循环初始值可以有多个，但类型必须相同；</li><li>初始化和变量迭代可以写到其他地方，但是分号不能省略；（见示例）</li><li>循环条件是布尔表达式。</li><li>循环四要素：循环变量初始化；循环条件；循环语句；循环变量迭代。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(循环变量初始化; 循环条件(布尔表达式); 循环变量迭代/更新) &#123;<br>    <span class="hljs-comment">//循环操作（可以多条）;</span><br>&#125;<br><br><span class="hljs-comment">//示例：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//变量初始化（变量i的作用域更大）</span><br><span class="hljs-keyword">for</span> (; i&lt;<span class="hljs-number">10</span>; ) &#123;<br>    System.out.println(<span class="hljs-string">&quot;shit&quot;</span> + i);<br>    i++;  <span class="hljs-comment">//变量迭代</span><br>&#125;<br><span class="hljs-comment">//补充</span><br><span class="hljs-keyword">for</span>(;;)&#123; <span class="hljs-comment">//死循环</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for-each-循环（增强for）"><a href="#for-each-循环（增强for）" class="headerlink" title="for each 循环（增强for）"></a>for each 循环（增强for）</h2><p>foreach 循环语句是 Java1.5 的新特征之一，在遍历数组、集合方面，foreach 为开发者提供了极大的方便。foreach 循环语句是 for 语句的特殊简化版本，主要用于执行遍历功能的循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (元素类型 元素变量名x : 遍历对象obj) &#123;   <span class="hljs-comment">// 快捷键：大写I + 回车</span><br>    <span class="hljs-comment">//引用了x的java语句; </span><br>&#125; <br></code></pre></td></tr></table></figure><p>其中，“类型”为元素的类型，“元素变量名”表示对象的每一个元素，“遍历对象”表示被遍历的对象，如集合。</p><p>每执行一次循环语句，循环变量就读取集合中的一个元素。</p><h2 id="while-循环控制"><a href="#while-循环控制" class="headerlink" title="while 循环控制"></a>while 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>while循环是先判断 再执行语句；</li><li>只要布尔表达式为 true，循环就会一直执行下去；</li><li>循环条件是布尔表达式；</li><li>也有循环四要素。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//循环变量初始化</span><br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>) &#123;  <span class="hljs-comment">//循环条件</span><br>    xxx  <span class="hljs-comment">//循环体（语句）</span><br>    i++;  <span class="hljs-comment">//循环变量迭代</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="do…while-循环控制"><a href="#do…while-循环控制" class="headerlink" title="do…while 循环控制"></a>do…while 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>do while 是关键字；</li><li>先执行，再判断，也就是说，一定会至少执行一次；</li><li>也有四要素，只是位置不一样；</li><li>最后有一个分号。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>    System.out.print(<span class="hljs-string">&quot;value of x : &quot;</span> + x ); <span class="hljs-comment">//循环体（语句）</span><br>    x++; <span class="hljs-comment">//循环变量迭代</span><br>&#125; <span class="hljs-keyword">while</span>(x &lt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//(循环条件)</span><br></code></pre></td></tr></table></figure><h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体。</p><p>当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次循环。</p><p>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次</p><h2 id="continue、break-和-return"><a href="#continue、break-和-return" class="headerlink" title="continue、break 和 return"></a><code>continue</code>、<code>break</code> 和 <code>return</code></h2><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ol><h3 id="break-跳转控制语句"><a href="#break-跳转控制语句" class="headerlink" title="break 跳转控制语句"></a>break 跳转控制语句</h3><p>主要用在循环语句或者 switch 语句中，用来跳出整个语句块</p><p>break语句出现仔多层嵌套的语句块中时，可以通过标签指明要终止的哪一层语句块。</p><p><strong>注意事项：</strong></p><ol><li>break语句可以指定退出哪一层；</li><li>label1是标签，名字由程序员指定；</li><li>break 后指定到哪个label 就退出到哪里；</li><li>在实际开发中，尽量不要用标签；</li><li>如果没有指定，break默认退出最近的循环体。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>lable1:<br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ ) &#123;<br><br>lable2:<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ ) &#123;<br>        <span class="hljs-keyword">if</span>( j == <span class="hljs-number">2</span> )&#123;<span class="hljs-keyword">break</span>;&#125;  <span class="hljs-comment">//等价于 break lable2</span><br>        System.out.print(j);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-number">01010101</span><br><span class="hljs-comment">//（如果break label1; 则输出结果为：01）</span><br></code></pre></td></tr></table></figure><h3 id="跳转控制语句-continue"><a href="#跳转控制语句-continue" class="headerlink" title="跳转控制语句 continue"></a>跳转控制语句 continue</h3><p><strong>基本规则：</strong></p><ol><li>continue 语句用于结束本次循环，继续执行下一次循环（作用是让程序立刻跳转到下一次循环的迭代）</li><li>continue 语句出现在多层嵌套循环语句体中时，可以通过标签指明要跳过的是哪一层循环（实际开发仍不建议使用）</li><li>在 for 循环中，continue 语句使程序立即跳转到更新语句。（i++）</li><li>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。（i&gt;0）</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] numbers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br><br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i : numbers ) &#123;<br>    <span class="hljs-keyword">if</span>( i == <span class="hljs-number">4</span> ) &#123;<br>        <span class="hljs-keyword">continue</span>;    <br>    &#125;<br>    System.out.print(i);<br>&#125;<br><span class="hljs-comment">//输出：1235678</span><br></code></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><ul><li>当<code>return</code>用在方法时，表示跳出方法；</li><li>如果用在main方法，表示退出程序。</li></ul><h1 id="六、注释"><a href="#六、注释" class="headerlink" title="六、注释"></a>六、注释</h1><p>Java 中的注释有三种：</p><ul><li><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</li><li><strong>多行注释</strong>：通常用于解释一段代码的作用。（不常用）</li><li><strong>文档注释</strong>：通常用于生成 Java 开发文档。</li></ul><p>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数据类型</title>
    <link href="/2022/05/25/Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/05/25/Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li><p>6 种数字类型：</p></li><li><ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li><p>1 种字符类型：<code>char</code></p></li><li><p>1 种布尔型：<code>boolean</code></p></li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th>类型</th><th>占用存储空间</th><th>默认值</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>byte</td><td>1byte</td><td>0</td><td>-27-128</td><td>27 - 1127</td></tr><tr><td>short</td><td>2byte</td><td>0</td><td>-215-32768</td><td>215 - 132767</td></tr><tr><td>int</td><td>4byte</td><td>0</td><td>-231-2147483648</td><td>231 - 12147483647</td></tr><tr><td>long</td><td>8byte</td><td>0L</td><td>-263……</td><td>263 - 1……</td></tr><tr><td>float</td><td>4byte</td><td>0.0f</td><td>-1.4E-45 -3.403E38</td><td>3.4028235E38</td></tr><tr><td>double</td><td>8byte</td><td>0.0d</td><td>-1.798E308</td><td>1.7976931348623157E308</td></tr><tr><td>char</td><td>2byte</td><td>‘u0000’</td><td>0 \u0000</td><td>65535（216- 1）\uffff</td></tr><tr><td>boolean</td><td>1bit</td><td>false</td><td>false</td><td>true</td></tr></tbody></table><p>像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都 <strong>-1</strong> 了。这是为什么呢？</p><p>这是因为在<strong>二进制补码表示法</strong>中，<strong>最高位是用来表示符号的</strong>（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。</p><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。</p><h2 id="整型-byte、short、int、long"><a href="#整型-byte、short、int、long" class="headerlink" title="整型 - byte、short、int、long"></a>整型 - byte、short、int、long</h2><p><code>byte</code>：字节（1byte）：8位、有符号的，以二进制补码表示的整数</p><p><code>short</code>：短整型（2byte）：16 位、有符号的，以二进制补码表示的整数</p><p><code>int</code>：整型（4byte）：32位、有符号的，以二进制补码表示的整数</p><p><code>long</code>：长整型（8byte）：64 位、有符号的，以二进制补码表示的整数</p><h3 id="整型的使用细节"><a href="#整型的使用细节" class="headerlink" title="整型的使用细节"></a>整型的使用细节</h3><ol><li>Java 的整型常量默认为 <code>int</code> 型，声明 long 型常量须在后加<code>l</code>或<code>L</code>；</li><li>Java 程序中变量声常明为 <code>int</code> 型，除非不足以表示大数，才使用 <code>long</code>；</li><li><code>bit</code>: 计算机中的最小存储单位。 <code>byte</code>: 计算机中基本存储单元，<code>1byte = 8bit</code>。</li></ol><h2 id="浮点型-float、double"><a href="#浮点型-float、double" class="headerlink" title="浮点型 - float、double"></a>浮点型 - float、double</h2><p><code>float</code>：4byte：单精度、32位、符合IEEE 754 标准的浮点数</p><p><code>double</code>：8byte：双精度、64 位、符合 IEEE 754 标准的浮点数</p><h3 id="浮点型使用细节"><a href="#浮点型使用细节" class="headerlink" title="浮点型使用细节"></a>浮点型使用细节</h3><ol><li>浮点数在机器中存放形式，浮点数 &#x3D; 符号位 + 指数位 + 尾数位</li><li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li><li>浮点数默认为<code>double</code>类型，声明<code>float</code>型须在后面加上<code>f</code>或<code>F</code>。（数值加<code>d</code>表示<code>double</code>类型）</li><li>浮点数有两种表示形式：</li></ol><ul><li><ul><li>十进制数形式：如5.12 512.0f .512</li><li>科学计数法形式：如5.12e2（5.12*10^2）</li><li>科学记数法：结尾的”E+数字”表示E之前的数字要乘以10的多少次方。比如，3.14E-3就是3.14 x 10-3 &#x3D;0.00314。</li></ul></li></ul><ol><li>通常使用<code>double</code>型，精度更高</li><li>比较浮点数的时候，不能使用“<code>==</code>”操作符。（计算机 内存存储浮点数使用IEEE754标准，存在精度问题，在存储计算过程中容易引起较小的舍入误差）</li></ol><ul><li><ul><li>使用Math.abs() 方法来计算两个浮点数之间差异的绝对值，如果这个差异在阈值范围之内，我们就认为两个浮点数是相等的。如：Math.abs(num1 - num2) &lt; 0.0001</li><li>使用 BigDecimal 类的 compareTo() 方法对两个数进行比较，该方法将会忽略小数点后的位数。见示例1。（比如说 2.0 和 2.00 的位数不同，但它俩的值是相等的）</li></ul></li></ul><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.0&quot;</span>);<br><br>System.out.println(a.equals(b));  <span class="hljs-comment">//false</span><br>System.out.println(a.compareTo(b) == <span class="hljs-number">0</span>);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="字符型-char"><a href="#字符型-char" class="headerlink" title="字符型 - char"></a>字符型 - char</h2><p><code>char</code>：2byte：单一的 16 位 Unicode 字符</p><h3 id="字符型使用细节"><a href="#字符型使用细节" class="headerlink" title="字符型使用细节"></a>字符型使用细节</h3><ol><li><code>char</code>用单引号<code>&#39; &#39;</code>，<code>String</code>字符串用双引号<code>&quot; &quot;</code></li><li>转义字符 ‘<code>\</code>‘ ，将其后的字符转变为特殊字符型常量。如：<code>char c = &#39;\n&#39;</code></li><li>Java 中，<code>char</code>本质是一个整数，输出时是 unicode 编码对应的字符（因此可直接赋值<code>char</code>一个整数）</li></ol><ul><li><ul><li>Unicode与中文之间的相互转换工具：<a href="https://www.w3cschool.cn/tools/index?name=unicode_chinese">在线Unicode&#x2F;中文转换工具 - 编码转换工具 - W3Cschool</a></li><li><a href="http://tool.chinaz.com/Tools/Unicode.aspx">Unicode编码转换 - 站长工具</a></li></ul></li></ul><ol><li>由3.可得，<code>char</code>类型可进行运算。</li><li>字符型存储到计算机中，需要找到字符对应的码值（整数），比如<code>&#39;a&#39;</code>：</li></ol><ul><li><ul><li>存储：<code>&#39;a&#39;</code> –&gt; 码值 97 –&gt; 二进制 0110 0001 –&gt; 存储</li></ul></li></ul><ol><li>字符编码表：</li></ol><ul><li><ul><li>- ASCII 编码表 1 个字节表示，一个128个字符（实际上一个字节可以表示256个字符，只用了128个）</li><li>Unicode 编码表 固定大小的编码，使用 2 个字节表示，字母和汉字统一占用 2 个字节（但这样浪费空间）。（Unicode兼容ASCII）</li><li>utf-8 编码表：大小可变的编码，使用1-6个字节表示一个符号，字母使用 1 个字节，汉字使用 3 个字节（实际开发用得最多）（Unicode的改进方式，互联网使用最广）</li><li>gbk 可以表示汉字，范围广，字母使用 1 个字节，汉字使用 2 个字节</li><li>gb2312 可以表示汉字，gb2312 &lt; gbk</li><li>big5 码，繁体中文，tw hk</li></ul></li></ul><h2 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型 - boolean"></a>布尔型 - boolean</h2><p><code>boolean</code>：1bit： 1 位，作为一种标志来记录 true&#x2F;false 情况</p><p>（准确讲是1byte，计算机处理数据的最小单位是 1 个字节）</p><p>事实上：boolean 占用多少字节取决于虚拟机本身的实现，《Java 虚拟机规范》提议：</p><ul><li>如果 boolean 是 “单独使用”：boolean 被编译为 int 类型，占 4 个字节</li><li>如果 boolean 是以 “boolean 数组” 的形式使用：boolean 占 1 个字节</li></ul><h3 id="布尔型细节"><a href="#布尔型细节" class="headerlink" title="布尔型细节"></a>布尔型细节</h3><ol><li>Java中不可以用 0 或者非 0 整数替代 false 和 true，这点和C、php等语言不同。</li></ol><h1 id="Java-类型转换"><a href="#Java-类型转换" class="headerlink" title="Java 类型转换"></a>Java 类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>自动类型转换：</strong>低精度数据类型 自动转换为 高精度数据类型：</p><ul><li>char –&gt; int –&gt; long –&gt; float –&gt; double</li><li>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</li></ul><p><strong>示例2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span>;  <span class="hljs-comment">//true char --&gt; int</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;  <span class="hljs-comment">//true int --&gt; double</span><br></code></pre></td></tr></table></figure><h3 id="自动类型转换细节"><a href="#自动类型转换细节" class="headerlink" title="自动类型转换细节"></a>自动类型转换细节</h3><ol><li>多种类型得数据混合运算时，系统自动将所有数据转换成精度（容量）最大的数据类型，然后再进行计算：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1.2</span>;  <span class="hljs-comment">//double 11.2</span><br></code></pre></td></tr></table></figure><ol><li>当把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错。</li><li>（<code>byte</code>, <code>short</code>） 和 <code>char</code> 之间不会相互自动转换。</li><li><code>byte</code>, <code>short</code>, <code>char</code> 三者可以计算，在计算时首先转换为 <code>**int**</code> 类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b1 + s;     <span class="hljs-comment">// √ 因为：b1 + s =&gt; int</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> b1 + b2;  <span class="hljs-comment">// × 因为：b1 + b3 =&gt; int</span><br></code></pre></td></tr></table></figure><ol><li>boolean 不参与转换</li><li>自动提升原则：表达式结果的类型自动提升为<strong>操作数中最大的类型</strong>。</li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。需要加上强制转换符()，但可能造成精度降低或溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(s + b);  <span class="hljs-comment">//由于(s+b)=&gt;int，因此要强制转换成short才不报错</span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型和String类型的转换"><a href="#基本数据类型和String类型的转换" class="headerlink" title="基本数据类型和String类型的转换"></a>基本数据类型和String类型的转换</h3><ol><li><strong>基本类型转String类型</strong></li></ol><p>方法：直接拼接个双引号””</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><ol><li><strong>String类型转基本类型</strong></li></ol><p>方法：通过基本类型的包装类调用<code>parseXX</code>方法即可（每一个基本类型都对应一个包装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;24&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br></code></pre></td></tr></table></figure><p><code>String</code>转换成<code>char</code> &#x3D;&#x3D;&gt; 得到字符串的第一个字符 （利用<code>charAt(n)</code>方法，将字符串的第<code>n</code>个字符取出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(s.charAt(<span class="hljs-number">0</span>))  <span class="hljs-comment">//s.charAt(0) 得到字符串s的第一个字符&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure><ol><li><strong>注意</strong></li></ol><ul><li>将<code>String</code>类型转成基本数据类型时，要确保<code>String</code>类型能够转成有效的数据，比如可以把<code>&quot;123&quot;</code>转成一个整数，但是不能把<code>&quot;shit&quot;</code>转成一个整数。</li><li>如果格式不正确，就会抛出异常，程序终止。</li></ul><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul><li>在进行基本的数据计算时，开发者可以直接使用基本数据类型。</li><li>但是当需要和Java其他对象结合使用，如存入集合中，就需要将基础数据类型实例封装为Java对象，</li><li>为了面向对象的这一特性，基本数据类型中的每一个类型在<code>java.lang</code>包中都有一个包装类，即将每个基本类型都包装成了一个类。八种基本类型对应包装类：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</li></ul><hr><table>    <tr>        <td>基本数据类型</td>        <td>包装类</td>        <td>接口</td>        <td>父类</td>        <td>接口</td>        <td>父类</td>    </tr>    <tr>        <td>boolean</td>        <td>Boolean</td>        <td rowspan="8">Comparable</td>        <td rowspan="2">—</td>        <td rowspan="8">Serializable</td>        <td rowspan="8">Object</td>    </tr>    <tr>        <td>char</td>        <td>Character</td>    </tr>    <tr>        <td>byte</td>        <td>Byte</td>        <td rowspan="6">Number</td>    </tr>    <tr>        <td>short</td>        <td>Short</td>    </tr>    <tr>        <td>int</td>        <td>Integer</td>    </tr>    <tr>        <td>long</td>        <td>Long</td>    </tr>    <tr>        <td>float</td>        <td>Float</td>    </tr>    <tr>        <td>double</td>        <td>Double</td>    </tr></table><h2 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h2><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中 [1]。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p>[1] 为什么说是<strong>几乎</strong>所有对象实例都存在于堆中呢？ </p><p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>更多参考：<a href="https://www.yuque.com/kingshit/java/khlmi9x1su7i6vr6">JIT逃逸分析</a></p><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 成员变量，存放在堆中</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">// 被 static 修饰，也存放在堆中，但属于类，不属于对象</span><br>    <span class="hljs-comment">// JDK1.7 静态变量从永久代移动了 Java 堆中</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 局部变量，存放在栈中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>; <span class="hljs-comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本数据类型和包装类转换"><a href="#基本数据类型和包装类转换" class="headerlink" title="基本数据类型和包装类转换"></a>基本数据类型和包装类转换</h2><ol><li>jdk5 前的手动装箱和拆箱方式。（装箱：基本类型 -&gt; 包装类型；拆箱：包装类型 -&gt; 基本类型）</li><li>jdk5 及以后的自动装箱和拆箱方式。</li><li>自动装箱底层调用的是<code>valueOf</code>方法，比如<code>Integer.valueOf()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer3</span> <span class="hljs-operator">=</span> n2;<br><span class="hljs-comment">//底层使用的是 Integer.valueOf(n2); </span><br><span class="hljs-comment">// valueOf本质是 当在 -128~127 时，直接返回；否则 new Integer(i); 详见</span><br><br><span class="hljs-comment">//自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> integer3;<br><span class="hljs-comment">//底层使用的是 integer2.intValue()，return integer3对象的value</span><br></code></pre></td></tr></table></figure><h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p><strong>装箱：</strong>将基本类型用它们对应的引用类型包装起来</p><p><strong>拆箱：</strong>将包装类型转换为基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱 等价于 Integer i = Integer.valueOf(10)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱 等价于 int n = i.intValue();</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><h2 id="浮点数运算的精度丢失风险"><a href="#浮点数运算的精度丢失风险" class="headerlink" title="浮点数运算的精度丢失风险"></a>浮点数运算的精度丢失风险</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.8f</span> - <span class="hljs-number">1.7f</span>;<br>System.out.println(a);  <span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);  <span class="hljs-comment">// 0.099999905</span><br>System.out.println(a == b);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>原因：</strong>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><p>更多内容详见：<a href="https://www.yuque.com/kingshit/wz61vk/yxked8f04twgtmnl">浮点数</a></p><h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到<strong>货币</strong>的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(c);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.2 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.20 */</span><br><span class="hljs-comment">// 比较内容，不是比较值</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* false */</span><br><span class="hljs-comment">// 比较值相等用compareTo，相等返回0</span><br>System.out.println(<span class="hljs-number">0</span> == x.compareTo(y)); <span class="hljs-comment">/* true */</span><br></code></pre></td></tr></table></figure><p>关于 <code>BigDecimal</code> 的详细介绍，参考：<a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a>。</p><h2 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h2><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><p>在 Java 中，64 位 long 整型是最大的整数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span><br>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h2 id="String类型和包装类转换"><a href="#String类型和包装类转换" class="headerlink" title="String类型和包装类转换"></a>String类型和包装类转换</h2><p>包装类（Integer 为例） -&gt; String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//方式一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;  <br><span class="hljs-comment">//底层创建一个基于i对象的值的String对象，i对象的类型并没有改变</span><br><br><span class="hljs-comment">//方式二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> i.toString();  <span class="hljs-comment">//</span><br><br><span class="hljs-comment">//方式三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> String.valueOf(i);  <br><span class="hljs-comment">//底层还是跟方式二一样调用toString： </span><br><span class="hljs-comment">// return (obj == null) ? &quot;null&quot; : obj.toString()</span><br></code></pre></td></tr></table></figure><p>String -&gt; 包装类（Integer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">//方式一：调用包装类的转换方法parseXxx()</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.parseInt(str);  <span class="hljs-comment">//底层：调用parseInt(s, 10); 参数radix:10表示输出十进制整数</span><br><br><span class="hljs-comment">//方式二：调用Integer构造器</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str);  <span class="hljs-comment">//底层还是跟方式一一样：this.value = parseInt(s, 10); </span><br></code></pre></td></tr></table></figure><h2 id="包装类缓存机制"><a href="#包装类缓存机制" class="headerlink" title="包装类缓存机制"></a>包装类缓存机制</h2><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128, 127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0, 127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p><strong>所有整型包装类对象之间值的比较，全部使用</strong> <code>**equals**</code> <strong>方法比较。</strong></p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    System.out.println(i1 == j2);  <span class="hljs-comment">// false  new出来的是不同的对象</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 底层调用valueOf方法，当传入参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 等价于 Integer i4 = Integer.valueOf(127)</span><br>    System.out.println(i3 == i4);  <span class="hljs-comment">// true</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 底层调用valueOf方法，当传入参数不在 -128~127 范围时，直接创建新对象。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i6</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 同上</span><br>    System.out.println(i5 == i6);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i7</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// 从数组里面取值，属于数组对象</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);  <span class="hljs-comment">// new出来的新对象</span><br>    System.out.println(i7 == i8);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i9</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// Integer对象</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i10</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;                  <span class="hljs-comment">// 基本数据类型</span><br>    System.out.println(i9 == i10);  <span class="hljs-comment">// true  只要有基本数据类型，就是判断值是否相等!!!</span><br><br>    <span class="hljs-comment">// 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。</span><br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br>    <br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i13</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i14</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>valueOf()</code>源码：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/valueOf%E6%BA%90%E7%A0%81.png" alt="valueOf源码"></p><p><strong>解读：</strong></p><ul><li>当传入的参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</li><li>当传入的参数不在 -128~127 范围时，直接创建新对象。</li></ul><p><code>**IntegerCache.cache**</code><strong>数组（部分）</strong>：</p><p>该数组由包装类<code>Integer</code>创建，大小为 256，存储了 -128~127</p><p><strong>Character</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">isDigit</span><span class="hljs-params">()</span></span>`方法：确定指定的字符是否为数字，返回`boolean<br></code></pre></td></tr></table></figure><p>示例：判断字符串是否都为数字组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断一个字符串是否都为数字组成</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span> ( !(Character.isDigit(str.charAt(i))) ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础概念</title>
    <link href="/2022/05/24/Java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/05/24/Java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE-EE-ME"><a href="#Java-SE-EE-ME" class="headerlink" title="Java SE EE ME"></a>Java SE EE ME</h1><p>Java SE 就是标准版，包含标准的 JVM 和标准库</p><p>Java EE 是企业版，它只是在 Java SE 的基础上加上了大量的 API 和库，以便方便开发 Web 应用、数据库、消息服务等。</p><p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Java%E7%89%88%E6%9C%AC.png" alt="Java版本"></p><h1 id="JVM-amp-JDK-amp-JRE"><a href="#JVM-amp-JDK-amp-JRE" class="headerlink" title="JVM &amp; JDK &amp; JRE"></a>JVM &amp; JDK &amp; JRE</h1><p><strong>JVM（Java Virtual Machine, Java 虚拟机）</strong>并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p>维基百科上就有常见 JVM 的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">Comparison of Java virtual machinesopen in new window</a> ，感兴趣的可以去看看。并且，你可以在 <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specificationsopen in new window</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JVM%E6%A8%A1%E5%9E%8B.png" alt="JVM模型"></p><p><strong>JDK（Java Development Kit）</strong>是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，还包含了 javac（编译 java 源码的编译器）以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p><p><strong>JRE（Java Runtime Environment）</strong>是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p><h2 id="JDK、JRE-和-JVM-的包含关系"><a href="#JDK、JRE-和-JVM-的包含关系" class="headerlink" title="JDK、JRE 和 JVM 的包含关系"></a>JDK、JRE 和 JVM 的包含关系</h2><p>JDK &#x3D; JRE + 开发工具集（例如 javac，java 编译工具等）</p><p>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）</p><p>如果只想运行开发好的<code>.class</code>文件，只需要 JRE。</p><p>但对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK.png" alt="JDK"></p><p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ <a href="http://openjdk.java.net/jeps/282">jlink</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。详见： <a href="https://javaguide.cn/java/new-features/java9.html">Java 9 新特性概览</a>。</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>官网：<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p><h2 id="配置环境变量path"><a href="#配置环境变量path" class="headerlink" title="配置环境变量path"></a>配置环境变量path</h2><ol><li>环境变量 - 系统变量 - 添加 JAVA_HOME 环境变量，指向 jdk 的安装目录 <code>D:\Program Files\jdk8\jdk1.8.0_333</code></li><li>编辑 path 环境变量，增加 <code>%JAVA_HOME%\bin</code></li><li>为了确保 jre（运行）在你使用 javaIDE 的时候不产生问题，新增配置 <code>%JAVA_HOME%\jre\bin</code></li></ol><p>windows 操作系统是如何搜索硬盘上某个命令？</p><ol><li>首先会从当前目录下搜索</li><li>当前目录搜索不到的话，会从环境变量path指定的路径当中搜索某个命令</li><li>如果都搜索不到，则报错</li></ol><h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><p>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><h1 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h1><ol><li>Java 源码本质上是一个文本文件，需要先用<code>javac</code>把 Xxx.java 编译成字节码文件 Xxx.class，然后，用<code>java</code>命令执行这个字节码文件</li><li>给虚拟机（JVM）传递的参数<code>Hello</code>是我们定义的类名，JVM 会启动<strong>类加载器（ClassLoader）</strong>，ClassLoader 会自动查找对应的 class 文件装载到 JVM 中执行。</li><li>JVM 将 Xxx.class 字节码文件解释成二进制数据。</li><li>操作系统执行二进制和底层硬件平台进行交互。</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C.png" alt="编译与运行"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol><li>编译阶段主要的任务是检查 Java 源程序是否符合Java语法</li><li>符合 Java 语法则生成正常的字节码文件（<code>xxx.class</code>）</li></ol><p>字节码文件中不是纯粹的二进制，这种文件无法在操作系统中直接执行。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac Hello.java<br></code></pre></td></tr></table></figure><ol><li>java 源文件，通过编译器编译成JVM可识别的字节码文件</li><li>通过<code>javac.exe</code>编译工具对<code>Hello.java</code>文件进行编译</li><li>若程序没错，则没有任何提示，并在源文件同目录出现一个<code>Hello.class</code>文件，该文件称为字节码文件，是可以执行的 java 程序</li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>java.exe</code>主要负责运行阶段</p><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java Hello<br></code></pre></td></tr></table></figure><ol><li>有了可执行的 java 程序（<code>.class</code>字节码文件）</li><li>通过运行工具<code>java.exe</code>对字节码文件进行执行，本质是<code>.class</code>装载到 JVM 执行</li></ol><p>注：dos控制台默认简体中文 GBK 编码，若源码有中文，则需要以 chinese 编码保存</p><h2 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h2><ol><li>Java应用程序的执行入口是main()方法。有固定书写格式：public static void main(String[] args){…}</li><li>Java语言严格区分大小写。</li><li>类首字母大写。</li><li>一个源文件中最多只有一个public类。其他类个数不限。[示例1]</li><li>如果源文件中包含一个public类，则文件名必须按该类名命名。</li><li>也可以将mian方法写在非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法。[示例1]</li></ol><p>示例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;yo my nigga!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编译后，每个类都对应一个.class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是皮蛋&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>&#125;<br># 编译 <span class="hljs-keyword">public</span> 类命名的文件<br>javac Hello.java <br><br># 运行里面的 Cat 类<br>java Cat <br></code></pre></td></tr></table></figure><p>在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p><p>　　1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。</p><p>　　2.public类的名称必须完全与含有该编译单元的文件名相同，包含大小写。如果不匹配，同样将得到编译错误。</p><p>　　3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。</p><p>一个编译单元（java文件）可以存在多个类，在编译时产生多个不同的<code>.class</code>文件， <code>.class</code>文件便是程序运行的数据来源。</p><p>java 将 public 类作为每个编译单元的数据接口，只能有一个，不然不能处理存在多个类的 java 文件。当一个编译单元（java文件）有多个非 public 类时，运行时需要对数据来源进行选择。</p><h2 id="Java-API文档"><a href="#Java-API文档" class="headerlink" title="Java API文档"></a>Java API文档</h2><p>API（Application Programming Interface）是Java提供的基本编程接口（java提供的类和相关方法）。中文在线文档：<a href="https://www.matools.com/">https://www.matools.com</a></p><h1 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h1><p>高级编程语言按照程序的执行方式分为两种：</p><ul><li>编译型：编译型语言open in new window 会通过编译器open in new window将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li><li>解释型：解释型语言open in new window会通过解释器open in new window一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li></ul><p><code>.class -&gt; 机器码</code>这一步：</p><ul><li><strong>JVM 类加载器</strong>首先加载<code>.class</code>字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</li></ul><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 <strong>JIT（Just in Time Compilation） 编译器</strong>，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong>。</p><p>🌈 拓展：<a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">有关 JIT 的实现细节: JVM C1、C2 编译器</a></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B-%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AAJavaGuide.png" alt="Java程序转变为机器代码的过程-图片来自JavaGuide"></p><p>Java程序转变为机器代码的过程</p><p>HotSpot 采用了<strong>惰性评估（Lazy Evaluation）</strong>的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h1 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h1><h2 id="什么是AOT？"><a href="#什么是AOT？" class="headerlink" title="什么是AOT？"></a>什么是AOT？</h2><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><p>JIT 与 AOT 两者的关键指标对比：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/AOTvsJIT.png" alt="AOTvsJIT"></p><p>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p>提到 AOT 就不得不提 GraalVMopen in new window 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。感兴趣的同学，可以去看看 GraalVM 的<a href="https://www.graalvm.org/latest/docs/">官方文档</a>。如果觉得官方文档看着比较难理解的话，也可以找一些文章来看看，比如：</p><ul><li><a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">基于静态编译构建微服务应用</a></li><li><a href="https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/%E8%B5%B0%E5%90%91-native-%E5%8C%96springdubbo-aot-%E6%8A%80%E6%9C%AF%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/">走向 Native 化：Spring&amp;Dubbo AOT 技术示例与原理讲解</a></li></ul><h2 id="为什么不全部使用-AOT-呢？"><a href="#为什么不全部使用-AOT-呢？" class="headerlink" title="为什么不全部使用 AOT 呢？"></a>为什么不全部使用 AOT 呢？</h2><p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。</p><p>除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</p><p>举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h1 id="Oracle-JDK-vs-OpenJDK"><a href="#Oracle-JDK-vs-OpenJDK" class="headerlink" title="Oracle JDK vs OpenJDK"></a>Oracle JDK vs OpenJDK</h1><p>首先，2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。</p><p>其次，对于 Java 7 而言，OpenJDK 和 Oracle JDK 是十分接近的。 Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。</p><p>下面这段话摘自 Oracle 官方在 2012 年发表的一个博客：</p><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p><p>最后，简单总结一下 Oracle JDK 和 OpenJDK 的区别：</p><ul><li><strong>是否开源</strong>：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引起很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目：<a href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdkopen in new window</a> 。</li><li><strong>是否免费</strong>：Oracle JDK 会提供免费版本，但一般有时间限制。JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。</li><li><strong>功能性</strong>：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。</li><li><strong>稳定性</strong>：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。</li><li><strong>协议</strong>：Oracle JDK 使用 BCL&#x2F;OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ul><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类（详见Java API文档）</li><li>控制访问范围</li></ol><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ol><li>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package</li><li>import 指令位置放在 package 下面，在类定义前面，可以有多句且没有顺序要求</li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">package</span> com.rwj;  <br><span class="hljs-comment">// package关键字：表示打包</span><br><span class="hljs-comment">// com.rwj：表示包名</span><br><br><span class="hljs-comment">// 导入/引入</span><br><span class="hljs-keyword">import</span> java.util.Scanner;  <span class="hljs-comment">//表示只会引入java.util包下的Scanner类</span><br><span class="hljs-keyword">import</span> java.util.*;  <span class="hljs-comment">//表示将java.util包下的所有类都引入</span><br></code></pre></td></tr></table></figure><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>创建不同的目录&#x2F;文件夹来保存类文件。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>只能包含数字、字母、下划线、小圆点，不能用数字开头，不能是关键字或保留字</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.公司名.项目名.业务模块名<br></code></pre></td></tr></table></figure><p><code>com.sina.crm.user</code> &#x2F;&#x2F;用户模块</p><p><code>com.sina.crm.order</code> &#x2F;&#x2F;订单模块</p><p><code>com.sina.crm.utils</code> &#x2F;&#x2F;工具类</p><h2 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h2><p><code>java.lang.*</code>：lang 包是基本包，默认引入，不需要再手动引入</p><p><code>java.util.*</code>：util 包，系统提供的工具包，工具类，使用 Scanner</p><p><code>java.net.*</code>：网络包，网络开发</p><p><code>java.awt.*</code>：做 java 界面开发，GUI</p><hr><p>参考</p><p><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">Java基础常见面试题总结(上)</a></p><p><a href="https://liaoxuefeng.com/books/java/quick-start/history/index.html">Java历史 - Java教程 - 廖雪峰的官方网站</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
