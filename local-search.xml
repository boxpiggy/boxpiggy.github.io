<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网页渲染技术简介</title>
    <link href="/2024/08/29/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/08/29/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>网站渲染可以在服务端和客户端进行。</p><h1 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h1><p>在客户端渲染中，客户端会先向服务器请求 HTML 文件，服务器返回一个基础的 HTML 文件，其中包含必要的 JavaScript 脚本。这些脚本在浏览器端运行，动态请求后端的数据，生成网页内容并渲染到页面上。</p><p>表现为看到请求的过程是断断续续的。</p><h2 id="客户端渲染优点"><a href="#客户端渲染优点" class="headerlink" title="客户端渲染优点"></a>客户端渲染优点</h2><ol><li>开发方便灵活：开发者不需要区分哪些数据要在服务端加载、哪些数据要在客户端加载，也不用担心哪些 API 无法再服务端使用。</li><li>减少服务器压力：由于渲染工作由客户端完成，因此服务器的负载相对较小，只需要提供静态资源。</li></ol><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>如果不需要做 SEO，比如面向企业的、内部的、个人学习用的网站，或者较为复杂、充满各种动态交互的网站，用客户端渲染更好。</p><h1 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h1><p>服务端渲染是一种将网页在服务端生成并渲染为 HTML 内容的技术。</p><p>在这种方式下，当用户请求一个网页时，服务器会提前调用后端来获取数据并生成完整的 HTML 文档，然后将其发送到客户端（浏览器）。浏览器接收到 HTML 后，直接展示页面内容，不用再动态地向后端发送请求来获取数据。</p><h2 id="服务端渲染优点"><a href="#服务端渲染优点" class="headerlink" title="服务端渲染优点"></a>服务端渲染优点</h2><ol><li>减少页面初始加载时间：首次加载时展示完整内容，减少白屏时间，不用等待 JavaScript 加载和执行后才能展示内容。</li><li>更有利于 SEO，因为搜索引擎爬虫能够直接抓取完整页面的内容，而不依赖于 JavaScript 的执行。</li></ol><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><p>如果网站要做 SEO、希望被更多人搜索到，首选服务端渲染，但堆服务器配置的要求就更高了。</p><h2 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h2><p>以前：JSP、PHP</p><p>现在：</p><ul><li>基于 React 的 Next.js 框架</li><li>基于 Vue 的 Nuxt.js 框架</li></ul><h1 id="静态网站生成"><a href="#静态网站生成" class="headerlink" title="静态网站生成"></a>静态网站生成</h1><p>除了服务端渲染和客户端渲染外，还有一种常见的技术——静态网站生成。</p><p>静态网站生成是一种在<strong>构建阶段</strong>生成静态 HTML 文件的技术。注意，是在构建时（而不是用户请求时）就已经请求后端服务器获取了数据并且把页面生成好了，用户请求的时候服务器只需要把文件发出去就行。</p><p>搜索引擎最喜欢的就是静态 HTML 文件，可以大幅提升 SEO 效果。此外，这些静态文件还可以通过内容分发网络（CDN 缓存）进行加速，进一步减少服务器的压力。</p><h2 id="静态网站生成缺点"><a href="#静态网站生成缺点" class="headerlink" title="静态网站生成缺点"></a>静态网站生成缺点</h2><ol><li>不适合内容动态变化的网站。</li><li>随着内容的增多，每次构建要生成大量静态页面，时间会越来越长。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>随着静态网站内容越来越多，每次构建会越来越慢，这种情况下，可以采用<strong>增量静态生成技术</strong>。允许部分页面在构建之后进行更新，而无需重新构建整个站点。这种技术适用于那些大多数内容不变、但某些部分需要动态更新的网站。</p><p>比如更改博客里的一篇文章，那么只需要重新构建生成这篇文章的 HTML 页面即可。</p><h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><p>基于以上优缺点，静态网站生成适合内容数量有限、内容基本不变的网站，比如个人博客。像 VuePress、Hugo、Hexo、Astro 都是主流的静态网站生成器。</p><p>值得一提的是，很多大型网站为了做 SEO 优化，专门把动态网站转为静态 HTML。</p><h1 id="多种方式结合"><a href="#多种方式结合" class="headerlink" title="多种方式结合"></a>多种方式结合</h1><h2 id="部分预渲染"><a href="#部分预渲染" class="headerlink" title="部分预渲染"></a>部分预渲染</h2><p><strong>部分预渲染</strong> 是一种将静态页面生成与客户端渲染结合的技术。</p><ol><li>在构建阶段或请求阶段，页面的静态部分预先渲染，比如导航栏、页脚等。</li><li>页面加载时候，静态部分可以直接显示。比如访问某些网站时，内容无论谁访问都是一样的、不变的。</li><li>然后通过水合过程，客户端的 JavaScript 接管已经渲染的静态内容，并继续处理动态交互。比如请i去后端获取用户登陆状态、并且加载出用户的信息。</li></ol><p>这样一来，网站兼具了服务端渲染的 SEO 友好和快速初始加载、以及客户端渲染灵活动态交互的优点。</p><h2 id="同构渲染"><a href="#同构渲染" class="headerlink" title="同构渲染"></a>同构渲染</h2><p>还有一个跟部分预渲染相似的概念，叫 <strong>同构渲染</strong>，是指同一套代码可以在服务端和客户端运行，并在服务端渲染页面的初始内容，然后再客户端接管渲染和交互。</p><p>作者更推荐这种方式。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
      <category>知识碎片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何设计分布式ID发号器</title>
    <link href="/2024/08/28/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%88%86%E5%B8%83%E5%BC%8FID%E5%8F%91%E5%8F%B7%E5%99%A8/"/>
    <url>/2024/08/28/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%88%86%E5%B8%83%E5%BC%8FID%E5%8F%91%E5%8F%B7%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="系统背景"><a href="#系统背景" class="headerlink" title="系统背景"></a>系统背景</h1><p>一般在分库分表场景，就会有分布式 ID（全局唯一 ID）的需求，因为需要有一个唯一标识来标记一个订单或者其他类似的数据等。</p><p>具体需求：</p><ul><li>全局唯一（所有系统要求）：生成的 ID 不能重复，否则在分库分表的场景下会造成冲突。</li><li>单调递增（部分系统要求[1]）：保证写入数据库的时候是顺序写入，提高写入性能。</li></ul><blockquote><p>[1]：并不是所有系统都需要，例如分布式追踪的请求 ID 就可以不需要单调递增。而那些需要存到数据库里作为 ID 主键的场景，可能就需要保证全局唯一 ID 是单调递增的。</p><p>另外，还需要考虑安全方面的问题。如果全局唯一 ID 是顺序递增的，那么可能会造成业务信息的泄露。例如竞争对手可以通过订单 ID 计算我们每天的订单数。</p></blockquote><p>全局唯一 ID 有很多解决方案，常见的为以下4种：</p><ol><li>UUID</li><li>雪花算法</li><li>基于数据库自增主键</li><li>Redis原子自增</li></ol><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>UUID（Universally Unique Identifier），即全局唯一标识符，它是 Java 中自带的 API。一个标准的 UUID 包含 32 个 16 进制的数字，以中横线作为分隔符分为 5 段，每段的长度分别为 8 字符、4 字符、4 字符、4 字符、12 字符，大小为 36 个字符。一个简单的 UUID 示例：<code>630e4100-e29b-33d4-a635-246652140000</code></p><h3 id="UUID-优点"><a href="#UUID-优点" class="headerlink" title="UUID 优点"></a>UUID 优点</h3><ul><li>本地生成，无外部依赖，性能高且实现简单。</li></ul><h3 id="UUID-缺点"><a href="#UUID-缺点" class="headerlink" title="UUID 缺点"></a>UUID 缺点</h3><ul><li>字段太长，占用存储空间。</li><li>非自增，无序插入会导致数据页频繁分裂，降低数据库写入性能。</li></ul><p>因此，UUID 比较适用于非数据库 ID 存储的情况，例如生成一个本地的分布式追踪请求 ID。</p><h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法（SnowFlake）是 Twitter 开源的分布式 ID 生成算法，其思路是用 64 位来表示一个 ID，并将 64 位分割成 4 个部分。</p><p>实际上就用到了63bit，第一个bit没用，固定为 0，表示为正整数。二进制中最高位是符号位，1 表示负数，0表示正数。由于 ID 都是正整数，所以固定为0。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95ID%E7%BB%93%E6%9E%84.png" alt="雪花算法ID结构"></p><ul><li>第二部分 41bit 是时间戳，精确到毫秒，可以使用 69 年。时间戳带有自增属性。</li><li>第三部分 10bit 是机器 ID，可以表示 1024 个节点。如果有机房的划分，可拆分成 5 位 datacenterId 和 5 位 workerId，datacenterId 代表机房，workerId 表示机器 ID。</li><li>第四部分 12bit 是自增序列号，12bit 可以表示 2 的 12 次方个 ID，即可以支持同一节点同一毫秒生成最多 4095 个 ID。</li></ul><h3 id="雪花算法的优点"><a href="#雪花算法的优点" class="headerlink" title="雪花算法的优点"></a>雪花算法的优点</h3><ul><li><strong>有序，提高写入性能。</strong>ID 从整体来看有序的、单调递增的，将其作为数据库主键 ID 时可以实现顺序写入，提高写入性能。</li><li><strong>不依赖第三方。</strong>生成方式简单、配置灵活，不依赖外部三方组件或中间件，因此其稳定性较高。</li><li><strong>保证业务安全问题。</strong>雪花算法生成的 ID 是单调递增的，但其递增步长又不是确定的，因此无法从 ID 的差值推断出生成的数量，从而可以保护业务隐私。</li><li><strong>可自定义。</strong>许多国内大厂的开源发号器的实现，都是在雪花算法的基础上做改进（例如：百度开源的 UidGenerator、美团开源的 Leaf 等等）。这些类雪花算法的核心都是将 64 位进行更合理的划分，从而使得其更适合自身场景。</li></ul><h3 id="雪花算法的缺点"><a href="#雪花算法的缺点" class="headerlink" title="雪花算法的缺点"></a>雪花算法的缺点</h3><ul><li>依赖时钟，如果机器的系统时间发生时钟回拨，即时间较正常的时间慢，可能会导致发号重复。</li></ul><blockquote><p>时钟回拨解决方案：</p><p>（1）理论上可以存储上一次发号的时间，如果当前发号的时间小于之前的发号时间，则说明时钟回拨，此时拒绝发号，可以报警或者重试（重试几次时间可能就回来了）。</p><p>（2）可以在本地维护一个文件，写入上次的时间戳，随后与当前时间戳比较。如果当前时间戳小于上次时间戳，说明系统时间出了问题，应该及时处理。</p></blockquote><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>常见的 hutool 就有提供了雪花算法工具类。</p><blockquote><p>雪花算法的机器 ID 如何动态配置？因为现在机器都是动态扩容部署，机器数都是不固定的，如果机器 ID 没配置好，容易导致冲突。</p><p>可以借助 Redis 或者 zookeeper 来实现机器 ID 的分配。</p><ul><li>redis 的执行是单线程的，机器启动时候调用 redis incr 即可得到自增 id ，可将这个 id 作为机器 ID。</li><li>zookeeper 的使用也很简单，机器启动时候可以利用 zookeeper 持久顺序节点特性，将注册成功的顺序号作为机器 ID。</li></ul></blockquote><h2 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h2><p>对 MySQL 来说，直接利用自增 id 即可实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">REPLACE INTO <span class="hljs-title function_">table</span><span class="hljs-params">(bizTag)</span> VALUES(<span class="hljs-string">&quot;order&quot;</span>);<br>SELECT <span class="hljs-title function_">last_insert_id</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>将<code>bizTag</code>设为唯一索引，可以填写业务值（也可以不同业务多张表），<code>REPLACE INTO</code>执行后自增 ID 会 +1，通过 <code>last_insert id</code> 即可获得自增的 ID 。</p><h3 id="数据库自增优点"><a href="#数据库自增优点" class="headerlink" title="数据库自增优点"></a>数据库自增优点</h3><p>简单、利用数据库就能实现，且ID 有序,</p><h3 id="数据库自增缺点"><a href="#数据库自增缺点" class="headerlink" title="数据库自增缺点"></a>数据库自增缺点</h3><p><strong>性能不足。</strong>当请求增多时，我们只能堆机器提高性能。</p><p><strong>水平扩展困难。</strong>当我们需要增加一台机器时，其处理过程非常麻烦。首先，需要先把新增的服务器部署好，设置新的步长，起始值要设置一个不可能达到的值。当把新增的服务器部署好之后，再一台台处理旧的服务器。</p><h3 id="水平扩展优化"><a href="#水平扩展优化" class="headerlink" title="水平扩展优化"></a>水平扩展优化</h3><p>可以利用<code>auto_increment_increment</code>和<code>auto_increment offset</code>实现横向扩展。</p><p>比如现在有两台数据库，<code>auto_increment_increment</code>都设置为<code>2</code>，即步长是<code>2</code>。第一台数据库表<code>auto increment offset</code>设置为 <code>1</code>，第二台数据库表<code>auto_increment offset</code>设置为<code>2</code>。</p><p>即<code>TicketServer1</code>从<code>1</code>开始发号，<code>TicketServer2</code>从<code>2</code>开始发号，两台机器每次发号之后都递增2</p><p>这样一来，第一台的 ID 增长值就是 1、3、5、7、9…，第二台的ID 增加值就是 2、4、6、8、10…</p><p>这样也能保证全局唯一性，多加几台机器弥补性能问题，只要指定好每个表的步长和初始值即可。要部署 N 台机器，步长需设置为 N，每台的初始值依次为 0,1,2…N-1。</p><p>不过单调递增特性没了，且加机器的成本不低，动态扩容很不方便。</p><h3 id="批量思想优化"><a href="#批量思想优化" class="headerlink" title="批量思想优化"></a>批量思想优化</h3><p>每次操作数据库就拿一个 ID，如果一次性拿 1000 个，那不就大大减少操作数据库的次数，性能不就上去了吗?</p><p>重新设计下表，主要字段如下：</p><p><code>bizTag</code>：业务标识 <code>maxld</code>：目前已经分配的最大 ID <code>step</code>：步长，可以设置为 1000 那么每次就是拿 1000 ，设置成 1w 就是拿 1w 个</p><p>每次来获取 ID 的 SQL如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">UPDATE table <span class="hljs-type">SET</span> <span class="hljs-variable">maxId</span> <span class="hljs-operator">=</span> max_id + step <span class="hljs-type">WHERE</span> <span class="hljs-variable">bizTag</span> <span class="hljs-operator">=</span> xxx<br>SELECT maxId, step FROM table <span class="hljs-type">WHERE</span> <span class="hljs-variable">biz_tag</span> <span class="hljs-operator">=</span> xxx<br></code></pre></td></tr></table></figure><p>这其实就是<strong>批量思想</strong>，大大提升了ID 获取的性能。</p><blockquote><p>假设业务并发量很高，此时业务方一批 ID 刚好用完后，来获取下一批 ID ，因为当前数据库压力大，很可能就会产生性能抖动，即卡了一下才拿到ID，从监控上看就是产生毛刺。</p><p>这样怎么处理？</p><p>其实这就是预处理思想，很多开源组件预处理的场景很多，例如 RocketMQcommitlog 文件的分配就是预处理，即当前 commitlog 文件用完之前，就会有后台线程预先创建后面要用的文件，就是为了防止创建的那一刻的性能抖动。</p></blockquote><p>同理，这个场景我们也可以使用<strong>预处理思想</strong>。</p><p>发号器服务可以本地缓存两个 buffer，业务方请求 ID 每次从其中一个 buffer 里取，如果这个 buffer 发现 ID 已经用了 20%（或者另外的数量），则可以起一个后台线程，调用上面的  SQL 语句，先把下一批的 ID 放置到另一个 buffer 中。</p><p>当前面那个 buffer ID 都用完了，则使用另一个 buffer 取号，如此循环使用即可，这样就能避免毛刺问题。</p><p>将 ID 放在本地缓存性能好，即使服务重启了也没事，无非就是中间空了一点点 ID 罢了，整体还是有序的。</p><h2 id="Redis-原子自增"><a href="#Redis-原子自增" class="headerlink" title="Redis 原子自增"></a>Redis 原子自增</h2><p>由于 Redis 是内存数据库，其强大的性能非常适合用来实现高并发的分布式 ID 生成。基于 Redis 实现自增 ID，其主要还是利用了 Redis 中的<code>INCR</code>命令。该命令可以将某个数自增一并返回结果，并且这个操作是原子操作。</p><p>通过 Redis 实现分布式 ID 功能，其模式与通过数据库自增 ID 类似，只是存储介质从硬盘变成了内存。</p><p>当单台 Redis 无法支撑并发请求的时候，Redis 同样可以通过集群部署和设置步长的方式去解决。但数据库自增主键有的问题，Redis 自增 ID 的方式也同样会有，即只能堆机器，同时水平扩展困难。此外，比起数据库存储的持久化，Redis 是基于内存的存储，还需要考虑持久化的问题。</p><h1 id="如何选型"><a href="#如何选型" class="headerlink" title="如何选型"></a>如何选型</h1><p>选型需要考虑：研发成本、并发量、性能、运维成本等。</p><ul><li>首先 UUID 各方面都不如雪花算法，除了研发成本。</li><li>雪花算法不依赖第三方组件，写入性能优秀，保证安全问题，缺点主要是研发成本高。</li><li>数据库自增 ID 研发成本低，但是支撑的并发量低，运维成本高，适用于小规模的使用场景。</li><li>Redis 原子自增的方式优点在于高性能，能支撑高并发的场景，但需要处理持久化问题，运维成本较高。</li></ul><p>总体来说，雪花算法与数据库自增 ID 或许是相对好的选择。</p><hr><p>参考资料</p><p><a href="https://www.cnblogs.com/chanshuyi/p/how-to-design-a-distributed-id-system.html">如何设计一个分布式 ID 发号器？ - 陈树义 - 博客园</a></p><p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>系统设计</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git添加失败，提示文件名太长</title>
    <link href="/2024/08/19/Git%E6%B7%BB%E5%8A%A0%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E5%90%8D%E5%A4%AA%E9%95%BF/"/>
    <url>/2024/08/19/Git%E6%B7%BB%E5%8A%A0%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E5%90%8D%E5%A4%AA%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>Git add</code>时遇到<code>filename too long</code>错误。</p><blockquote><p>Git 的<code>add</code>命令将文件添加到暂存区。</p></blockquote><h1 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h1><p>在理解错误原因之前，我们需要了解一下操作系统对文件名长度的限制。不同的操作系统对文件名长度的限制是不同的。例如，Windows系统的文件名长度限制为260个字符，而Unix&#x2F;Linux系统中的文件名长度限制则更高一些。</p><p>Git 默认在 Windows 系统中使用 LF（Line Feed）作为行分隔符，而在 Unix&#x2F;Linux 系统中使用 CR（Carriage Return）和 LF 作为行分隔符。当我们在 Windows 系统中使用 Git时，Git 会自动将行分隔符转换为 LF，这样就可能导致文件名变长。</p><p>一般来说，主要原因还是 <strong>Git 未开启长路径支持。</strong></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>在解决这个问题之前，我们需要先了解一下Git的配置。我们可以通过以下命令查看Git的配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br></code></pre></td></tr></table></figure><p>查看配置信息中是否存在如下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">core.longpaths=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果存在该行，并且值为<code>true</code>，说明 Git 已经开启了长路径支持，那么问题可能是由于行分隔符导致的。我们可以尝试通过以下命令关闭行分隔符转换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.autocrlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>如果不存在<code>core.longpaths</code>配置或者其值不为<code>true</code>，我们可以尝试通过设置该配置来开启长路径支持：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.longpaths <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>在执行以上命令后，重新执行添加命令，看是否能够成功添加文件。如果问题仍然存在，那么可能是因为你的操作系统对文件名长度有限制。这时，我们可以尝试缩短文件名或重新组织文件结构，将文件移到较短路径下。</p><hr><p>参考：<a href="https://geek-docs.com/git/git-questions/127_git_git_add_command_fails_saying_filename_too_long.html">Git 添加命令失败，提示文件名太长|极客教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>Git常见问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid添加Live2d看板娘</title>
    <link href="/2024/08/18/Fluid%E6%B7%BB%E5%8A%A0Live2d%E7%9C%8B%E6%9D%BF%E5%A8%98/"/>
    <url>/2024/08/18/Fluid%E6%B7%BB%E5%8A%A0Live2d%E7%9C%8B%E6%9D%BF%E5%A8%98/</url>
    
    <content type="html"><![CDATA[<h1 id="添加看板娘"><a href="#添加看板娘" class="headerlink" title="添加看板娘"></a>添加看板娘</h1><p>使用 <a href="https://github.com/stevenjoezhang/live2d-widget">live2d-widget</a> 插件，添加 Live2D 看板娘</p><h2 id="引入项目"><a href="#引入项目" class="headerlink" title="引入项目"></a>引入项目</h2><p>把 <a href="https://github.com/stevenjoezhang/live2d-widget">live2d-widget</a> 项目<code>clone</code>到本地博客目录的<code>source</code>目录下。</p><blockquote><p>放在<code>source</code>目录下的所有开头不是<code>_</code>的文件，在<code>hexo generate</code>的时候，都会被拷贝到<code>public</code>文件夹下，且 Hexo 默认会渲染所有的 HTML 和 Markdown 文件。</p></blockquote><p>配置文件<code>_config.yml</code>中，配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">skip_render:</span> <span class="hljs-string">live2d-widget/*</span><br></code></pre></td></tr></table></figure><p>这样，hexo 就不会渲染<code>live2d-widget</code>目录下的所有文件。</p><h2 id="项目autoload-js配置"><a href="#项目autoload-js配置" class="headerlink" title="项目autoload.js配置"></a>项目<code>autoload.js</code>配置</h2><p>这一步主要是配置加载资源的路径</p><h3 id="配置live2d-path"><a href="#配置live2d-path" class="headerlink" title="配置live2d_path"></a>配置<code>live2d_path</code></h3><p>修改<code>live2d-widget/autoload.js</code>中的常量<code>live2d_path</code>为<code>live2d-widget</code>这一目录的 URL：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 把</span><br><span class="hljs-keyword">const</span> live2d_path = <span class="hljs-string">&quot;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;</span>;<br><span class="hljs-comment">// 改为</span><br><span class="hljs-keyword">const</span> live2d_path = <span class="hljs-string">&quot;/live2d-widget/&quot;</span>;<br></code></pre></td></tr></table></figure><blockquote><p><code>autoload.js</code>中的注释的绝对路径指的是，将资源打包放到<code>[Blogroot]/source/</code>中后，以<code>[Blogroot]/source/</code>为根目录（&#x2F;）的绝对路径。</p></blockquote><p><code>&quot;/live2d-widget/&quot;</code>后面的斜杠一定要加上，不然就会拼接出错误的请求路径。例如请求<code>live2d-widget</code>目录下的<code>live2d.min.js</code>时的请求路径 <a href="http://localhost:4000/live2d-widgetlive2d.min.js">http://localhost:4000/live2d-widgetlive2d.min.js</a></p><p><strong>验证</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">hexo clean<br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p>能够通过浏览器访问到<code>live2d.min.js</code>就可以了。</p><h3 id="配置模型资源"><a href="#配置模型资源" class="headerlink" title="配置模型资源"></a>配置模型资源</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">initWidget</span>(&#123;<br>    <span class="hljs-attr">waifuPath</span>: live2d_path + <span class="hljs-string">&quot;waifu-tips.json&quot;</span>,<br>    <span class="hljs-comment">//apiPath: &quot;https://live2d.fghrsh.net/api/&quot;,</span><br>    <span class="hljs-comment">// cdnPath: &quot;https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/&quot;,  // 原作者api</span><br>    <span class="hljs-attr">cdnPath</span>: <span class="hljs-string">&quot;https://npm.elemecdn.com/akilar-live2dapi@latest/&quot;</span>,  <span class="hljs-comment">// Akilar站长api</span><br>    <span class="hljs-comment">// https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/</span><br>    <span class="hljs-attr">tools</span>: [<span class="hljs-string">&quot;hitokoto&quot;</span>, <span class="hljs-string">&quot;asteroids&quot;</span>, <span class="hljs-string">&quot;switch-model&quot;</span>, <span class="hljs-string">&quot;switch-texture&quot;</span>, <span class="hljs-string">&quot;photo&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;quit&quot;</span>]<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>apiPath</code> 和 <code>cdnPath</code> 两个参数设置其中一项即可。<code>apiPath</code> 是后端 API 的 URL，可以自行搭建，并增加模型，可以参考 <a href="https://github.com/fghrsh/live2d_api">live2d_api</a>。而 <code>cdnPath</code> 则是通过 jsDelivr 这样的 CDN 服务加载资源，更加稳定。</p><h2 id="注入autoload-js脚本"><a href="#注入autoload-js脚本" class="headerlink" title="注入autoload.js脚本"></a>注入<code>autoload.js</code>脚本</h2><p>通过注入代码的方式，为博客网页无侵入式地增加<code>autoload.js</code>脚本。</p><p>博客目录下<code>scripts</code>文件夹（如不存在则创建），在里面创建任意名称的 js 文件，在文件中写入如下内容：</p><p><strong>Github.io 站点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">filter</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;theme_inject&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">injects</span>) &#123;<br>    <span class="hljs-comment">// Github Page</span><br>    injects.<span class="hljs-property">head</span>.<span class="hljs-title function_">raw</span>(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-string">&#x27;&lt;script src=&quot;https://boxpiggy.github.io/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>head</code>表示在<head>标签中的结尾注入；</li><li><code>raw</code>方法表示注入的是原生代码，第一个参数是键名，第二个参数则是一句原生的 HTML 语句。</li></ul><p>完成以上步骤后就可以提交了。</p><h2 id="模型调整"><a href="#模型调整" class="headerlink" title="模型调整"></a>模型调整</h2><p>修改<code>waifu.css</code>，看板娘放到最上层（默认为<code>1</code>，修改为<code>999</code>就是最顶层，值越大所在的图层就越高）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">z-index:</span> <span class="hljs-number">999</span><span class="hljs-string">;</span><br></code></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>如左下角。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://andytonglove.github.io/2022/09/08/%E5%8D%9A%E5%AE%A2live2d%E7%9C%8B%E6%9D%BF%E5%A8%98%E9%85%8D%E7%BD%AE/#">博客live2d看板娘配置——fluid主题</a>（提到 fluid 主题的注入代码方式添加脚本）</p><p><a href="https://akilar.top/posts/5b8f515f/">akilar - Live2d Widget</a>（解释详细）</p><p><a href="https://alec-97.github.io/posts/2499736958/">fluid添加看板娘</a>（提到修改模型）</p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载器详解</title>
    <link href="/2024/08/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/08/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://javaguide.cn/java/jvm/classloader.html">https://javaguide.cn/java/jvm/classloader.html</a></p><p>作者：JavaGuide</p></blockquote><h1 id="回顾一下类加载过程"><a href="#回顾一下类加载过程" class="headerlink" title="回顾一下类加载过程"></a>回顾一下类加载过程</h1><p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。</p><ul><li>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。</li><li>连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</li></ul><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p><p>加载是类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口</li></ol><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h2><p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。</p><p>根据官方 API 文档的介绍：</p><blockquote><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.</p><p>Every Class object contains a reference to the ClassLoader that defined it.</p><p>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.</p></blockquote><p>翻译过来大概的意思是：</p><blockquote><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。每个 Java 类都有一个引用指向加载它的<code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取<code>ClassLoader</code>的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p></blockquote><p>从上面的介绍可以看出：</p><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li><li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li><li>数组类不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>&lt;T&gt; &#123;<br>  ...<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader classLoader;<br>  <span class="hljs-meta">@CallerSensitive</span><br>  <span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title function_">getClassLoader</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">//...</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，类加载器的主要作用就是<strong>加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）</strong>。 字节码可以是 Java 源程序（.java文件）经过 javac 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p><p>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。</p><h2 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h2><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p><p>对于已经加载的类会被放在<code>ClassLoader</code>中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>  ...<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>  <span class="hljs-comment">// 由这个类加载器加载的类。</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>  <span class="hljs-comment">// 由VM调用，用此类加载器记录每个已加载类。</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addClass</span><span class="hljs-params">(Class&lt;?&gt; c)</span> &#123;<br>        classes.addElement(c);<br>   &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h2><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ol><li><code>**BootstrapClassLoader**</code>**(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（<code>%JAVA_HOME%/lib</code>目录下的<code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被              <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li><code>**ExtensionClassLoader**</code>**(扩展类加载器)**：主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的 jar 包和类以及被<code>java.ext.dirs</code>系统变量所指定的路径下的所有类。</li><li><code>**AppClassLoader**</code>**(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><blockquote><p>🌈 拓展一下：</p><ul><li><code>rt.jar</code>：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库<code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li><li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。<strong>扩展类加载器</strong>被改名为<strong>平台类加载器（platform class loader）</strong>。Java SE 中除了少数几个关键模块，比如说    <code>java.base</code>是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</li></ul></blockquote><p>除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ <code>.class</code> 文件）进行加密，加载时再利用自定义的类加载器对其解密。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="类加载器层次关系图"></p><p>除了<code>BootstrapClassLoader</code>是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自<code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><p>每个<code>ClassLoader</code>可以通过<code>getParent()</code>获取其父<code>ClassLoader</code>，如果获取到 <code>ClassLoader</code>为<code>null</code>的话，那么该类是通过<code>BootstrapClassLoader</code>加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>  ...<br>  <span class="hljs-comment">// 父加载器</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>    <br>  <span class="hljs-meta">@CallerSensitive</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">//...</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么获取到</strong><code>**ClassLoader**</code><strong>为</strong><code>**null**</code><strong>就是</strong><code>**BootstrapClassLoader**</code><strong>加载的呢？</strong> 这是因为<code>BootstrapClassLoader</code>由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是<code>null</code>。</p><p>下面我们来看一个获取 <code>ClassLoader</code> 的小案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintClassLoaderTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> PrintClassLoaderTree.class.getClassLoader();<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">split</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;|--&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needContinue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (needContinue)&#123;<br>            System.out.println(split.toString() + classLoader);<br>            <span class="hljs-keyword">if</span>(classLoader == <span class="hljs-literal">null</span>)&#123;<br>                needContinue = <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                classLoader = classLoader.getParent();<br>                split.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果(JDK 8 )：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">|--sun.misc.Launcher$AppClassLoader@18b4aac2<br>    |--sun.misc.Launcher$ExtClassLoader@53bd815b<br>        |--null<br></code></pre></td></tr></table></figure><p>从输出结果可以看出：</p><ul><li>我们编写的 Java 类<code>PrintClassLoaderTree</code>的<code>ClassLoader</code>是<code>AppClassLoader</code>；</li><li><code>AppClassLoader</code>的父<code>ClassLoader</code>是<code>ExtClassLoader</code>；</li><li><code>ExtClassLoader</code>的父<code>ClassLoader</code>是<code>BootstrapClassLoader</code>，因此输出结果为<code>null</code>。</li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>我们前面也说说了，除了<code>BootstrapClassLoader</code>其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承<code>ClassLoader</code>抽象类。</p><p><code>ClassLoader</code>类有两个关键的方法：</p><ul><li><code>protected Class **loadClass**(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code>为类的二进制名称，<code>resolve</code>如果为<code>true</code>，在加载时调用<code>resolveClass(Class&lt;?&gt; c)</code>方法解析该类。</li><li><code>protected Class **findClass**(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><p>官方 API 文档中写到：</p><blockquote><p>Subclasses of <code>ClassLoader</code> are encouraged to override <code>findClass(String name)</code>, rather than this method.</p><p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code>方法。</p></blockquote><p>如果我们不想打破双亲委派模型，就重写<code>ClassLoader</code>类中的<code>findClass()</code>方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写<code>loadClass()</code>方法。</p><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h2 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h2><p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。</p><p>根据官网介绍：</p><blockquote><p>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.</p></blockquote><p>翻译过来大概的意思是：</p><blockquote><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。每个<code>ClassLoader</code>实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code>实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p><p>虚拟机中被称为 “bootstrap class loader” 的内置类加载器本身没有父类加载器，但是可以作为<code>ClassLoader</code>实例的父类加载器。</p></blockquote><p>从上面的介绍可以看出：</p><ul><li><code>ClassLoader</code>类使用委托模型来搜索类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li><li><code>ClassLoader</code>实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li></ul><p>下图展示的各种类加载器之间的层次关系被称为类加载器的<strong>“双亲委派模型(Parents Delegation Model)”</strong>。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="类加载器层次关系图"></p><p>注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p><blockquote><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 MotherClassLoader 和一个FatherClassLoader 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。</p></blockquote><p>另外，<strong>类加载器之间的父子关系一般不是以继承的关系来实现的</strong>，而是通常使用组合关系来复用父加载器的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 组合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ClassLoader</span><span class="hljs-params">(ClassLoader parent)</span> &#123;<br>        <span class="hljs-built_in">this</span>(checkCreateClassLoader(), parent);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承</strong>。</p><h2 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h2><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在<code>java.lang.ClassLoader</code>的 <code>loadClass()</code>中，相关代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">//首先，检查该类是否已经加载过</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果 c 为 null，则说明该类没有被加载过</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span><br>                <span class="hljs-comment">//用户可通过覆写该方法，来自定义类加载器</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">//用于统计类加载器相关的信息</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            <span class="hljs-comment">//对类进行link操作</span><br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p><p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p><ul><li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器<code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器<code>BootstrapClassLoader</code>中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的<code>findClass()</code>方法来加载类）。</li><li>如果子类加载器也无法加载这个类，那么它会抛出一个<code>ClassNotFoundException</code>异常。</li></ul><p>🌈 拓展一下：</p><p><strong>JVM 判定两个 Java 类是否相同的具体规则：</strong>JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p><h2 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h2><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p><h2 id="打破双亲委派模型方法"><a href="#打破双亲委派模型方法" class="headerlink" title="打破双亲委派模型方法"></a>打破双亲委派模型方法</h2><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写<code>loadClass()</code>即可。</p><p>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/871">issue871</a>）：自定义加载器的话，需要继承<code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写<code>ClassLoader</code>类中的<code>findClass()</code>方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写    <code>loadClass()</code>方法。</p><p>为什么是重写<code>loadClass()</code>方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p><blockquote><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器<code>loadClass()</code>方法来加载类）。</p></blockquote><p>重写<code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。</p><p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器<code>WebAppClassLoader</code>来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p><p>Tomcat 的类加载器的层次结构如下：</p><p>![Tomcat 的类加载器的层次结构](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Tomcat">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Tomcat</a> 的类加载器的层次结构.png)</p><p>Tomcat 这四个自定义的类加载器对应的目录如下：</p><ul><li><code>CommonClassLoader</code>对应<code>&lt;Tomcat&gt;/common/*</code></li><li><code>CatalinaClassLoader</code>对应<code>&lt;Tomcat &gt;/server/*</code></li><li><code>SharedClassLoader</code>对应<code>&lt;Tomcat &gt;/shared/*</code></li><li><code>WebAppClassloader</code>对应<code>&lt;Tomcat &gt;/webapps/&lt;app&gt;/WEB-INF/*</code></li></ul><p>从图中的委派关系中可以看出：</p><ul><li><code>CommonClassLoader</code>作为<code>CatalinaClassLoader</code>和<code>SharedClassLoader</code>的父加载器。<code>CommonClassLoader</code>能加载的类都可以被<code>CatalinaClassLoader</code>和           <code>SharedClassLoader</code>使用。因此，<code>CommonClassLoader</code>是为了实现公共类库（可以被所有 Web 应用和 Tomcat 内部组件使用的类库）的共享和隔离。</li><li><code>CatalinaClassLoader</code>和<code>SharedClassLoader</code>能加载的类则与对方相互隔离。<code>CatalinaClassLoader</code>用于加载 Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web 应用的类。<code>SharedClassLoader</code>作为<code>WebAppClassLoader</code>的父加载器，专门来加载 Web 应用之间共享的类比如 Spring、Mybatis。</li><li>每个 Web 应用都会创建一个单独的<code>WebAppClassLoader</code>，并在启动 Web 应用的线程里设置线程线程上下文类加载器为<code>WebAppClassLoader</code>。各个<code>WebAppClassLoader</code> 实例之间相互隔离，进而实现 Web 应用之间的类隔。</li></ul><p>单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。（核心类库接口和第三方实现类）</p><p>比如，SPI 中，SPI 的接口（如<code>java.sql.Driver</code>）是由 Java 核心库提供的，由             <code>BootstrapClassLoader</code>加载。而 SPI 的实现（如<code>com.mysql.cj.jdbc.Driver</code>）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载 SPI 的接口的类加载器           （<code>BootstrapClassLoader</code>）也会用来加载 SPI 的实现。按照双亲委派模型，                 <code>BootstrapClassLoader</code> 是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。</p><p>再比如，假设我们的项目中有 Spring 的 jar 包，由于其是 Web 应用之间共享的，因此会由 <code>SharedClassLoader</code>加载（Web 服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了 Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring 的类加载器（也就是 <code>SharedClassLoader</code>）也会用来加载这些业务类。但是业务类在 Web 应用目录下，不在<code>SharedClassLoader</code>的加载路径下，所以<code>SharedClassLoader</code>无法找到业务类，也就无法加载它们。</p><p>如何解决这个问题呢？ 这个时候就需要用到<strong>线程上下文类加载器（</strong><code>**ThreadContextClassLoader**</code>）了。</p><p>拿 Spring 这个例子来说，当 Spring 需要加载业务类的时候，它不是用自己的类加载器，而是用<strong>当前线程</strong>的<strong>上下文类加载器</strong>。还记得我上面说的吗？每个 Web 应用都会创建一个单独的 <code>WebAppClassLoader</code>，并在启动 Web 应用的线程里设置线程线程上下文类加载器为       <code>WebAppClassLoader</code>。这样就可以让高层的类加载器（<code>SharedClassLoader</code>）借助子类加载器（ <code>WebAppClassLoader</code>）来加载业务类，破坏了 Java 的类加载委托机制，让应用逆向使用类加载器。</p><p>线程线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用。这个类加载器通常是由应用程序或者容器（如 Tomcat）设置的。</p><p><code>Java.lang.Thread</code>中的<code>getContextClassLoader()</code>和<code>setContextClassLoader(ClassLoader cl)</code>分别用来获取和设置线程的上下文类加载器。如果没有通过<code>setContextClassLoader(ClassLoader cl)</code>进行设置的话，线程将继承其父线程的上下文类加载器。</p><p>Spring 获取线程线程上下文类加载器的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cl = Thread.currentThread().getContextClassLoader();<br></code></pre></td></tr></table></figure><p>感兴趣的小伙伴可以自行深入研究一下 Tomcat 打破双亲委派模型的原理，推荐资料：<a href="http://gk.link/a/10Egr">《深入拆解 Tomcat &amp; Jetty》</a></p><hr><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul><li>《深入拆解 Java 虚拟机》</li><li><a href="https://blog.csdn.net/xyang81/article/details/7292380">深入分析Java ClassLoader原理-CSDN博客</a></li><li><a href="http://gityuan.com/2016/01/24/java-classloader/">Java类加载器(ClassLoader) - Gityuan博客 | 袁辉辉的技术博客</a></li><li><a href="https://www.baeldung.com/java-classloaders">Just a moment…</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html">Class ClassLoader - Oracle 官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/51374915">老大难的 Java ClassLoader 再不理解就老了</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载过程详解</title>
    <link href="/2024/08/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/08/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://javaguide.cn/java/jvm/class-loading-process.html">https://javaguide.cn/java/jvm/class-loading-process.html</a></p><p>作者：JavaGuide</p></blockquote><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p><p>这 7 个阶段的顺序如下图所示：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="一个类的完整生命周期"></p><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p><p>详见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">Java Virtual Machine Specification - 5.3. Creation and Loading</a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。</li></ol><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取（ ZIP、 JAR、EAR、WAR、网络、动态代理技术运行时动态生成、其他文件生成比如 JSP…）、怎样获取。</p><p>加载这一步主要是通过我们后面要讲到的 <strong>类加载器</strong> 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p><blockquote><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容在 <a href="https://blog-21n.pages.dev/2024/08/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/">类加载器详解</a> 这篇文章中有详细介绍到。</p></blockquote><p>每个 Java 类都有一个引用指向加载它的 ClassLoader。不过，数组类不是通过 ClassLoader 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 ClassLoader 的时候和该数组的元素类型的 ClassLoader 是一致的。</p><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code>方法）。</p><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是<strong>确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</strong>。</p><p>验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。</p><p>不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="验证阶段示意图"></p><p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。关于方法区的详细介绍，推荐阅读 <a href="https://javaguide.cn/java/jvm/memory-area.html">Java内存区域详解</a> 这篇文章。</p><p>符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p><p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：</p><ul><li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li><li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li><li>……</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被<code>static</code>关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。相关阅读：<a href="https://github.com/fenixsoft/jvm_book/issues/75">第三版7.3.3节272页勘误 · Issue #75 · fenixsoft&#x2F;jvm_book</a></li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value = 111</code>，那么 <code>value</code> 变量在准备阶段的初始值就是 <code>0</code> 而不是 <code>111</code>（初始化阶段才会赋值）。特殊情况：比如给 <code>value</code> 变量加上了 <code>final</code> 关键字<code>public static final int value=111</code>，那么准备阶段 <code>value</code> 的值就被赋值为 <code>111</code></li></ol><p>基本数据类型的零值：(图片来自《深入理解 Java 虚拟机》第 3 版 7.33 )</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><strong>解析阶段是虚拟机将常量池内的<strong><strong>符号引用</strong></strong>替换为<strong><strong>直接引用</strong></strong>的过程</strong>。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8.png" alt="符号引用和直接引用"></p><p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>初始化阶段是执行初始化方法</strong><code>**&lt;clinit&gt; ()**</code><strong>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码（字节码）</strong>。</p><p>说明：<code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p><p>对于<code>&lt;clinit&gt; ()</code>方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为       <code>&lt;clinit&gt; ()</code>方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 6 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 <code>new</code>、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条字节码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被<code>final</code>修饰)、或调用一个类的静态方法时。</li></ol><ul><li><ul><li>当 jvm 执行<code>new</code>指令时会初始化类。即当程序<strong>创建</strong>一个类的实例对象。</li><li>当 jvm 执行<code>getstatic</code>指令时会初始化类。即程序<strong>访问</strong>类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当 jvm 执行<code>putstatic</code>指令时会初始化类。即程序给类的静态变量<strong>赋值</strong>。</li><li>当 jvm 执行<code>invokestatic</code>指令时会初始化类。即程序<strong>调用</strong>类的静态方法。</li></ul></li></ul><ol><li>使用<code> java.lang.reflect</code>包的方法对类进行反射调用时如 <code>Class.forName(&quot;...&quot;)</code>，<code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含<code>main</code>方法的那个类)，虚拟机会先初始化这个类。</li><li><code>MethodHandle</code>和<code>VarHandle</code>可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用<code>findStaticVarHandle</code>来初始化要调用的类</li><li>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745</a>」 当一个接口中定义了 JDK8 新加入的默认方法（被<code>default</code> 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li></ol><h1 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h1><p>卸载这部分内容来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/662">issue#662</a>由 <a href="https://github.com/guang19">guang19</a> 补充完善</p><p><strong>卸载类即该类的 Class 对象被 GC。</strong></p><p>卸载类需要满足 3 个要求：</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用。</li><li>该类的类加载器的实例已被 GC。</li></ol><p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，JDK 自带的<code>BootstrapClassLoader</code>，<code>ExtClassLoader</code>，        <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们（类加载器的实例）肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解 Java 虚拟机》</p><p>《实战 Java 虚拟机》</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4">Chapter 5. Loading, Linking, and Initializing</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类文件结构详解</title>
    <link href="/2024/08/10/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/08/10/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://javaguide.cn/java/jvm/class-file-structure.html">类文件结构详解</a></p><p>作者：JavaGuide</p></blockquote><h1 id="字节码回顾"><a href="#字节码回顾" class="headerlink" title="字节码回顾"></a>字节码回顾</h1><p>在 Java 中，JVM 可以理解的代码就叫做<strong>字节码</strong>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Clojure（Lisp 语言的一种方言）、Groovy、Scala、JRuby、Kotlin 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成.class文件最终运行在 Java 虚拟机之上。.class文件的二进制格式可以使用 WinHexopen in new window 查看。</p><p>![运行在 Java 虚拟机之上的编程语言](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BF%90%E8%A1%8C%E5%9C%A8">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/运行在</a> Java 虚拟机之上的编程语言.png)</p><p>可以说.class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p><h1 id="Class-文件结构总结"><a href="#Class-文件结构总结" class="headerlink" title="Class 文件结构总结"></a>Class 文件结构总结</h1><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，有点类似 C 语言的结构体。</p><p><code>ClassFile</code> 的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassFile &#123;<br>    u4             magic; <span class="hljs-comment">//Class 文件的标志</span><br>    u2             minor_version;<span class="hljs-comment">//Class 的小版本号</span><br>    u2             major_version;<span class="hljs-comment">//Class 的大版本号</span><br>    u2             constant_pool_count;<span class="hljs-comment">//常量池的数量</span><br>    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<span class="hljs-comment">//常量池</span><br>    u2             access_flags;<span class="hljs-comment">//Class 的访问标记</span><br>    u2             this_class;<span class="hljs-comment">//当前类</span><br>    u2             super_class;<span class="hljs-comment">//父类</span><br>    u2             interfaces_count;<span class="hljs-comment">//接口数量</span><br>    u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span><br>    u2             fields_count;<span class="hljs-comment">//字段数量</span><br>    field_info     fields[fields_count];<span class="hljs-comment">//一个类可以有多个字段</span><br>    u2             methods_count;<span class="hljs-comment">//方法数量</span><br>    method_info    methods[methods_count];<span class="hljs-comment">//一个类可以有个多个方法</span><br>    u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span><br>    attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过分析 <code>ClassFile</code> 的内容，我们便可以知道 class 文件的组成。</p><p>![ClassFile 内容分析](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/ClassFile">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/ClassFile</a> 内容分析.jpeg)</p><p>下面这张图是通过 IDEA 插件 <code>jclasslib</code> 查看的，你可以更直观看到 Class 文件结构。</p><p>![Class 文件结构](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Class">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Class</a> 文件结构.png)</p><p>使用 <code>jclasslib</code> 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。</p><p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p><h2 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u4             magic;  <span class="hljs-comment">// Class 文件的标志</span><br></code></pre></td></tr></table></figure><p>每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。Java 规范规定魔数为固定值：<code>0xCAFEBABE</code>。如果读取的文件不是以这个魔数开头，Java 虚拟机将拒绝加载它。</p><h2 id="Class-文件版本号（Minor-amp-Major-Version）"><a href="#Class-文件版本号（Minor-amp-Major-Version）" class="headerlink" title="Class 文件版本号（Minor&amp;Major Version）"></a>Class 文件版本号（Minor&amp;Major Version）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             minor_version;  <span class="hljs-comment">// Class 的小版本号</span><br>u2             major_version;  <span class="hljs-comment">// Class 的大版本号</span><br></code></pre></td></tr></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是<strong>次版本号</strong>，第 7 和第 8 个字节是<strong>主版本号</strong>。</p><p>每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用       <code>javap -v</code> 命令来快速查看 Class 文件的版本号信息。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h2 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             constant_pool_count;  <span class="hljs-comment">// 常量池的数量</span><br>cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];  <span class="hljs-comment">// 常量池</span><br></code></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：<strong>字面量</strong>和<strong>符号引用</strong>。</p><p>字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。</p><p>而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型</strong>。</p><table><thead><tr><th>类型</th><th>标志（tag）</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8 编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整形字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_FieldRef_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_MethodRef_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodRef_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code>：将结果输出到 temp.txt 文件)。</p><h2 id="访问标志-Access-Flags"><a href="#访问标志-Access-Flags" class="headerlink" title="访问标志(Access Flags)"></a>访问标志(Access Flags)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             access_flags;  <span class="hljs-comment">// Class 的访问标记</span><br></code></pre></td></tr></table></figure><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p><p>类访问和属性修饰符：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%92%8C%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt="类访问和属性修饰符"></p><p>我们定义了一个 <code>Employee</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.snailclimb.bean;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>javap -v class类名</code>指令来看一下类的访问标志。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="查看类的访问标志"></p><h2 id="当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合"><a href="#当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合" class="headerlink" title="当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合"></a>当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             this_class;  <span class="hljs-comment">// 当前类</span><br>u2             super_class;  <span class="hljs-comment">// 父类</span><br>u2             interfaces_count;  <span class="hljs-comment">// 接口数量</span><br>u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span><br></code></pre></td></tr></table></figure><p>Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后。</p><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p><h2 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             fields_count;<span class="hljs-comment">//字段数量</span><br>field_info     fields[fields_count];<span class="hljs-comment">//一个类会可以有个字段</span><br></code></pre></td></tr></table></figure><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构：</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构"></p><ul><li><strong>access_flags：</strong>字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符），可否被序列化（transient 修饰符），可变性（final），可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index：</strong>对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index：</strong>对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count：</strong>一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]：</strong>存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flag 的取值：</strong></p><p>![字段的 access_flag 的取值](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AD%97%E6%AE%B5%E7%9A%84">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/字段的</a> access_flag 的取值.png)</p><h2 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             methods_count;  <span class="hljs-comment">// 方法数量</span><br>method_info    methods[methods_count];  <span class="hljs-comment">// 一个类可以有个多个方法</span><br></code></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构：</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p><p>方法表的 access_flag 取值：</p><p>![方法表的 access_flag 取值](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/方法表的</a> access_flag 取值.png)</p><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h2 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span><br>attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span><br></code></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《实战 Java 虚拟机》</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">Chapter 4. The class File Format</a></li><li><a href="https://coolshell.cn/articles/9229.html">实例分析Java Class的文件结构 | 酷 壳 - CoolShell</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/39960815">《Java虚拟机原理图解》 1.2.2、Class文件中的常量池详解（上）-CSDN博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现在线人数统计功能</title>
    <link href="/2024/08/10/Redis%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
    <url>/2024/08/10/Redis%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E4%BA%BA%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在线人数统计有多种实现方式，本文使用 Redis 的有序集合数据类型来实现。</p><p>核心方法：<code>zadd</code>、<code>zrangeByScore</code>、<code>zremrangeByScore</code>、<code>zrem</code>。</p><h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><h2 id="如何认定用户是否在线？"><a href="#如何认定用户是否在线？" class="headerlink" title="如何认定用户是否在线？"></a>如何认定用户是否在线？</h2><p>认定用户在线的条件一般跟网站有关，如果网站需要登录才能进入，那么这种网站就是根据用户的token令牌有效性判断是否在线；</p><p>如果网站是公开的，是那种不需要登录就可以浏览的，那么这种网站一般就需要自定一个规则来识别用户，也有很多方式实现如<strong>IP</strong>、<strong>deviceId</strong>、<strong>浏览器指纹</strong>，推荐使用<strong>浏览器指纹</strong>的方式实现。</p><p>浏览器指纹可能包括以下信息的组合：用户代理字符串 (User-Agent string)、HTTP请求头信息、屏幕分辨率和颜色深度、时区和语言设置、浏览器插件详情等。现成的JavaScript库，像 FingerprintJS 或 ClientJS，可以帮助简化这个过程，因为它们已经实现了收集上述信息并生成唯一标识的算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 安装：npm install @fingerprintjs/fingerprintjs</span><br><br><span class="hljs-comment">// 使用示例：</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">FingerprintJS</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fingerprintjs/fingerprintjs&#x27;</span>;<br><br><span class="hljs-comment">// 初始化指纹JS Library</span><br><span class="hljs-title class_">FingerprintJS</span>.<span class="hljs-title function_">load</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">fp</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取访客ID</span><br>  fp.<span class="hljs-title function_">get</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> visitorId = result.<span class="hljs-property">visitorId</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(visitorId);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样就可以获取一个访问公开网站的用户的唯一ID了，当用户访问网站的时候，将这个ID放到访问链接的Cookie或者header中传到后台，后端服务根据这个ID标示用户。</p><h2 id="zadd命令添加在线用户"><a href="#zadd命令添加在线用户" class="headerlink" title="zadd命令添加在线用户"></a><code>zadd</code>命令添加在线用户</h2><p><strong>（1）zadd 命令介绍</strong> </p><p><code>zadd</code> 命令有三个参数 <code>ZADD key score &quot;member&quot;</code>：</p><ul><li><code>key</code>：有序集合的名称。 </li><li><code>score1</code>、<code>score2</code> 等：分数值，可以是整数值或双精度浮点数。 </li><li><code>member1</code>、<code>member2</code> 等：要添加到有序集合的成员。</li></ul><p><strong>示例：</strong>向有序集合<code>myzset</code>中添加一个成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZADD myzset 1 <span class="hljs-string">&quot;one&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（2）添加在线用户标识到有序集合中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// expireTime给用户令牌设置了一个过期时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().plusSeconds(expireTimeout);<br><span class="hljs-type">String</span> <span class="hljs-variable">expireTimeStr</span> <span class="hljs-operator">=</span> DateUtil.formatFullTime(expireTime);<br><span class="hljs-comment">// 添加用户token到有序集合中</span><br>redisService.zadd(<span class="hljs-string">&quot;user.active&quot;</span>, Double.parseDouble(expireTimeStr), userToken);<br></code></pre></td></tr></table></figure><p>由于一个用户可能会重复登录，这就导致<code>userToken</code>也会重复，但为了不重复计算这个用户的访问次数，<code>zadd</code>命令的第二个参数很好的解决了这个问题。</p><p>我这里的逻辑是：每次添加一个在线用户时，利用<strong>当前时间</strong>加上<strong>过期时间</strong>计算出一个分数，可以有效保证当前用户只会存在一个最新的登录态。</p><h2 id="zrangeByScore命令查询在线人数"><a href="#zrangeByScore命令查询在线人数" class="headerlink" title="zrangeByScore命令查询在线人数"></a><code>zrangeByScore</code>命令查询在线人数</h2><p><strong>（1）zrangeByScore命令介绍</strong></p><ul><li><code>key</code>：指定的有序集合的名字。 </li><li><code>min</code> 和 <code>max</code>：定义了查询的分数范围，也可以是 -inf 和 +inf（分别表示“负无穷大”和“正无穷大”）。</li></ul><p><strong>示例：</strong>查询有序集合<code>myzset</code>中分数在 1 到 3 之间的所有成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZRANGEBYSCORE myzset 1 3<br></code></pre></td></tr></table></figure><p><strong>（2）查询当前所有的在线用户</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前的日期</span><br><span class="hljs-type">String</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> DateUtil.formatFullTime(LocalDateTime.now());<br><span class="hljs-comment">// 查询当前日期到&quot;+inf&quot;之间所有的用户</span><br>Set&lt;String&gt; userOnlineStringSet = redisService.zrangeByScore(<span class="hljs-string">&quot;user.active&quot;</span>, now, <span class="hljs-string">&quot;+inf&quot;</span>);<br></code></pre></td></tr></table></figure><p>利用<code>zrangeByScore</code>方法可以查询这个有序集合指定范围内的用户，</p><p>这<code>userOnlineStringSet</code>也就是在线用户集，它的<code>size</code>就是在线人数了。</p><h2 id="zremrangeByScore命令定时清除在线用户"><a href="#zremrangeByScore命令定时清除在线用户" class="headerlink" title="zremrangeByScore命令定时清除在线用户"></a><code>zremrangeByScore</code>命令定时清除在线用户</h2><p><strong>（1）zremrangeByScore命令介绍</strong></p><ul><li><code>key</code>：指定的有序集合的名字。 </li><li><code>min</code> 和 <code>max</code>：定义了查询的分数范围，也可以是 -inf 和 +inf（分别表示“负无穷大”和“正无穷大”）。</li></ul><p> <strong>示例：</strong>删除有序集合<code>myzset</code>分数在 1 到 3 之间的所有成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ZREMRANGEBYSCORE myzset <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>（2）定时清除在线用户</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取当前的日期</span><br><span class="hljs-type">String</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> DateUtil.formatFullTime(LocalDateTime.now());<br><span class="hljs-comment">// 清除当前日期到&quot;-inf&quot;之间所有的用户</span><br>redisService.zremrangeByScore(<span class="hljs-string">&quot;&quot;</span>user.active<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;-inf&quot;</span>, now);      <br></code></pre></td></tr></table></figure><p>由于有序集合不会自动清理下线的用户，所以这里我们需要写一个定时任务去定时删除下线的用户。</p><h2 id="zrem命令用户退出登录时删除成员"><a href="#zrem命令用户退出登录时删除成员" class="headerlink" title="zrem命令用户退出登录时删除成员"></a><code>zrem</code>命令用户退出登录时删除成员</h2><p><strong>（1）zrem命令介绍</strong></p><ul><li><code>key</code>：指定的有序集合的名字。 </li><li><code>members</code>：需要删除的成员。</li></ul><p><strong>示例：</strong>删除<code>myzset</code>有序集合中名为<code>xxx</code>的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ZREM myzset <span class="hljs-string">&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（2）定时清除在线用户</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除名为xxx的成员</span><br>redisService.zrem(<span class="hljs-string">&quot;user.active&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>);      <br></code></pre></td></tr></table></figure><p>删除<code>zset</code>中的记录，确保主动退出的用户下线。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这种方案的核心逻辑就是，创建一个<strong>在线用户身份集合</strong>为<code>key</code>，利用<strong>用户身份</strong>为<code>member</code>，利用<strong>过期时间</strong>为<code>score</code>，然后对这个集合进行增删改查，实现起来还是比较巧妙和简单的，大家有兴趣可以试试看。</p><hr><p>来源：<a href="https://juejin.cn/post/7356065093060427816">https://juejin.cn/post/7356065093060427816</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于system目录</title>
    <link href="/2024/05/06/%E5%85%B3%E4%BA%8Esystem%E7%9B%AE%E5%BD%95/"/>
    <url>/2024/05/06/%E5%85%B3%E4%BA%8Esystem%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>linux 系统中有很多的 system 目录，常看到的有<code>/etc/systemd/system</code>、<code>/lib/systemd/system</code>以及<code>/usr/lib/systemd/system</code>等。</p><h1 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h1><h2 id="lib和-usr-lib一样"><a href="#lib和-usr-lib一样" class="headerlink" title="/lib和/usr/lib一样"></a><code>/lib</code>和<code>/usr/lib</code>一样</h2><p>目录<code>/lib/systemd/system</code>以及<code>/usr/lib/systemd/system</code>其实指向的是同一目录。</p><p>在<code>/</code>目录下<code>ll</code>可知：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost /]# ll<br>total 28<br>lrwxrwxrwx.   1 root root    7 Jul  3 09:43 bin -&gt; usr/bin<br>dr-xr-xr-x.   5 root root 4096 Jul 19 12:04 boot<br>drwxr-xr-x.  19 root root 3080 Jul 19 04:03 dev<br>drwxr-xr-x.  76 root root 8192 Jul 19 20:07 etc<br>drwxr-xr-x.   4 root root   39 Jul 19 04:37 home<br>lrwxrwxrwx.   1 root root    7 Jul  3 09:43 lib -&gt; usr/lib<br>lrwxrwxrwx.   1 root root    9 Jul  3 09:43 lib64 -&gt; usr/lib64<br></code></pre></td></tr></table></figure><p><code>[/usr]/lib/systemd/system/</code>目录中包含的是软件包安装的单元，也就是说通过yum、dnf、rpm 等软件包管理命令管理的 systemd 单元文件，都放置在该目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[/usr]/lib/systemd/system/<br>The expectation is that `/lib/systemd/system` is a directory that should only contain systemd unit files which were put there by the package manager (YUM/DNF/RPM/APT/etc).<br></code></pre></td></tr></table></figure><h2 id="etc-systemd-system-与前二者关系"><a href="#etc-systemd-system-与前二者关系" class="headerlink" title="/etc/systemd/system/与前二者关系"></a><code>/etc/systemd/system/</code>与前二者关系</h2><p><code>/etc/systemd/system/</code>：系统管理员安装的单元，优先级更高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Files in /etc/systemd/system are manually placed here by the operator of the system for ad-hoc software installations that are not in the form of a package. This would include tarball type software installations or home grown scripts.<br></code></pre></td></tr></table></figure><p>在一般的使用场景下，每一个 Unit（服务等） 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p><p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在<code>/usr/lib/systemd/system/</code>这个目录。</p><p><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> clamd@scan.service</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">等同于</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">ln</span> -s <span class="hljs-string">&#x27;/usr/lib/systemd/system/clamd@scan.service&#x27;</span> <span class="hljs-string">&#x27;/etc/systemd/system/multi-user.target.wants/clamd@scan.service&#x27;</span></span><br></code></pre></td></tr></table></figure><p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p><p>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">disable</span> clamd@scan.service</span><br></code></pre></td></tr></table></figure><p>虽然在<code>/etc/systemd/system/</code>目录下放置的是系统管理员安装的单元，但是实际使用过程中，用户可以自定义服务配置文件，并且放置在该目录，将该服务的配置文件的优先级提高。</p><p>比如在该目录下创建 redis.service 设置 redis 服务开机自启，见：<a href="https://www.yuque.com/kingshit/wz61vk/ptk89rc8yb290xfv">Redis 安装配置</a>。</p><h2 id="扩展：-run-systemd-system目录"><a href="#扩展：-run-systemd-system目录" class="headerlink" title="扩展：/run/systemd/system目录"></a>扩展：<code>/run/systemd/system</code>目录</h2><p><code>/run/systemd/system</code>这个目录一般是进程在运行时动态创建 unit 文件的目录，一般很少修改，除非是修改程序运行时的一些参数时，即 Session 级别的，才在这里做修改。</p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p><code>systemd</code>的使用大幅提高了系统服务的运行效率, 而unit的文件位置一般主要有三个目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">Table 1.  Load path when running in system mode (--system).<br>┌────────────────────────┬─────────────────────────────┐<br>│Path                    │ Description                 │<br>├────────────────────────┼─────────────────────────────┤<br>│/etc/systemd/system     │ Local configuration         │<br>├────────────────────────┼─────────────────────────────┤<br>│/run/systemd/system     │ Runtime units               │<br>├────────────────────────┼─────────────────────────────┤<br>│/lib/systemd/system     │ Units of installed packages │<br>└────────────────────────┴─────────────────────────────┘<br></code></pre></td></tr></table></figure><p>这三个目录的配置文件优先级依次从高到低，如果同一选项三个地方都配置了，优先级高的会覆盖优先级低的。</p><p>系统安装时，默认会将 unit 文件放在<code>/lib/systemd/system</code>目录。如果我们想要修改系统默认的配置，比如<code>nginx.service</code>，一般有两种方法：</p><ul><li>在<code>/etc/systemd/system</code>目录下创建<code>nginx.service</code>文件，里面写上我们自己的配置。</li><li>在<code>/etc/systemd/system</code>下面创建<code>nginx.service.d</code>目录，在这个目录里面新建任何以<code>.conf</code>结尾的文件，然后写入我们自己的配置。推荐这种做法。</li></ul><h1 id="附systemd介绍"><a href="#附systemd介绍" class="headerlink" title="附systemd介绍"></a>附systemd介绍</h1><p>服务设定位置：</p><ul><li>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;</li><li>&#x2F;run&#x2F;systemd&#x2F;system&#x2F;</li><li>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;（一般为连接文件）</li></ul><p>服务统一管理：systemd</p><p>service设定文件：</p><ul><li>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;*.service: 预设设定文件</li><li>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;system&#x2F;*.service.d&#x2F;: 用户个性化设定文件，会被加入设定</li><li>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;system&#x2F;*.service.wants&#x2F;: 连结文件，启动该服务后推荐启动的其他服务</li><li>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;system&#x2F;*.service.requires&#x2F;: 连结文件，启动该服务之前，需要预先启动的服务</li><li>&#x2F;run&#x2F;systemd&#x2F;generator.late 使用 systemd-sysv-generator工具处理 SysV init脚本（即：&#x2F;etc&#x2F;init.d&#x2F;*），自动生成.service文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>文件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Java 编程风格指南</title>
    <link href="/2023/11/14/Google%20Java%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <url>/2023/11/14/Google%20Java%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://hawstein.com/2014/01/20/google-java-style/">https://hawstein.com/2014/01/20/google-java-style/</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h2 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h2><p>在本文档中，除非另有说明：</p><ol><li>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)</li><li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li></ol><p>其他的术语说明会偶尔在后面的文档出现。</p><h2 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h2><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p><h1 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h1><h2 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。</p><h2 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h2><p>源文件编码格式为UTF-8。</p><h2 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h2><h3 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ol><li>所有其它字符串中的空白字符都要进行转义。</li><li>制表符不用于缩进。</li></ol><h3 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h3><p>对于具有特殊<a href="http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">转义序列</a>的任何字符(\b, \t, \n, \f, \r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p><h3 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p><p><em>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</em></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">unitAbbrev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;μs&quot;</span>;                                <span class="hljs-comment">// 赞，即使没有注释也非常清晰</span><br><span class="hljs-type">String</span> <span class="hljs-variable">unitAbbrev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\u03bcs&quot;</span>; <span class="hljs-comment">// &quot;μs&quot;                   // 允许，但没有理由要这样做</span><br><span class="hljs-type">String</span> <span class="hljs-variable">unitAbbrev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\u03bcs&quot;</span>; <span class="hljs-comment">// Greek letter mu, &quot;s&quot;   // 允许，但这样做显得笨拙还容易出错</span><br><span class="hljs-type">String</span> <span class="hljs-variable">unitAbbrev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\u03bcs&quot;</span>;                           <span class="hljs-comment">// 很糟，读者根本看不出这是什么</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\ufeff&#x27;</span> + content; <span class="hljs-comment">// byte order mark            // Good，对于非打印字符，使用转义，并在必要时写上注释</span><br></code></pre></td></tr></table></figure><p><em>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</em></p><h1 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h1><p>一个源文件包含(按顺序地)：</p><ol><li>许可证或版权信息(如有需要)</li><li>package语句</li><li>import语句</li><li>一个顶级类(<strong>只有一个</strong>)</li></ol><p>以上每个部分之间用一个空行隔开。</p><h2 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h2 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h2><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p><h2 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h2><h3 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h3><p>即，不要出现类似这样的import语句：import java.util.*;</p><h3 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h3><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p><h3 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h3><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p><ol><li>所有的静态导入独立成组</li><li>com.google imports(仅当这个源文件是在com.google包下)</li><li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li><li>java imports</li><li>javax imports</li></ol><p>组内不空行，按字典序排列。</p><h2 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h2><h3 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p><p>例外：package-info.java，该文件中可没有package-info类。</p><h3 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h4 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h4><p>当一个类有多个构造函数，或是多个同名方法，这些函数&#x2F;方法应该按顺序出现在一起，中间不要放进其它函数&#x2F;方法。</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p><strong>术语说明</strong>：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p><h2 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h2><h3 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h3><p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p><h3 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h3><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>() &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (condition()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                something();<br>            &#125; <span class="hljs-keyword">catch</span> (ProblemException e) &#123;<br>                recover();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>4.8.1节给出了enum类的一些例外。</p><h3 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if&#x2F;else 或 try&#x2F;catch&#x2F;finally) ，即使大括号内没内容，右大括号也要换行。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br><br>void doNothing() &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h2><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p><h2 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h2><p>每个语句后要换行。</p><h2 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p><p>例外：</p><ol><li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)。</li><li>注释中那些可能被剪切并粘贴到shell中的命令行。</li></ol><h2 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h2><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p><p><em>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</em></p><h3 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p><ol><li>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li><li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如&#x3D;，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(,)与其前面的内容留在同一行。</li></ol><h3 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h2 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h2><h3 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h3><p>以下情况需要使用一个空行：</p><ol><li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。</li></ol><ul><li><ul><li><strong>例外</strong>：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li></ul></li></ul><ol><li>在函数体内，语句的逻辑分组间使用空行。</li><li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li><li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li></ol><p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p><h3 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p><ol><li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li><li>分隔任何保留字与其前面的右大括号(<code>&#125;</code>)(如<code>else, catch</code>)。</li><li>在任何左大括号前(<code>&#123;</code>)，两个例外：</li></ol><ul><li><ul><li><code>@SomeAnnotation(&#123;a, b&#125;)</code>(不使用空格)。</li><li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li></ul></li></ul><ol><li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：</li></ol><ul><li><ul><li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li><li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li><li><code>foreach</code>语句中的分号。</li></ul></li></ul><ol><li>在<code>, : ;</code>及右括号(<code>)</code>)后</li><li>如果在一条语句后做注释，则双斜杠(&#x2F;&#x2F;)两边都要空格。这里可以允许多个空格，但没有必要。</li><li>类型和变量之间：List list。</li><li>数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</li></ol><p><em>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</em></p><h3 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h3><p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p><p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p><p>以下示例先展示未对齐的代码，然后是对齐的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x; <span class="hljs-comment">// this is fine</span><br><span class="hljs-keyword">private</span> Color color; <span class="hljs-comment">// this too</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>   x;      <span class="hljs-comment">// permitted, but future edits</span><br><span class="hljs-keyword">private</span> Color color;  <span class="hljs-comment">// may leave it unaligned</span><br></code></pre></td></tr></table></figure><p><em>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</em></p><h2 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h2><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p><h2 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h2><h3 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p><p>没有方法和文档的枚举类可写成数组初始化的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Suit</span> &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;<br></code></pre></td></tr></table></figure><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h3 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h3><h4 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h4><p>不要使用组合声明，比如int a, b;。</p><h4 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h3 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h3><h4 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span>,<br>    <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h4><p>中括号是类型的一部分：String[] args， 而非String args[]。</p><h3 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h3><p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p><h4 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h4><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p><p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p><h4 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h4><p>在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用&#x2F;&#x2F; fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (input) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        prepareOneOrTwo();<br>        <span class="hljs-comment">// fall through</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        handleOneTwoOrThree();<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        handleLargeNumber(input);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h4><p>每个switch语句都包含一个default语句组，即使它什么代码也不包含。</p><h3 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNameIfPresent</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p><strong>例外</strong>：单个的注解可以和签名的第一行出现在同一行。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br><br>@Override public int hashCode() &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br><br>@Partial @Mock DataLoader loader;<br></code></pre></td></tr></table></figure><p>参数和局部变量注解没有特定规则。</p><h3 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h3><h4 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是&#x2F;* … <em>&#x2F;风格，也可以是&#x2F;&#x2F; …风格。对于多行的&#x2F;</em> … <em>&#x2F;注释，后续行必须从</em>开始， 并且与前一行的*对齐。以下示例注释都是OK的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br><br>/*<br> * This is          // And so           /* Or you can<br> * okay.            // is this.          * even do this. */<br> */<br></code></pre></td></tr></table></figure><p>注释不要封闭在由星号或其它字符绘制的框架里。</p><p><em>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用</em> *&#x2F;* … *&#x2F;*<em>。</em></p><h3 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h3><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br><br>public protected private abstract static final transient volatile synchronized native strictfp<br></code></pre></td></tr></table></figure><h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h2><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p><h2 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h2><h3 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h3><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p><h3 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h3><p>类名都以UpperCamelCase风格编写。</p><p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p><h3 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h3><p>方法名都以lowerCamelCase风格编写。</p><p>方法名通常是动词或动词短语。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test<MethodUnderTest>_<state>，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。</p><h3 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h3><p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p><p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Constants</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="hljs-string">&quot;Ed&quot;</span>, <span class="hljs-string">&quot;Ann&quot;</span>);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Joiner</span> <span class="hljs-variable">COMMA_JOINER</span> <span class="hljs-operator">=</span> Joiner.on(<span class="hljs-string">&#x27;,&#x27;</span>);  <span class="hljs-comment">// because Joiner is immutable</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SomeEnum</span> &#123; ENUM_CONSTANT &#125;<br><br><span class="hljs-comment">// Not constants</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">nonFinal</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;non-final&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">nonStatic</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;non-static&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(MyClass.getName());<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] nonEmptyArray = &#123;<span class="hljs-string">&quot;these&quot;</span>, <span class="hljs-string">&quot;can&quot;</span>, <span class="hljs-string">&quot;change&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>这些名字通常是名词或名词短语。</p><h3 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h3><p>非常量字段名以lowerCamelCase风格编写。</p><p>这些名字通常是名词或名词短语。</p><h3 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h3><p>参数名以lowerCamelCase风格编写。</p><p>参数应该避免用单个字符命名。</p><h3 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h3><p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p><p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p><p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p><h3 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li></ul><h2 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h2><p><a href="http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰式命名法</a>分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ol><li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。</li></ol><ul><li><ul><li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li></ul><ol><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：</li></ol><ul><li><ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li></ul><ol><li>最后将所有的单词连接起来得到一个标识符。</li></ol><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">Prose form                Correct               Incorrect<br>------------------------------------------------------------------<br>&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest<br>&quot;new customer ID&quot;         newCustomerId         newCustomerID<br>&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch<br>&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS<br>&quot;YouTube importer&quot;        YouTubeImporter<br>                          YoutubeImporter*<br></code></pre></td></tr></table></figure><p>加星号处表示可以，但不推荐。</p><p><em>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<strong>checkNonempty</strong>和<strong>checkNonEmpty</strong>也都是正确的。</em></p><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h2><p>只要是合法的，就把@Override注解给用上。</p><h2 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)</p><p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br>5<br>6<br>7<br><br>try &#123;<br>  int i = Integer.parseInt(response);<br>  return handleNumericResponse(i);<br>&#125; catch (NumberFormatException ok) &#123;<br>  // it&#x27;s not numeric; that&#x27;s fine, just continue<br>&#125;<br>return handleTextResponse(response);<br></code></pre></td></tr></table></figure><p><strong>例外</strong>：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br>5<br><br>try &#123;<br>  emptyStack.pop();<br>  fail();<br>&#125; catch (NoSuchElementException expected) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br><br>Foo aFoo = ...;<br>Foo.aStaticMethod(); // good<br>aFoo.aStaticMethod(); // bad<br>somethingThatYieldsAFoo().aStaticMethod(); // very bad<br></code></pre></td></tr></table></figure><h2 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h2><p>极少会去重写Object.finalize。</p><p><em>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解</em> <a href="http://books.google.com/books?isbn=8131726592">Effective Java</a> <em>第7条款：“Avoid Finalizers”，然后不要使用它。</em></p><h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><h2 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h2><h3 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h3><p>Javadoc块的基本格式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Multiple lines of Javadoc text are written here,</span><br><span class="hljs-comment"> * wrapped normally...</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(String p1)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>或者是以下单行形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** An especially short bit of Javadoc. */</span><br></code></pre></td></tr></table></figure><p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p><h3 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<p>，并且它和第一个单词间没有空格。</p><h3 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h3><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p><h2 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h2><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a…或This method returns…开头, 它也不会是一个完整的祈使句，如Save the record…。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><p><em>Tip：一个常见的错误是把简单的Javadoc写成</em><em>&#x2F;</em>* @return the customer ID *&#x2F;<strong>，这是不正确的。它应该写成</strong>&#x2F;** Returns the customer ID. *&#x2F;*<em>。</em></p><h2 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h2><p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p><h3 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h3><p>对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><p><em>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<strong>getCanonicalName</strong>， 就不应该忽视文档说明，因为读者很可能不知道词语<strong>canonical name</strong>指的是什么。</em></p><h3 id="7-3-2-例外：重写"><a href="#7-3-2-例外：重写" class="headerlink" title="7.3.2 例外：重写"></a>7.3.2 例外：重写</h3><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p><h3 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p><hr><h1 id="本文来源"><a href="#本文来源" class="headerlink" title="本文来源"></a>本文来源</h1><p>本文档翻译自 <a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html">Google Java Style</a>， 译者 <a href="http://weibo.com/hawstein">@Hawstein</a>。</p><p>出处：<a href="https://hawstein.com/2014/01/20/google-java-style/">https://hawstein.com/2014/01/20/google-java-style/</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>开发效率</category>
      
      <category>规范指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 访问数据库</title>
    <link href="/2023/10/17/Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/10/17/Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为<code>Connection</code>；</p><p>连接到数据库后，需要打开游标，称之为<code>Cursor</code>，通过<code>Cursor</code>执行 SQL 语句，然后，获得执行结果。</p><p>Python 定义了一套操作数据库的 API 接口，任何数据库要连接到 Python，只需要提供符合 Python 标准的数据库驱动即可。</p><h1 id="一、常用数据库"><a href="#一、常用数据库" class="headerlink" title="一、常用数据库"></a>一、常用数据库</h1><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 是一种嵌入式数据库，它的数据库就是一个文件。由于 SQLite 本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在 iOS 和 Android 的 App 中都可以集成。Python 就内置了 SQLite3。</p><h3 id="导入数据库模块"><a href="#导入数据库模块" class="headerlink" title="导入数据库模块"></a>导入数据库模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">import sqlite3<br></code></pre></td></tr></table></figure><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>在 python 中，使用 sqlite3 创建数据库的连接，当我们指定的数据库文件不存在的时候连接对象会自动创建数据库文件；如果数据库文件已经存在，则连接对象不会再创建数据库文件，而是直接打开该数据库文件。</p><p>连接对象可以是<strong>硬盘</strong>上面的数据库文件，也可以是建立在<strong>内存</strong>（memory）中的，在内存中的数据库执行完任何操作后，都不需要提交事务的(commit)</p><p><code>connect</code>方法返回<code>con</code>对象，即是数据库链接对象，它提供了以下方法：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.cursor()</td><td>创建一个游标对象</td></tr><tr><td>.commit()</td><td>处理事务提交</td></tr><tr><td>.rollback()</td><td>处理事务回滚</td></tr><tr><td>.close()</td><td>关闭一个数据库连接</td></tr></tbody></table><h4 id="在硬盘上建立数据库"><a href="#在硬盘上建立数据库" class="headerlink" title="在硬盘上建立数据库"></a>在硬盘上建立数据库</h4><ul><li>数据库的名称不区分大小写，且以第一次建立时的名字为准。</li><li>不加全路径时，数据库文件会自动建立在工程项目文件夹下。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">con=sqlite3.connect(<span class="hljs-string">&quot;D:\Test.db&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="在内存上建立数据库"><a href="#在内存上建立数据库" class="headerlink" title="在内存上建立数据库"></a>在内存上建立数据库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">con = sqlite3.connect(<span class="hljs-string">&quot;memory&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cur = con.cursor()<br></code></pre></td></tr></table></figure><p>游标对象有以下方法支持数据库操作：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>.execute()</td><td>用来执行sql语句</td></tr><tr><td>.executemany()</td><td>用来执行多条sql语句</td></tr><tr><td>.close()</td><td>用来关闭游标</td></tr><tr><td>.fetchone()</td><td>用来从结果中取一条记录，并将游标指向下一条记录</td></tr><tr><td>.fetchmany()</td><td>用来从结果中取多条记录。</td></tr><tr><td>.fetchall()</td><td>用来从结果中取出所以记录。</td></tr><tr><td>.scroll()</td><td>用于游标滚动。</td></tr></tbody></table><p>注意：使用游标的方法返回的数据类型是列表。</p><h3 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h3><h3 id="事务提交或回滚"><a href="#事务提交或回滚" class="headerlink" title="事务提交或回滚"></a>事务提交或回滚</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提交</span><br>con.commit()<br><br><span class="hljs-comment"># 回滚</span><br>con.rollback()<br><br><span class="hljs-comment"># 关闭游标</span><br>cur.close()<br><span class="hljs-comment"># 关闭数据库连接</span><br>con.close()<br></code></pre></td></tr></table></figure><p>注意：一定要先关闭游标，再关闭数据库连接，否则会报错！</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>SQLite 的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用。而MySQL 是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于 SQLite。</p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>由于 MySQL 服务器以独立的进程运行，并通过网络对外服务，所以，需要支持 Python 的 MySQL 驱动来连接到 MySQL 服务器。</p><p>MySQL 官方提供了 mysql-connector-python 驱动，但是安装的时候需要给 <code>pip</code> 命令加上参数<code>--allow-external</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install mysql-connector-python --allow-external mysql-connector-python<br><span class="hljs-comment"># 如果上面的命令安装失败，可以试试另一个驱动：</span><br>pip install mysql-connector<br></code></pre></td></tr></table></figure><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 导入MySQL驱动:</span><br>&gt;&gt;&gt; import mysql.connector<br><br><span class="hljs-comment"># 注意把password设为你的root口令:</span><br>&gt;&gt;&gt; conn = mysql.connector.connect(user=<span class="hljs-string">&#x27;root&#x27;</span>, password=<span class="hljs-string">&#x27;password&#x27;</span>, database=<span class="hljs-string">&#x27;test&#x27;</span>)<br>&gt;&gt;&gt; cursor = conn.cursor()<br><br><span class="hljs-comment"># 创建user表:</span><br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;</span>)<br><br><span class="hljs-comment"># 插入一行记录，注意MySQL的占位符是%s:</span><br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;insert into user (id, name) values (%s, %s)&#x27;</span>, [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>])<br>&gt;&gt;&gt; cursor.rowcount<br>1<br><br><span class="hljs-comment"># 提交事务:</span><br>&gt;&gt;&gt; conn.commit()<br>&gt;&gt;&gt; cursor.close()<br><br><span class="hljs-comment"># 运行查询:</span><br>&gt;&gt;&gt; cursor = conn.cursor()<br>&gt;&gt;&gt; cursor.execute(<span class="hljs-string">&#x27;select * from user where id = %s&#x27;</span>, (<span class="hljs-string">&#x27;1&#x27;</span>,))<br>&gt;&gt;&gt; values = cursor.fetchall()<br>&gt;&gt;&gt; values<br>[(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>)]<br><br><span class="hljs-comment"># 关闭Cursor和Connection:</span><br>&gt;&gt;&gt; cursor.close()<br>True<br>&gt;&gt;&gt; conn.close()<br></code></pre></td></tr></table></figure><h1 id="二、使用-ORM-框架"><a href="#二、使用-ORM-框架" class="headerlink" title="二、使用 ORM 框架"></a>二、使用 ORM 框架</h1><h2 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>数据库表是一个二维表，包含多行多列。把一个表的内容用 Python 的数据结构表示出来的话，可以用一个<code>list</code>表示多行，<code>list</code>的每一个元素是 <code>tuple</code>，表示一行记录，比如，包含<code>id</code>和<code>name</code>的<code>use</code> 表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[<br>    (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>),<br>    (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>),<br>    (<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure><p>Python 的 DB-API 返回的数据结构就是像上面这样表示的。</p><p>但是用<code>tuple</code>表示一行很难看出表的结构。如果把一个<code>tuple</code>用 <code>class</code> 实例来表示，就可以更容易地看出表的结构来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br><br>[<br>    User(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>),<br>    User(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>),<br>    User(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure><p>这就是传说中的 ORM 技术：<strong>Object-Relational Mapping</strong>，把<strong>关系数据库的表结构映射到对象上</strong>。</p><p>但是由谁来做这个转换呢？</p><p>所以 ORM 框架应运而生。在 Python 中，最有名的 ORM 框架是 SQLAlchemy。我们来看看 SQLAlchemy 的用法。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install sqlalchemy<br></code></pre></td></tr></table></figure><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SQLAlchemy 的初始化和对象定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入:</span><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, String, create_engine<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker<br><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br><br><span class="hljs-comment"># 创建对象的基类:</span><br>Base = declarative_base()<br><br><span class="hljs-comment"># 定义User对象:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    <span class="hljs-comment"># 表的名字:</span><br>    __tablename__ = <span class="hljs-string">&#x27;user&#x27;</span><br><br>    <span class="hljs-comment"># 表的结构:</span><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br><br><span class="hljs-comment"># 初始化数据库连接:</span><br>engine = create_engine(<span class="hljs-string">&#x27;mysql+mysqlconnector://root:password@localhost:3306/test&#x27;</span>)<br><span class="hljs-comment"># 创建DBSession类型:</span><br>DBSession = sessionmaker(bind=engine)<br></code></pre></td></tr></table></figure><p>以上代码完成 SQLAlchemy 的初始化和具体每个表的class定义。</p><p>create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：</p><p>‘数据库类型+数据库驱动名称:&#x2F;&#x2F;用户名:口令@机器地址:端口号&#x2F;数据库名’</p><p>如果有多个表，就继续定义其他 class，例如 School：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;school&#x27;</span><br>    <span class="hljs-built_in">id</span> = ...<br>    name = ...<br></code></pre></td></tr></table></figure><h4 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h4><p>由于有了 ORM，我们向数据库表中添加一行记录，可以视为添加一个<code>User</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建session对象:</span><br>session = DBSession()<br><span class="hljs-comment"># 创建新User对象:</span><br>new_user = User(<span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;5&#x27;</span>, name=<span class="hljs-string">&#x27;Bob&#x27;</span>)<br><span class="hljs-comment"># 添加到session:</span><br>session.add(new_user)<br><span class="hljs-comment"># 提交即保存到数据库:</span><br>session.commit()<br><span class="hljs-comment"># 关闭session:</span><br>session.close()<br></code></pre></td></tr></table></figure><p>可见，关键是获取<code>session</code>，然后把对象添加到<code>session</code>，最后提交并关闭。</p><p><code>DBSession</code> 对象可视为当前数据库连接。</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>有了ORM，查询出来的可以不再是<code>tuple</code>，而是<code>User</code>对象。SQLAlchemy 提供的查询接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建Session:</span><br>session = DBSession()<br><span class="hljs-comment"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:</span><br>user = session.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span>==<span class="hljs-string">&#x27;5&#x27;</span>).one()<br><span class="hljs-comment"># 打印类型和对象的name属性:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;type:&#x27;</span>, <span class="hljs-built_in">type</span>(user))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, user.name)<br><span class="hljs-comment"># 关闭Session:</span><br>session.close()<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.User&#x27;</span>&gt;<br>name: Bob<br></code></pre></td></tr></table></figure><h4 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h4><p>由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM 框架也可以提供两个对象之间的一对多、多对多等功能。</p><p>例如，如果一个<code>User</code>拥有多个<code>Book</code>，就可以定义一对多关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;user&#x27;</span><br><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br>    <span class="hljs-comment"># 一对多:</span><br>    books = relationship(<span class="hljs-string">&#x27;Book&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    __tablename__ = <span class="hljs-string">&#x27;book&#x27;</span><br><br>    <span class="hljs-built_in">id</span> = Column(String(<span class="hljs-number">20</span>), primary_key=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">20</span>))<br>    <span class="hljs-comment"># “多”的一方的book表是通过外键关联到user表的:</span><br>    user_id = Column(String(<span class="hljs-number">20</span>), ForeignKey(<span class="hljs-string">&#x27;user.id&#x27;</span>))<br></code></pre></td></tr></table></figure><p>当我们查询一个<code>User</code>对象时，该对象的<code>books</code>属性将返回一个包含若干个<code>Book</code>对象的<code>list</code>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="executemany"><a href="#executemany" class="headerlink" title="executemany()"></a>executemany()</h4><p>在<code>executemany()</code>方法中，参数列表需要是一个可迭代对象，并且每个元素都需要是一个序列（例如列表、元组等）。这是为了支持批量执行多次操作。</p><p>为了满足<code>executemany()</code>方法的要求，需要将每个参数以元组形式传递，即使是只有一个值的情况也不例外。这样可以确保参数列表与 SQL 语句中占位符的数量和顺序相匹配，从而正确地执行批量操作。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 计算生态</title>
    <link href="/2023/08/18/Python-%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81/"/>
    <url>/2023/08/18/Python-%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><p>PyPEF2：处理pdf文件的工具集</p><p>支持获取信息、分隔&#x2F;整合文件、加密解密等</p><p>完全Python语言实现，不需要额外依赖，功能稳定</p><p>NLTK：自然语言文本处理第三方库</p><p>支持语言文本分类、标记、语法句法、语义解析等</p><p>最好的Python自然语言处理库</p><p>Python-docx：创建或更新Microsoft Word文件的第三方库</p><p>提供创建或更新.doc .docx等文件的计算功能</p><p>增加并配置段落、图片、表格、文字等，功能全面</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p><strong>Numpy</strong>：表达N维数组的最基础库</p><ul><li>C语言实现，对外接口是python语言，计算速度优异</li><li>数据分析及科学计算的基础库</li><li>提供直接的矩阵运算、广播函数、线性代数等功能</li><li>Numpy最基础单元是一个数组，数组是一个变量</li></ul><p><strong>Pandas</strong>：Python数据分析高层次应用库</p><ul><li><p>操作索引即操作数据</p></li><li><p>Python最主要的数据分析功能库，基于Numpy开发</p></li><li><p>Pandas核心提供两个数据结构：</p></li><li><ul><li>Series &#x3D; 索引 + 一维数据</li><li>DataFrame &#x3D; 行列索引 + 二维数据</li></ul></li></ul><p>Pandas 库通过扩展了对一维和二维数据的表示，因而能够形成更高层次对数据的操作，简化数据分析的运行</p><p><strong>SciPy</strong>：数学、科学和工程计算功能库</p><ul><li>提供一批数学算法及工程数据运算功能</li><li>雷系Matlab，可用于如傅里叶变换、信号处理等应用</li><li>Python最主要的科学计算功能库，基于Numpy开发</li></ul><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p><strong>Matplotlib</strong>：高质量的二维数据可视化功能库</p><ul><li>通过 matplotlib.pyplot 子库调用各可视化效果（把所有有效的可视化展示方法汇集到一个子库中，相当于各个子库的快捷方式）</li><li>Python最主要的数据可视化功能库，基于Numpy开发</li></ul><p><strong>Seaborn</strong>：统计类数据可视化功能库</p><ul><li>提供了一批高层次统计类数据可视化展示效果</li><li>主要展示数据间分布、分类和线性关系等内容</li><li>基于Matplotlib开发，支持Numpy和Pandas</li></ul><p><strong>Mayavi</strong>：三维科学数据可视化功能库</p><ul><li>提供了一批易用的3D科学计算数据可视化展示效果</li><li>目前版本是Mayavi2，三维可视化最主要的第三方库</li><li>支持Numpy、TVTK、Traits、Envisage等第三方库</li></ul><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p><strong>Scikit-learn</strong>：机器学习方法工具集</p><ul><li>提供聚类、分类、回归、强化学习等计算功能</li><li>机器学习最基本且最优秀的Python第三方库</li></ul><p><strong>TensorFlow</strong>：AlphaGo背后的机器学习计算框架</p><ul><li>谷歌公司推动的开源机器学习框架</li><li>将数据流图作为基础，图节点代表运算，边代表张亮</li><li>应用机器学习方法的一种方式，支撑谷歌人工智能应用</li></ul><p>深度学习</p><p><strong>MXNet</strong>：基于神经网络的深度学习计算框架</p><ul><li>可用于自动驾驶、机器翻译、语音识别等众多领域</li><li>Python最重要的深度学习计算框架</li></ul><h1 id="从Web解析到网络空间"><a href="#从Web解析到网络空间" class="headerlink" title="从Web解析到网络空间"></a>从Web解析到网络空间</h1><h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><p>（如何爬下来）</p><p><strong>Requests</strong></p><ul><li>提供了简单易用的类HTTP协议网络爬虫功能</li><li>支持连接池、SSL、Cookies、HTTP(S)代理等</li><li>Python最主要的页面级网络爬虫功能库</li></ul><p><strong>Scrapy</strong>：优秀的网络爬虫框架</p><ul><li>提供了构建网络爬虫系统的框架功能</li><li>框架可理解为功能半成品，很多基础功能已完成，只需要用户进行扩展开发或者额外配置</li><li>支持批量和定时网页爬取、提供数据处理流程等</li><li>Python最主要且最专业的网络爬虫框架</li></ul><p><strong>pyspider</strong>：</p><ul><li>提供完整的网页爬取系统构建功能</li><li>支持数据库后端、消息队列、优先级、分布式架构等</li><li>Python重要的网络爬虫类第三方库</li></ul><h2 id="Web-信息提取"><a href="#Web-信息提取" class="headerlink" title="Web 信息提取"></a>Web 信息提取</h2><p>（爬下来后如何解析html和xml等内容）</p><p><strong>Beautiful Soup</strong>：HTML和XML的解析库</p><ul><li>又名beautifulsoup4或bs4，可以加载多种解析引擎</li><li>常与网络爬虫库搭配使用，如Scrapy、request等</li><li>将HTML页面以树形结构进行组织，通过下行、上行、平行遍历解析其中的内容</li></ul><p><strong>Re</strong>：正则表达式解析和处理功能库</p><ul><li>提供了定义和解析正则表达式的一批通用功能</li><li>可用于各类场景，包括定点的Web信息提取</li><li>Python主要标准库之一</li></ul><p><strong>Python-Goose</strong>：提取文章类型Web页面的功能库</p><ul><li>提供了对Web页面中文章信息&#x2F;视频等元数据的提取功能</li><li>针对特定类型Web页面，应用覆盖面较广</li><li>Python最主要的Web信息提取库</li></ul><h2 id="Web-网站开发"><a href="#Web-网站开发" class="headerlink" title="Web 网站开发"></a>Web 网站开发</h2><p><strong>Django</strong>：最流行的Web应用框架</p><ul><li>提供了构建Web系统的基本应用框架</li><li>MTV模式：模型（model）、模板（Template）、视图（Views）</li><li>Python最重要的Web应用框架，略微复杂，适合比较专业的网站构建</li></ul><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/python-web.png" alt="python-web"></p><p><strong>Pyramid</strong>：规模适中的Web应用框架</p><ul><li>提供了简单方便构建Web系统的应用框架</li><li>规模适中，适合快速构建并适度扩展类应用</li><li>Python产品级Web应用框架，起步简单可扩展性好</li></ul><p><strong>Flask</strong>：Web应用开发微框架</p><ul><li>提供了最简单构建Web系统的应用框架</li><li>特点是：简单、规模小、快速</li><li>Django &gt; Pyramid &gt; Flask</li></ul><h2 id="网络应用开发"><a href="#网络应用开发" class="headerlink" title="网络应用开发"></a>网络应用开发</h2><p><strong>WeRoBot</strong>：微信公众号开发框架</p><ul><li>提供了解析微信服务器消息及反馈消息的功能</li><li>建立微信机器人的重要技术手段</li></ul><p><strong>aip</strong>：百度AI开放平台接口</p><ul><li>提供了访问百度AI服务的Python功能接口</li><li>语音、人脸、OCR、NLP、知识图谱、图像搜索等领域</li><li>Python百度AI应用的最主要方式</li></ul><p><strong>MyQR</strong>：二维码生成第三方库</p><ul><li>提供了生成二维码的系列功能</li><li>基本二维码、艺术二维码和动态二维码</li></ul><h1 id="从人机交互到艺术设计"><a href="#从人机交互到艺术设计" class="headerlink" title="从人机交互到艺术设计"></a>从人机交互到艺术设计</h1><h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><p><strong>PyQt5</strong>：Qt开发框架的Python接口</p><ul><li>提供了创建Qt5程序的Python API接口</li><li>Qt是非常成熟的跨平台桌面应用开发系统，完备GUI</li><li>推荐的Python GUI开发第三方库</li></ul><p><strong>wxPython</strong>：跨平台GUI开发框架</p><ul><li>提供了专用于Python的跨平台GUI开发框架</li><li>理解数据类型与索引的关系，操作索引即操作数据</li><li>Python最主要的数据分析功能库，基于Numpy开发</li></ul><p><strong>PyGObject</strong>：使用GTK+开发GUI的功能库</p><ul><li>提供了整合GTK+、WebKitGTK+等库的功能</li><li>GTK+：跨平台的一种用户图形界面GUI框架</li><li>实例：Anaconda采用该库开发GUI</li></ul><h2 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h2><p><strong>PyGame</strong>：简单的游戏开发功能库</p><ul><li>提供了基于SDL的简单游戏开发功能及实现引擎</li><li>理解游戏对外部输入的响应机制及角色构建和交互机制</li><li>Python游戏入门最主要的第三方库</li></ul><p><strong>Panda3D</strong>：开源、跨平台的3D渲染和游戏开发库</p><ul><li>一个3D游戏引擎，提供Python和C++接口</li><li>支持很多先进特性：法线贴图、光泽贴图、卡通渲染等</li><li>由迪士尼和卡尼吉梅隆大学共同开发</li></ul><p><strong>cocos2d</strong>：构建2D游戏和图形界面交互式应用的框架</p><ul><li>提供了基于OpenGL的游戏开发图形渲染功能</li><li>支持GPU加速，采用树形结构分层管理游戏对象类型</li><li>适用于2D专业级游戏开发</li></ul><h2 id="虚拟现实"><a href="#虚拟现实" class="headerlink" title="虚拟现实"></a>虚拟现实</h2><p><strong>VR Zero</strong>：在树莓派上开发VR应用的Python库</p><ul><li>提供大量与VR开发相关的功能</li><li>针对树莓派的VR开发库，支持设备小型化，配置简单化</li><li>适合初学者实践VR开发及应用</li></ul><p><strong>pyovr</strong>：Oculus Rift的Python开发接口</p><ul><li>针对Oculus VR设备的Python开发库</li><li>基于成熟的VR设备，提供全套文档，工业级应用设备</li><li>Python+虚拟现实领域探索的一种思路</li></ul><p><strong>Vizard</strong>：基于Python的通用VR开发引擎</p><ul><li>专业的企业级虚拟现实开发引擎</li><li>提供详细的官方文档</li><li>支持多种主流的VR硬件设备，具有一定通用性</li></ul><h2 id="图形艺术"><a href="#图形艺术" class="headerlink" title="图形艺术"></a>图形艺术</h2><p><strong>Quads</strong>：迭代的艺术</p><ul><li>对图片进行四分迭代，形成像素风</li><li>可以生成动图或静图图像</li><li>简单易用，具有很高的展示度</li></ul><p><strong>ascii_art</strong>：ASCII艺术库</p><ul><li>将普通图片转为ASCII艺术风格</li><li>输出可以是纯文本或彩色文本</li><li>可采用图片格式输出</li></ul><p><strong>turtle</strong>：海龟绘图体系</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cartopy</title>
    <link href="/2023/08/18/Cartopy/"/>
    <url>/2023/08/18/Cartopy/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Cartopy-简介"><a href="#1-Cartopy-简介" class="headerlink" title="1. Cartopy 简介"></a>1. Cartopy 简介</h1><p>Cartopy 是英国气象局开发的开源免费的第三方 Python 地图绘图包，实现了 Basemap 的大部分功能，还可以通过 Matplotlib 的 API 实现丰富的自定义效果。</p><h2 id="1-1-常用绘图库"><a href="#1-1-常用绘图库" class="headerlink" title="1.1 常用绘图库"></a>1.1 常用绘图库</h2><p>在常用的python绘图库中，basemap，geopandas，pyecharts等，其中basemap在2020年已经停止维护了，pyecharts是用于数据可视化等专业图表的绘制，pyecharts在地学可视化中功能实在过于简陋；geopandas是基于pandas的，一般用于商业数据分析。</p><h2 id="1-2-常用Cartopy依赖库"><a href="#1-2-常用Cartopy依赖库" class="headerlink" title="1.2 常用Cartopy依赖库"></a>1.2 常用Cartopy依赖库</h2><p>pyproj：处理地图投影变形，Cartopy 基于它定义了丰富的地图投影；</p><p>pillow：Python 的图像处理包，读写和操作栅格图像； </p><p>pyshp：Python 实现的 ESRI Shapefile 读写包； </p><p>shapely：操作和分析空间地理对象； </p><p>cartopy：Cartopy 安装包，地图制图工具。</p><h1 id="2-Cartopy-安装"><a href="#2-Cartopy-安装" class="headerlink" title="2. Cartopy 安装"></a>2. Cartopy 安装</h1><h2 id="conda（官方推荐）"><a href="#conda（官方推荐）" class="headerlink" title="conda（官方推荐）"></a>conda（官方推荐）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install -c conda-forge cartopy<br></code></pre></td></tr></table></figure><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>下载对应 python 版本的依赖：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p><p>安装下载好的.whl文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install Shapely-1.8.2-cp39-cp39-win_amd64.whl<br>pip install Pillow-9.1.1-cp39-cp39-win_amd64.whl<br>pip install pyproj-3.3.1-cp39-cp39-win_amd64.whl<br>pip install Cartopy-0.20.2-cp39-cp39-win_amd64.whl<br><span class="hljs-comment"># 由于 Cartopy 一般与 matplotlib 一起使用，顺便安装一下 matplotlib 库</span><br>pip install matplotlib<br></code></pre></td></tr></table></figure><h1 id="3-绘制底图基本流程"><a href="#3-绘制底图基本流程" class="headerlink" title="3. 绘制底图基本流程"></a>3. 绘制底图基本流程</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> cartopy.crs <span class="hljs-keyword">as</span> ccrs<br><br><span class="hljs-comment"># 创建画布以及ax</span><br>fig = plt.figure()<br>ax = fig.add_subplot(<span class="hljs-number">111</span>, projection=ccrs.PlateCarree())<br><br><span class="hljs-comment"># 调用ax的方法画海岸线</span><br>ax.coastlines()<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/result.png" alt="result"></p><p>Cartopy 是利用 Matplotlib 来画图的，因此首先要导入 pyplot 模块。</p><p>在 Cartopy 中每种投影都是一个类，存放在 <code>cartopy.crs</code> 模块中。crs 即坐标参考系统（Coordinate Reference Systems）。</p><p>这里选取最常用的等距圆柱投影<code>ccrs.PlateCarree</code>作为地图投影。</p><hr><p>参考：</p><p><a href="https://zhajiman.github.io/post/cartopy_introduction/">https://zhajiman.github.io/post/cartopy_introduction/</a></p><p><a href="https://zhuanlan.zhihu.com/p/544122658">https://zhuanlan.zhihu.com/p/544122658</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv视频读写</title>
    <link href="/2023/08/09/opencv%E8%A7%86%E9%A2%91%E8%AF%BB%E5%86%99/"/>
    <url>/2023/08/09/opencv%E8%A7%86%E9%A2%91%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在<code>opencv</code>中关于视频的读操作是通过<code>VideoCapture</code>类来完成的；关于视频的写操作是通过<code>VideoWriter</code>类来实现的。</p><h1 id="VideoCapture"><a href="#VideoCapture" class="headerlink" title="VideoCapture"></a>VideoCapture</h1><p><code>VideoCapture</code>既支持从视频文件读取，也支持直接从摄像机（比如电脑自带摄像头）中读取。</p><p>要想获取视频需要先创建一个 <code>VideoCapture</code> 对象，<code>VideoCapture</code>类提供了构造函数：<code>cv2.VideoCapture()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cap = cv2.VideoCapture(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 读取摄像头</span><br>cap = cv2.VideoCapture(<span class="hljs-string">&#x27;video.mp4&#x27;</span>)  <span class="hljs-comment"># 读取视频文件</span><br></code></pre></td></tr></table></figure><p>摄像头ID号默认值为<code>-1</code>，表示随机选取一个摄像头。</p><p>如果你运行该程序的设备有多个摄像头，则用0表示设备内置的第一个摄像头，1表示设备的第二个摄像头，依次类推。如果一般台式机只有一个摄像头，用0或者-1都可以。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="检查是否初始化成功"><a href="#检查是否初始化成功" class="headerlink" title="检查是否初始化成功"></a>检查是否初始化成功</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cap.isOpened()<br></code></pre></td></tr></table></figure><p>说明：判断视频对象是否成功读取，成功读取视频对象返回<code>True</code>。</p><p>当我们初始化摄像头失败后，我们还可以使用函数<code>cv2.VideoCapture.open()</code>打开摄像头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> cap.isOpened() <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>    result = cap.<span class="hljs-built_in">open</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>open</code>参数也是摄像头的ID号，与前面构造函数一样。同时，使用<code>open()</code>函数打开摄像头后，也返回成功<code>True</code>或失败<code>False</code>。</p><h3 id="捕获帧"><a href="#捕获帧" class="headerlink" title="捕获帧"></a>捕获帧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">retval, frame = cap.read()<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>按帧读取视频，返回值<code>retval</code>是布尔型，正确读取则返回<code>True</code>；</li><li>读取失败或读取视频结尾则会返回<code>False</code>；</li><li><code>frame</code>为每一帧的图像，这里图像是三维矩阵，即<code>frame.shape = (640,480,3)</code>，读取的图像为BGR格式。</li></ul><h3 id="等待键盘输入"><a href="#等待键盘输入" class="headerlink" title="等待键盘输入"></a>等待键盘输入</h3><p><code>waitKey()</code>方法本身表示等待键盘输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">key = cv2.waitKey(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>参数<code>1</code>，表示延时1ms切换到下一帧。</li><li>参数为<code>0</code>，表示显示当前帧，相当于视频暂停。</li><li>参数过大如<code>cv2.waitKey(1000)</code>，会因为延时过久而卡顿感觉到卡顿。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    ret, frame = cap.read()<br>    <span class="hljs-keyword">if</span> ret:<br>        cv2.imshow(<span class="hljs-string">&#x27;Video&#x27;</span>, frame)<br>        key = cv2.waitKey(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> key == <span class="hljs-number">27</span>:<br>            <span class="hljs-keyword">break</span><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><ul><li><code>key</code>得到的是键盘输入的 ASCII 码，esc 键对应的 ASCII 码是 27，即当按 esc 键时 if 条件句成立。</li></ul><h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><p>使用完摄像头资源之后，需要释放该资源，即关闭摄像头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cap.release()<br></code></pre></td></tr></table></figure><h3 id="关闭所有图像窗口"><a href="#关闭所有图像窗口" class="headerlink" title="关闭所有图像窗口"></a>关闭所有图像窗口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>有时，我们需要获取<code>cv2.VideoCapture</code>摄像头的一些属性，比如其分辨率，像素。</p><p>OpenCV提供了<code>cv2.VideoCapture.get()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cameraInfo = cap.get(propId)<br></code></pre></td></tr></table></figure><p>参数<code>propId</code>对应着就是<code>cv2.VideoCapture</code>类对象的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">width = <span class="hljs-built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))  <span class="hljs-comment"># 获取视频的宽度</span><br>height = <span class="hljs-built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))  <span class="hljs-comment"># 获取视频的高度</span><br>fps = cap.get(cv2.CAP_PROP_FPS)  <span class="hljs-comment"># 获取视频的帧率</span><br>fourcc = <span class="hljs-built_in">int</span>(cap.get(cv2.CAP_PROP_FOURCC))  <span class="hljs-comment"># 视频的编码</span><br></code></pre></td></tr></table></figure><h3 id="grab-与-retrieve"><a href="#grab-与-retrieve" class="headerlink" title="grab() 与 retrieve()"></a>grab() 与 retrieve()</h3><p>一般情况下，我们都只使用一个摄像头，上面这些步骤与函数完全能够应付。但是，如果需要同步一组或一个多头摄像头，就需要使用<code>VideoCapture.grab()</code>与<code>VideoCapture.retrieve()</code>函数。可以把函数<code>VideoCapture.read()</code>理解为这两个函数的组合。</p><p>函数<code>grab()</code>用于指向下一帧，函数<code>retrieve()</code>用来解码并返回一帧。所以，对于一组摄像头我们可以这样操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">cap0 = cv2.VideoCapture(<span class="hljs-number">0</span>)<br>cap1 = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br>isCamera0 = cap0.grab()<br>isCamera1 = cap1.grab()<br><br><span class="hljs-keyword">if</span> isCamera0 <span class="hljs-keyword">and</span> isCamera1:<br>    frame0 = cap0.retrieve()<br>    frame1 = cap1.retrieve()<br></code></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="读取摄像头并保存为视频"><a href="#读取摄像头并保存为视频" class="headerlink" title="读取摄像头并保存为视频"></a>读取摄像头并保存为视频</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">videocapture</span>():<br>    cap=cv2.VideoCapture(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 生成读取摄像头对象</span><br>    width = <span class="hljs-built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))  <span class="hljs-comment"># 获取视频的宽度</span><br>    height = <span class="hljs-built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))  <span class="hljs-comment"># 获取视频的高度</span><br>    fps = cap.get(cv2.CAP_PROP_FPS)  <span class="hljs-comment"># 获取视频的帧率</span><br>    fourcc = <span class="hljs-built_in">int</span>(cap.get(cv2.CAP_PROP_FOURCC))  <span class="hljs-comment"># 视频的编码</span><br>    <span class="hljs-comment"># 定义视频对象输出</span><br>    writer = cv2.VideoWriter(<span class="hljs-string">&quot;video_result.mp4&quot;</span>, fourcc, fps, (width, height))<br>    <span class="hljs-keyword">while</span> cap.isOpened():<br>        ret, frame = cap.read()  <span class="hljs-comment"># 读取摄像头画面</span><br>        cv2.imshow(<span class="hljs-string">&#x27;video&#x27;</span>, frame)  <span class="hljs-comment"># 显示画面</span><br>        key = cv2.waitKey(<span class="hljs-number">24</span>)<br>        writer.write(frame)  <span class="hljs-comment"># 视频保存</span><br>        <span class="hljs-comment"># 按 Q 退出</span><br>        <span class="hljs-keyword">if</span> key == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>            <span class="hljs-keyword">break</span><br>    cap.release()  <span class="hljs-comment"># 释放摄像头</span><br>    cv2.destroyAllWindows()  <span class="hljs-comment"># 释放所有显示图像窗口    </span><br></code></pre></td></tr></table></figure><h2 id="通过帧数间隔抽取图片"><a href="#通过帧数间隔抽取图片" class="headerlink" title="通过帧数间隔抽取图片"></a>通过帧数间隔抽取图片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_img</span>(<span class="hljs-params">mp4_path</span>):<br>    cap = cv2.VideoCapture(mp4_path)<br>    c = <span class="hljs-number">1</span><br>    frame_rate = <span class="hljs-number">100</span>  <span class="hljs-comment"># 帧数截取间隔（每隔100帧截取一帧）</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        ret, frame = cap.read()<br>        <span class="hljs-keyword">if</span> ret:<br>            <span class="hljs-keyword">if</span> c % frame_rate == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始截取视频第 &quot;</span> + <span class="hljs-built_in">str</span>(c) + <span class="hljs-string">&quot; 帧&quot;</span>)<br>                <br>                <span class="hljs-comment"># 图片保存到本地</span><br>                save_image_path = os.path.join(save_dir, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;c&#125;</span>.jpg&#x27;</span>)<br>                <span class="hljs-comment"># cv2.imwrite(save_image_path, frame)  # 不能包含中文</span><br>                cv2.imencode(<span class="hljs-string">&#x27;.jpg&#x27;</span>, frame)[<span class="hljs-number">1</span>].tofile(save_image_path)<br>            c += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>    cap.release()<br></code></pre></td></tr></table></figure><h2 id="通过时间间隔抽取图片"><a href="#通过时间间隔抽取图片" class="headerlink" title="通过时间间隔抽取图片"></a>通过时间间隔抽取图片</h2><p>假如你想每隔10秒截取一帧，那么就相当于你要每隔（ FPS * 10 ）帧截取一帧图像</p><p>首先你需要知道你的视频的帧率（FPS）是多少，通过opencv获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cap = cv2.VideoCapture(<span class="hljs-string">&quot;./query_video/test_video_0.mp4&quot;</span>)<br><br>fps = cap.get(cv2.CAP_PROP_FPS)<br></code></pre></td></tr></table></figure><p>结合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_img</span>(<span class="hljs-params">mp4_path</span>):<br>    cap = cv2.VideoCapture(mp4_path)<br>    fps = cap.get(cv2.CAP_PROP_FPS)<br>    c = <span class="hljs-number">1</span><br>    time_rate = <span class="hljs-number">10</span>  <span class="hljs-comment"># 帧数截取间隔（每隔10秒截取一帧）</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        ret, frame = cap.read()<br>        <span class="hljs-keyword">if</span> ret:<br>            frame_rate = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>(fps) * time_rate / <span class="hljs-number">2.5</span>)  <span class="hljs-comment"># 如果视频2.5倍速加速过</span><br>            <span class="hljs-keyword">if</span> c % frame_rate == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始截取视频第 &quot;</span> + <span class="hljs-built_in">str</span>(c) + <span class="hljs-string">&quot; 帧&quot;</span>)<br>                <span class="hljs-comment"># 图像保存到本地</span><br>                save_image_path = os.path.join(save_dir, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;c&#125;</span>.jpg&#x27;</span>)<br>                <span class="hljs-comment"># cv2.imwrite(save_image_path, frame)  # 不能包含中文</span><br>                cv2.imencode(<span class="hljs-string">&#x27;.jpg&#x27;</span>, frame)[<span class="hljs-number">1</span>].tofile(save_image_path)<br>            c += <span class="hljs-number">1</span><br>            cv2.waitKey(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;截取完毕&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>    cap.release()<br></code></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://blog.csdn.net/weixin_40922285/article/details/102967331">cv2.VideoCapture读取视频或摄像头，并进行保存帧图像或视频-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010368556/article/details/79186992">opencv学习—VideoCapture 类基础知识-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyternotebook更换虚拟环境</title>
    <link href="/2023/07/31/Jupyternotebook%E6%9B%B4%E6%8D%A2%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/07/31/Jupyternotebook%E6%9B%B4%E6%8D%A2%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用 Jupyter notebook ，一开始只有一个默认Python3内核，本地管理的多个环境的多个第三方库都无法使用。</p><p>执行<code>sys.executable</code>可以看到目前是使用默认的环境：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83.png" alt="查看当前使用环境"></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="1）进入虚拟环境"><a href="#1）进入虚拟环境" class="headerlink" title="1）进入虚拟环境"></a>1）进入虚拟环境</h2><p>进入命令行终端，切换到指定虚拟环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看虚拟环境名称</span> <br>conda env list <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入指定虚拟环境</span> <br>conda activate ECdownload<br></code></pre></td></tr></table></figure><h2 id="2）安装ipykernel库"><a href="#2）安装ipykernel库" class="headerlink" title="2）安装ipykernel库"></a>2）安装ipykernel库</h2><p>安装ipykernel：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install ipykernel -i https://pypi.douban.com/simple<br></code></pre></td></tr></table></figure><h2 id="3）安装内核"><a href="#3）安装内核" class="headerlink" title="3）安装内核"></a>3）安装内核</h2><p>使用<code>python -m ipykernel install --user --name 环境名 --display-name &quot;内核名&quot;</code>命令，创建指定虚拟环境和指定名称内核：</p><p>或<code>ipython kernel install --user --name 环境名</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m ipykernel install --user --name ECdownload --display-name &quot;Python [conda env:ECdownload]&quot;<br></code></pre></td></tr></table></figure><blockquote><p>ECdownload 是本人的虚拟环境名</p></blockquote><h2 id="4）使用"><a href="#4）使用" class="headerlink" title="4）使用"></a>4）使用</h2><p>刷新之后就可以看到新增了刚才创建的内核，直接更换：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%88%90%E5%8A%9F.png" alt="成功"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Conda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装配置anaconda</title>
    <link href="/2023/07/07/Linux%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEanaconda/"/>
    <url>/2023/07/07/Linux%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEanaconda/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Linux安装配置anaconda"><a href="#1-Linux安装配置anaconda" class="headerlink" title="1. Linux安装配置anaconda"></a>1. Linux安装配置anaconda</h1><h2 id="1-1-官网"><a href="#1-1-官网" class="headerlink" title="1.1 官网"></a>1.1 官网</h2><p><a href="https://www.anaconda.com/products/distribution">https://www.anaconda.com/products/distribution</a></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/anaconda%E4%B8%8B%E8%BD%BD.png" alt="anaconda下载"></p><h2 id="1-2-下载安装"><a href="#1-2-下载安装" class="headerlink" title="1.2 下载安装"></a>1.2 下载安装</h2><p>获取安装包下载链接（后缀为.sh），在服务器下载安装（或者在本地下载完上传到服务器，whatever）</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%8E%B7%E5%8F%96%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5.png" alt="获取下载链接"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载</span> <br>wget https://repo.anaconda.com/archive/Anaconda3-2021.11-Linux-x86_64.sh <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装（root下运行）</span> <br>bash Anaconda3-2019.07-Linux-x86_64.sh <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span> <br>sh Anaconda3-2019.07-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><h3 id="1-2-1-询问安装目录"><a href="#1-2-1-询问安装目录" class="headerlink" title="1.2.1 询问安装目录"></a>1.2.1 询问安装目录</h3><p>中间会出现下图，询问你是否要更改默认安装目录（如果要更改，输入相应的地址就可以了）</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%98%AF%E5%90%A6%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95.png" alt="是否更改默认安装目录"></p><h3 id="1-2-2-初始化"><a href="#1-2-2-初始化" class="headerlink" title="1.2.2 初始化"></a>1.2.2 初始化</h3><p>安装完成后会出现以下提示，是否希望安装程序通过运行<code>conda init</code>来初始化Anaconda3?</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%98%AF%E5%90%A6%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="是否初始化"></p><p><strong>（1）选择yes</strong></p><p>选择yes的话，<code>.bashrc</code>文件中会添加以下内容，这样在打开终端时自动执行<code>conda activate root</code>命令，这样在终端输入<code>python</code>的时候默认是python3（CentOS7及7以下默认装的是python2）。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/bashrc%E6%96%87%E4%BB%B6.png" alt="bashrc文件"></p><p>这样的话，启动虚拟机shell命令前面出现(base)字样，默认python3（当然，<code>conda deactivate</code>这个命令又可以回去）</p><p><strong>（2）选择no</strong></p><p>选择no的话，在安装完anaconda后需手动添加环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export ANACONDA3_HOME=/usr/local/src/anaconda3 <br>export PATH=$PATH:ANACONDA3_HOME/bin<br></code></pre></td></tr></table></figure><p>不过，有的小伙伴会问，如果我安装过程选择了no，但是安装完还想初始化，该怎么操作？可以通过以下命令来实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /usr/local/anaconda3/bin/activate # activate的安装路径，启动<br>activate conda init<br></code></pre></td></tr></table></figure><p>执行完这两个命令，<code>.bashrc</code>中也会添加上面那些内容。</p><p>官网建议选yes：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE.png" alt="官方建议"></p><p>选择no后弹出以下提示语：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E9%80%89%E6%8B%A9no.png" alt="选择no"></p><p>通过以下命令关闭 【启动后自动激活环境】：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda config --set auto_activate_base false<br></code></pre></td></tr></table></figure><p>\3. 修改 <code>.bashrc</code></p><p>现在,您可以通过修改 <code>~/.bashrc</code>文件来激活安装。</p><p>在 <code>~/.bashrc</code> 末尾添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=&quot;~/anaconda3/bin&quot;:$PATH <br>source ~/anaconda3/bin/activate<br></code></pre></td></tr></table></figure><p>后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.bashrc<br></code></pre></td></tr></table></figure><p>完成后，您将被置于Anaconda的默认base编程环境中。</p><hr><p>参考：<a href="https://blog.csdn.net/JineD/article/details/129507719">https://blog.csdn.net/JineD/article/details/129507719</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Conda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开放端口供他人访问</title>
    <link href="/2023/05/23/%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/"/>
    <url>/2023/05/23/%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-查看防火墙状态（是否开启）"><a href="#1-查看防火墙状态（是否开启）" class="headerlink" title="1. 查看防火墙状态（是否开启）"></a>1. 查看防火墙状态（是否开启）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status firewalld<br></code></pre></td></tr></table></figure><h2 id="2-开启防火墙"><a href="#2-开启防火墙" class="headerlink" title="2. 开启防火墙"></a>2. 开启防火墙</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start firewalld<br></code></pre></td></tr></table></figure><h2 id="3-查看所有开启的端口"><a href="#3-查看所有开启的端口" class="headerlink" title="3. 查看所有开启的端口"></a>3. 查看所有开启的端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --list-ports<br></code></pre></td></tr></table></figure><p>注：启动防火墙后，默认没有开启任何端口，需要手动开启端口</p><h2 id="4-防火墙开启端口访问"><a href="#4-防火墙开启端口访问" class="headerlink" title="4. 防火墙开启端口访问"></a>4. 防火墙开启端口访问</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=80/tcp --permanent<br></code></pre></td></tr></table></figure><ul><li><code>--zone</code>  #作用域 </li><li><code>--add-port=80/tcp</code>   #添加端口，格式为：端口&#x2F;通讯协议 </li><li><code>--permanent</code>    #永久生效，没有此参数重启后失效</li></ul><p>注：开启后需要重启防火墙才生效</p><h2 id="5-重启防火墙"><a href="#5-重启防火墙" class="headerlink" title="5. 重启防火墙"></a>5. 重启防火墙</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --reload<br></code></pre></td></tr></table></figure><h2 id="6-再次查看所有开启的端口"><a href="#6-再次查看所有开启的端口" class="headerlink" title="6. 再次查看所有开启的端口"></a>6. 再次查看所有开启的端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --list-ports<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy</title>
    <link href="/2023/05/10/Numpy/"/>
    <url>/2023/05/10/Numpy/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Numpy-简介"><a href="#1-Numpy-简介" class="headerlink" title="1. Numpy 简介"></a>1. Numpy 简介</h1><p>NumPy 是一个由多维数组对象（ndarray）和处理这些数组的函数（function）集合组成的库。主要用来计算、处理一维或多维数组。</p><h1 id="2-Numpy-安装"><a href="#2-Numpy-安装" class="headerlink" title="2. Numpy 安装"></a>2. Numpy 安装</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install numpy<br></code></pre></td></tr></table></figure><p>在实际项目中， <strong>NumPy</strong> 通常与 <strong>SciPy</strong> 程序包一起使用，SciPy 可以看做对 NumPy 库的扩展，它在 NumPy 的基础上又增加了许多工程计算函数。因此将它们同时安装是一个不错的选择。</p><p>注意：在 Windows 下直接使用 pip 安装 SciPy 会发生报错，需要我们解决 SciPy 的依赖项问题，所以不推荐使用pip安装 SciPy 程序包。</p><p>首先我们要知道什么是 SciPy 栈？其实它是一个科学计算软件包的集成平台，这类平台囊括了常用的数值计算与机器学习库，比如 NumPy、Matplotlib、SciPy 库、IPython 等，并且它可以自动解决包之间的依赖问题。通过安装一个集成平台就可以实现上述所有软件包的安装。</p><p>常用的平台为 Anaconda（官网下载：<a href="https://www.anaconda.com/%EF%BC%89%EF%BC%8C%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E7%9A%84">https://www.anaconda.com/），是一个开源的</a> Python 发行版，它包含了 NumPy、SciPy 等180多个科学包及其依赖项。除了支持 Windows 外，也支持 Linux 和 Mac 系统。Anaconda 就目前应用较为广泛，因此建议安装。</p><blockquote><p>Anaconda 的下载文件约 500 MB 左右，你可以选择安装 Miniconda，它是 Anaconda 的轻巧版，只需 40 余兆。</p></blockquote><h1 id="3-Numpy-ndarray对象"><a href="#3-Numpy-ndarray对象" class="headerlink" title="3. Numpy ndarray对象"></a>3. Numpy ndarray对象</h1><p>NumPy 定义了一个 n 维数组对象，简称 ndarray 对象，它是一个一系列相同类型元素组成的数组集合。数组中的每个元素都占有大小相同的内存块，您可以使用索引或切片的方式获取数组中的每个元素。</p><p>ndarray 对象采用了数组的索引机制，将数组中的每个元素映射到内存块上，并且按照一定的布局对内存块进行排列，常用的布局方式有两种，即按行或者按列。</p><h2 id="3-1-创建ndarray对象"><a href="#3-1-创建ndarray对象" class="headerlink" title="3.1 创建ndarray对象"></a>3.1 创建ndarray对象</h2><p>通过 NumPy 的内置函数 array() 可以创建 ndarray 对象，其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.array(<span class="hljs-built_in">object</span>, dtype=<span class="hljs-literal">None</span>, copy=<span class="hljs-literal">True</span>, order=<span class="hljs-literal">None</span>, ndmin=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th>参数</th><th>描述说明</th></tr></thead><tbody><tr><td>object</td><td>表示一个数组序列。</td></tr><tr><td>dtype</td><td>可选参数，通过它可以更改数组的数据类型。</td></tr><tr><td>copy</td><td>可选参数，表示数组能否被复制，默认是 True。</td></tr><tr><td>order</td><td>以哪种内存布局创建数组，有 3 个可选值，分别是 C(行序列)&#x2F;F(列序列)&#x2F;A(默认)。</td></tr><tr><td>ndim</td><td>用于指定数组的维度。</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一维数组：</span><br>a=numpy.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># 创建多维数组：</span><br>b=numpy.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><br><span class="hljs-comment"># 如果要改变数组元素的数据类型，可以使用通过设置 dtype=&quot;数据类型名称&quot;，如下所示：</span><br>c=numpy.array([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>], dtype=<span class="hljs-string">&quot;complex&quot;</span>)  <span class="hljs-comment"># 将数组中的元素类型变成了复数类型：</span><br></code></pre></td></tr></table></figure><h2 id="3-2-ndim查看数组维数"><a href="#3-2-ndim查看数组维数" class="headerlink" title="3.2 ndim查看数组维数"></a>3.2 ndim查看数组维数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过 ndim 可以查看数组的维度：</span><br><br>arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>]]) <br><span class="hljs-built_in">print</span>(arr.ndim)  <span class="hljs-comment"># 2</span><br><br><span class="hljs-comment"># 也可以使用 ndim 参数创建不同维度的数组：</span><br><span class="hljs-comment"># 输出一个二维数组：</span><br><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], ndim = <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># [[1 2 3 4 5]]</span><br></code></pre></td></tr></table></figure><h2 id="3-3-reshape数组变维"><a href="#3-3-reshape数组变维" class="headerlink" title="3.3 reshape数组变维"></a>3.3 reshape数组变维</h2><p>数组的形状指的是多维数组的行数和列数。<code>reshape()</code>函数可以改变多维数组行数和列数，从而达到数组变维的目的。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%8F%98%E7%BB%B4.png" alt="变维"></p><p><code>reshape()</code>函数可以接受一个元组作为参数，用于指定了新数组的行数和列数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">e = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]) <br><br>e=e.reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># 原数组：[[1 2]</span><br><span class="hljs-comment">#        [3 4]</span><br><span class="hljs-comment">#        [5 6]]</span><br><span class="hljs-comment"># 新数组:[[1 2 3]</span><br><span class="hljs-comment">#        [4 5 6]]</span><br></code></pre></td></tr></table></figure><h1 id="4-Numpy-数据类型"><a href="#4-Numpy-数据类型" class="headerlink" title="4. Numpy 数据类型"></a>4. Numpy 数据类型</h1><p>Numpy 作为 Python 的扩展包，它提供了比 Python 更加丰富的数据类型。</p><p>（略，<a href="http://c.biancheng.net/numpy/dtype.html%EF%BC%89">http://c.biancheng.net/numpy/dtype.html）</a></p><h2 id="4-1-数据类型-dtype-对象"><a href="#4-1-数据类型-dtype-对象" class="headerlink" title="4.1 数据类型(dtype)对象"></a>4.1 数据类型(dtype)对象</h2><p>数据类型对象（Data Type Object） 主要用来描述数组元素的数据类型、大小以及字节顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个 dtype 对象</span><br>a = np.dtype(np.int64)<br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># int64</span><br></code></pre></td></tr></table></figure><h2 id="4-2-数据类型标识码"><a href="#4-2-数据类型标识码" class="headerlink" title="4.2 数据类型标识码"></a>4.2 数据类型标识码</h2><p>NumPy 中每种数据类型都有一个唯一标识的字符码：</p><table><thead><tr><th>字符</th><th>对应类型</th></tr></thead><tbody><tr><td>b</td><td>代表布尔型</td></tr><tr><td>i</td><td>带符号整型</td></tr><tr><td>u</td><td>无符号整型</td></tr><tr><td>f</td><td>浮点型</td></tr><tr><td>c</td><td>复数浮点型</td></tr><tr><td>m</td><td>时间间隔（timedelta）</td></tr><tr><td>M</td><td>datatime（日期时间）</td></tr><tr><td>O</td><td>Python对象</td></tr><tr><td>S,a</td><td>字节串（S）与字符串（a）</td></tr><tr><td>U</td><td>Unicode</td></tr><tr><td>V</td><td>原始数据（void）</td></tr></tbody></table><p>示例：使用数据类型标识码，创建一组结构化数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建数据类型score</span><br>dt = np.dtype([(<span class="hljs-string">&#x27;score&#x27;</span>,<span class="hljs-string">&#x27;i1&#x27;</span>)])  <span class="hljs-comment"># 定义字段名score，以及数组数据类型i1</span><br>a = np.array([(<span class="hljs-number">55</span>,),(<span class="hljs-number">75</span>,),(<span class="hljs-number">85</span>,)], dtype = dt)<br><br><span class="hljs-built_in">print</span>(a)           <span class="hljs-comment"># [(55,) (75,) (85,)] </span><br><span class="hljs-built_in">print</span>(a.dtype)     <span class="hljs-comment"># dtype([(&#x27;score&#x27;, &#x27;i1&#x27;)])</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&#x27;score&#x27;</span>])  <span class="hljs-comment"># [55 75 85]</span><br></code></pre></td></tr></table></figure><h2 id="4-3-定义结构化数据"><a href="#4-3-定义结构化数据" class="headerlink" title="4.3 定义结构化数据"></a>4.3 定义结构化数据</h2><p>通常情况下，结构化数据使用字段的形式来描述某个对象的特征。以下示例描述一位老师的姓名、年龄、工资的特征，该结构化数据其包含以下字段：</p><ul><li>str 字段：name</li><li>int 字段：age</li><li>float 字段：salary</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建结构化数据teacher</span><br>teacher = np.dtype([(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;S20&#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;i1&#x27;</span>), (<span class="hljs-string">&#x27;salary&#x27;</span>, <span class="hljs-string">&#x27;f4&#x27;</span>)])<br><br><span class="hljs-built_in">print</span>(teacher)  <span class="hljs-comment"># [(&#x27;name&#x27;, &#x27;S20&#x27;), (&#x27;age&#x27;, &#x27;i1&#x27;), (&#x27;salary&#x27;, &#x27;&lt;f4&#x27;)]</span><br><br><span class="hljs-comment"># 将其应用于ndarray对象</span><br>b = np.array([(<span class="hljs-string">&#x27;ycs&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-number">6357.50</span>),(<span class="hljs-string">&#x27;jxe&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-number">6856.80</span>)], dtype = teacher) <br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [(b&#x27;ycs&#x27;, 32, 6357.5) (b&#x27;jxe&#x27;, 28, 6856.8)]（输出的name为bytes字节串类型）</span><br></code></pre></td></tr></table></figure><h1 id="5-NumPy-数组属性"><a href="#5-NumPy-数组属性" class="headerlink" title="5. NumPy 数组属性"></a>5. NumPy 数组属性</h1><h2 id="ndarray-shape"><a href="#ndarray-shape" class="headerlink" title="ndarray.shape"></a>ndarray.shape</h2><p>返回一个由数组维度构成的元组。如 2 行 3 列的二维数组可以表示为(2,3)。</p><p>示例，输出了数组的维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a.shape)<br>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>通过 shape 属性修改数组的形状大小： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.shape = (<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment"># =&gt; a.reshape(3,2)</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a)<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><h2 id="ndarray-reshape"><a href="#ndarray-reshape" class="headerlink" title="ndarray.reshape()"></a>ndarray.reshape()</h2><p>NumPy 还提供了一个调整数组形状的 reshape() 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 与上例一样</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.reshape = (<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a)<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><h2 id="ndarray-ndim"><a href="#ndarray-ndim" class="headerlink" title="ndarray.ndim"></a>ndarray.ndim</h2><p>返回数组的维数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机生成一个一维数组</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>c = np.arange(<span class="hljs-number">24</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c)<br>[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c.ndim)<br><span class="hljs-number">1</span><br><span class="hljs-comment">#对数组进行变维操作</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>e = c.reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)  <span class="hljs-comment"># 2个4行3列的数组</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(e)<br>[[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>]<br>  [ <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br>  [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>]<br>  [ <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]<br><br>[[<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span>]<br>  [<span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br>  [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span>]<br>  [<span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(e.ndim)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="ndarray-itemsize"><a href="#ndarray-itemsize" class="headerlink" title="ndarray.itemsize"></a>ndarray.itemsize</h2><p>返回数组中每个元素的大小（以字节为单位）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], dtype = np.int8)  <span class="hljs-comment"># 数据类型为int8，代表1字节</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (x.itemsize)<br><span class="hljs-number">1</span><br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], dtype = np.int64)  <span class="hljs-comment"># 数据类型为int64，代表8字节</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (x.itemsize)<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="ndarray-flags"><a href="#ndarray-flags" class="headerlink" title="ndarray.flags"></a>ndarray.flags</h2><p>返回 ndarray 数组的内存信息，比如 ndarray 数组的存储方式，以及是否是其他数组的副本等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (x.flags)<br>C_CONTIGUOUS : <span class="hljs-literal">True</span><br>F_CONTIGUOUS : <span class="hljs-literal">True</span><br>OWNDATA : <span class="hljs-literal">True</span><br>WRITEABLE : <span class="hljs-literal">True</span><br>ALIGNED : <span class="hljs-literal">True</span><br>WRITEBACKIFCOPY : <span class="hljs-literal">False</span><br>UPDATEIFCOPY : <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="ndarray-dtype"><a href="#ndarray-dtype" class="headerlink" title="ndarray.dtype"></a>ndarray.dtype</h2><h2 id="ndarray-size"><a href="#ndarray-size" class="headerlink" title="ndarray.size"></a>ndarray.size</h2><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a1 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],dtype=np.complex128)  <br><span class="hljs-built_in">print</span>(a1)  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数据类型&quot;</span>,<span class="hljs-built_in">type</span>(a1))           <span class="hljs-comment">#打印数组数据类型  </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数组元素数据类型：&quot;</span>,a1.dtype)  <span class="hljs-comment"># 打印数组元素数据类型  </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数组元素总数：&quot;</span>,a1.size)       <span class="hljs-comment"># 打印数组尺寸，即数组元素总数  </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数组形状：&quot;</span>,a1.shape)          <span class="hljs-comment"># 打印数组形状  </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数组的维度数目&quot;</span>,a1.ndim)       <span class="hljs-comment"># 打印数组的维度数目  </span><br></code></pre></td></tr></table></figure><p>ndarray的转置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.T</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.transpose</span>()<br></code></pre></td></tr></table></figure><ul><li>在默认情况下，两者效果相同，但<code>transpose()</code>可以指定交换的<code>axis</code>维度。</li><li>对于一维数组，两者均不改变，返回原数组。</li><li>对于二维数组，默认进行标准的转置操作。</li><li>对于多维数组<code>A,A.shape</code>为<code>(a,b,c,d,...,n)</code>，则转置后的<code>shape</code>为<code>(n,...,d,c,b,a)</code>，即逆序。</li><li>对于<code>.transpose()</code>，可以指定转置后的维度。语法：<code>A.transpose((axisOrder1,...,axisOrderN))</code>，其效果等同于<code>np.transpose(A,(axisOrder1,...,axisOrderN))</code>，(axisOrder)中是想要得到的索引下标顺序。效果详见例子。</li></ul><p>示例，指定维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]],[[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]],[[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]]])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a.shape)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a.transpose(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>).shape)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>A = np.transpose(a, (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(A.shape)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><code>a.transpose(1,2,0)</code>与<code>np.transpose(a, (1,2,0))</code>效果相同。其<code>shape</code>在第一个维度即<code>shape[0]</code>上是原来的<code>shape[1]</code>，第二维<code>shape[1]</code>是原来的<code>shape[2]</code>，第三维<code>shape[2]</code>是原来的<code>shape[0]</code>。所以原<code>shape</code>为<code>(3,2,4)</code>。新的  <code>shape</code>为<code>(2,4,3)</code>。</p><hr><p>参考：</p><p>参考手册：<a href="https://numpy.org.cn/reference/arrays/">https://numpy.org.cn/reference/arrays/</a></p><p><a href="http://c.biancheng.net/numpy/array-attribute.html">NumPy数组属性</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>数据处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python解析XML</title>
    <link href="/2023/04/04/Python%E8%A7%A3%E6%9E%90XML/"/>
    <url>/2023/04/04/Python%E8%A7%A3%E6%9E%90XML/</url>
    
    <content type="html"><![CDATA[<h1 id="解析XML的Python包"><a href="#解析XML的Python包" class="headerlink" title="解析XML的Python包"></a>解析XML的Python包</h1><p>Python的标准库中，提供了6种可以用于处理XML的包。</p><h2 id="xml-dom"><a href="#xml-dom" class="headerlink" title="xml.dom"></a>xml.dom</h2><p>xml.dom实现的是W3C制定的DOM API。如果你习惯于使用DOM API或者有人要求这这样做，可以使用这个包。不过要注意，在这个包中，还提供了几个不同的模块，各自的性能有所区别。</p><p>DOM解析器在任何处理开始之前，必须把基于XML文件生成的树状数据放在内存，所以DOM解析器的内存使用量完全根据输入资料的大小。</p><h2 id="xml-dom-minidom"><a href="#xml-dom-minidom" class="headerlink" title="xml.dom.minidom"></a>xml.dom.minidom</h2><p><code>xml.dom.minidom</code>是DOM API的极简化实现，比完整版的DOM要简单的多，而且这个包也小的多。那些不熟悉DOM的朋友，应该考虑使用<code>xml.etree.ElementTree</code>模块。<a href="https://link.juejin.cn/?target=https://mail.python.org/pipermail/python-dev/2011-December/114812.html">据lxml的作者评价</a>，这个模块使用起来并不方便，效率也不高，而且还容易出现问题。</p><h2 id="xml-dom-pulldom"><a href="#xml-dom-pulldom" class="headerlink" title="xml.dom.pulldom"></a>xml.dom.pulldom</h2><p>与其他模块不同，<code>xml.dom.pulldom</code>模块提供的是一个“pull解析器”，其背后的基本概念指的是从XML流中pull事件，然后进行处理。虽然与SAX一样采用事件驱动模型（event-driven processing model），但是不同的是，使用pull解析器时，使用者需要明确地从XML流中pull事件，并对这些事件遍历处理，直到处理完成或者出现错误。</p><blockquote><p>pull解析（pull parsing）是近来兴起的一种XML处理趋势。此前诸如SAX和DOM这些流行的XML解析框架，都是push-based，也就是说对解析工作的控制权，掌握在解析器的手中。</p></blockquote><h2 id="xml-sax"><a href="#xml-sax" class="headerlink" title="xml.sax"></a>xml.sax</h2><p><code>xml.sax</code>模块实现的是SAX API，这个模块牺牲了便捷性来换取速度和内存占用。SAX是Simple API for XML的缩写，它并不是由W3C官方所提出的标准。它是事件驱动的，并不需要一次性读入整个文档，而文档的读入过程也就是SAX的解析过程。所谓事件驱动，是指一种基于回调（callback）机制的程序运行方法。</p><h2 id="xml-etree-ElementTree（以下简称ET）"><a href="#xml-etree-ElementTree（以下简称ET）" class="headerlink" title="xml.etree.ElementTree（以下简称ET）"></a>xml.etree.ElementTree（以下简称ET）</h2><p><code>xml.etree.ElementTree</code>模块提供了一个轻量级、Pythonic的API，同时还有一个高效的C语言实现，即<code>xml.etree.cElementTree</code>。与DOM相比，ET的速度更快，API使用更直接、方便。与SAX相比，<code>ET.iterparse</code>函数同样提供了按需解析的功能，不会一次性在内存中读入整个文档。ET的性能与SAX模块大致相仿，但是它的API更加高层次，用户使用起来更加便捷。</p><h1 id="详解-xml-etree-ElementTree"><a href="#详解-xml-etree-ElementTree" class="headerlink" title="详解 xml.etree.ElementTree"></a>详解 xml.etree.ElementTree</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Element类型是一种灵活的容器对象，用于在内存中存储结构化数据。</p><blockquote><p>注意：xml.etree.ElementTree模块在应对恶意结构数据时显得并不安全。</p></blockquote><p>每个element对象都具有以下属性：</p><ul><li>tag：string对象，表示数据代表的种类。 </li><li>attrib：dictionary对象，表示附有的属性。 </li><li>text：string对象，表示element的内容。 </li><li>tail：string对象，表示element闭合之后的尾迹。 </li><li>若干子元素（child elements）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;tag attrib1=<span class="hljs-number">1</span>&gt;text&lt;/tag&gt;tail<br>  <span class="hljs-number">1</span>     <span class="hljs-number">2</span>        <span class="hljs-number">3</span>         <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>Python标准库中，提供了ET的两种实现。一个是纯Python实现的<code>xml.etree.ElementTree</code>，另一个是速度更快的C语言实现<code>xml.etree.cElementTree</code>。</p><p>Python 3.3版本之前优先导入C语言编译的API：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">import</span> xml.etree.cElementTree <span class="hljs-keyword">as</span> ET<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">import</span> xml.etree.ElementTree <span class="hljs-keyword">as</span> ET<br></code></pre></td></tr></table></figure><p>Python 3.3之后，<code>ElemenTree</code>模块会自动优先使用C加速器，如果不存在C实现，则会使用Python实现。</p><h3 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">xml</span>.etree.ElementTree.Element(tag, attrib=&#123;&#125;, **extra)<br><br>　　tag：string，元素代表的数据种类。<br>　　text：string，元素的内容。<br>　　tail：string，元素的尾形。<br>　　attrib：dictionary，元素的属性字典。<br>　　<br>　　＃针对属性的操作<br>　　clear()：清空元素的后代、属性、text和tail也设置为<span class="hljs-literal">None</span>。<br>　　get(key, default=<span class="hljs-literal">None</span>)：获取key对应的属性值，如该属性不存在则返回default值。<br>　　items()：根据属性字典返回一个列表，列表元素为(key, value）。<br>　　keys()：返回包含所有元素属性键的列表。<br>　　<span class="hljs-built_in">set</span>(key, value)：设置新的属性键与值。<br><br>　　＃针对后代的操作<br>　　append(subelement)：添加直系子元素。<br>　　extend(subelements)：增加一串元素对象作为子元素。＃python2<span class="hljs-number">.7</span>新特性<br>　　find(<span class="hljs-keyword">match</span>)：寻找第一个匹配子元素，匹配对象可以为tag或path。<br>　　findall(<span class="hljs-keyword">match</span>)：寻找所有匹配子元素，匹配对象可以为tag或path。<br>　　findtext(<span class="hljs-keyword">match</span>)：寻找第一个匹配子元素，返回其text值。匹配对象可以为tag或path。<br>　　insert(index, element)：在指定位置插入子元素。<br>　　<span class="hljs-built_in">iter</span>(tag=<span class="hljs-literal">None</span>)：生成遍历当前元素所有后代或者给定tag的后代的迭代器。＃python2<span class="hljs-number">.7</span>新特性<br>　　iterfind(<span class="hljs-keyword">match</span>)：根据tag或path查找所有的后代。<br>　　itertext()：遍历所有后代并返回text值。<br>　　remove(subelement)：删除子元素。<br></code></pre></td></tr></table></figure><h3 id="ElementTree对象"><a href="#ElementTree对象" class="headerlink" title="ElementTree对象"></a>ElementTree对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">xml</span>.etree.ElementTree.ElementTree(element=<span class="hljs-literal">None</span>, file=<span class="hljs-literal">None</span>)<br>　　element如果给定，则为新的ElementTree的根节点。<br><br>　　_setroot(element)：用给定的element替换当前的根节点。慎用。<br>　　<br>　　＃ 以下方法与Element类中同名方法近似，区别在于它们指定以根节点作为操作对象。<br>　　find(<span class="hljs-keyword">match</span>)<br>　　findall(<span class="hljs-keyword">match</span>)<br>　　findtext(<span class="hljs-keyword">match</span>, default=<span class="hljs-literal">None</span>)<br>　　getroot()：获取根节点.<br>　　<span class="hljs-built_in">iter</span>(tag=<span class="hljs-literal">None</span>)<br>　　iterfind(<span class="hljs-keyword">match</span>)<br>　　parse(source, parser=<span class="hljs-literal">None</span>)：装载xml对象，source可以为文件名或文件类型对象.<br>　　write(file, encoding=<span class="hljs-string">&quot;us-ascii&quot;</span>, xml_declaration=<span class="hljs-literal">None</span>, default_namespace=<span class="hljs-literal">None</span>,method=<span class="hljs-string">&quot;xml&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="将XML文档解析为树（tree）"><a href="#将XML文档解析为树（tree）" class="headerlink" title="将XML文档解析为树（tree）"></a>将XML文档解析为树（tree）</h3><p>XML是一种结构化、层级化的数据格式，最适合体现XML的数据结构就是树。ET提供了两个对象：<code>ElementTree</code>将整个XML文档转化为树，<code>Element</code>则代表着树上的单个节点。对整个XML文档的交互（读取，写入，查找需要的元素），一般是在<code>ElementTree</code>层面进行的。对单个XML元素及其子元素，则是在<code>Element</code>层面进行的。</p><p>使用下面的XML文档，作为演示数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ProductMetaData</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">SatelliteID</span>&gt;</span>HY-1C<span class="hljs-tag">&lt;/<span class="hljs-name">SatelliteID</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">SensorID</span>&gt;</span>CZI<span class="hljs-tag">&lt;/<span class="hljs-name">SensorID</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">TimeType</span>&gt;</span>MONTHLY<span class="hljs-tag">&lt;/<span class="hljs-name">TimeType</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ProductUnit</span>&gt;</span>NSOAS<span class="hljs-tag">&lt;/<span class="hljs-name">ProductUnit</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ProductInfo</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ProductLevel</span>&gt;</span>L1B<span class="hljs-tag">&lt;/<span class="hljs-name">ProductLevel</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ProductFormat</span>&gt;</span>HDF5.0<span class="hljs-tag">&lt;/<span class="hljs-name">ProductFormat</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ProductDescription</span>&gt;</span>HY-1C LEVELL1B Product<span class="hljs-tag">&lt;/<span class="hljs-name">ProductDescription</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ProcessingType</span>&gt;</span>OPER<span class="hljs-tag">&lt;/<span class="hljs-name">ProcessingType</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ProduceTime</span>&gt;</span>2022-04-25T03:18:00.225817<span class="hljs-tag">&lt;/<span class="hljs-name">ProduceTime</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SpatialResolution</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SpatialResolution</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ProductInfo</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ProductMetaData</span>&gt;</span><br></code></pre></td></tr></table></figure><p>加载xml文档，获取ElementTree对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> xml.etree.ElementTree <span class="hljs-keyword">as</span> ET<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>tree = ET.ElementTree(file=<span class="hljs-string">&#x27;D:\PythonFiles\SatelliteDataParsing\H1C_OPER_CZI_L1B_20220425T025003_20220425T025059_19011_10.meta.xml&#x27;</span>)<br><br><br>&lt;xml.etree.ElementTree.ElementTree <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001DA59EB5940</span>&gt;<br></code></pre></td></tr></table></figure><p>获取根元素（root element）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>root = tree获取根元素（root element）.getroot()<br><span class="hljs-meta">&gt;&gt;&gt; </span>root.tag, root.attrib, root.text, root.tail<br>(<span class="hljs-string">&#x27;ProductMetaData&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;\n    &#x27;</span>, <span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>遍历直接子元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> root:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(child.tag, child.attrib, child.text)<br><span class="hljs-meta">... </span><br>SatelliteID &#123;&#125; HY-1C<br>SensorID &#123;&#125; CZI<br>TimeType &#123;&#125; MONTHLY<br>ProductUnit &#123;&#125; NSOAS<br>ProductInfo &#123;&#125;<br></code></pre></td></tr></table></figure><p>通过索引值来访问特定的子元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>root[<span class="hljs-number">0</span>].tag, root[<span class="hljs-number">0</span>].text<br>(<span class="hljs-string">&#x27;SatelliteID&#x27;</span>, <span class="hljs-string">&#x27;HY-1C&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>root[<span class="hljs-number">4</span>][<span class="hljs-number">0</span>].tag, root[<span class="hljs-number">4</span>][<span class="hljs-number">0</span>].text<br>(<span class="hljs-string">&#x27;ProductLevel&#x27;</span>, <span class="hljs-string">&#x27;L1B&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>Element对象有一个iter方法，可以对某个元素对象之下所有的子元素进行深度优先遍历（DFS）。ElementTree对象同样也有这个方法。下面是查找XML文档中所有元素的最简单方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> tree.<span class="hljs-built_in">iter</span>():<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(e.tag, e.attrib, e.text)<br><span class="hljs-meta">... </span><br>ProductMetaData &#123;&#125; <br>    <br>SatelliteID &#123;&#125; HY-1C<br>SensorID &#123;&#125; CZI<br>TimeType &#123;&#125; MONTHLY<br>ProductUnit &#123;&#125; NSOAS<br>ProductInfo &#123;&#125; <br>        <br>ProductLevel &#123;&#125; L1B<br>ProductFormat &#123;&#125; HDF5<span class="hljs-number">.0</span><br>ProductDescription &#123;&#125; HY-1C LEVELL1B Product<br>ProcessingType &#123;&#125; OPER<br>ProduceTime &#123;&#125; <span class="hljs-number">2022</span>-04-25T03:<span class="hljs-number">18</span>:<span class="hljs-number">00.225817</span><br>SpatialResolution &#123;&#125; <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>遍历所有具备所提供tag的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> tree.<span class="hljs-built_in">iter</span>(tag=<span class="hljs-string">&#x27;ProductName&#x27;</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(e.tag, e.attrib, e.text)<br><span class="hljs-meta">... </span>   <br>ProductLevel &#123;&#125; L1B<br></code></pre></td></tr></table></figure><h3 id="通过XPath查找元素"><a href="#通过XPath查找元素" class="headerlink" title="通过XPath查找元素"></a>通过XPath查找元素</h3><p>Element对象中有一些find方法可以接受Xpath路径作为参数，find方法会返回第一个匹配的子元素，findall以列表的形式返回所有匹配的子元素, iterfind则返回一个所有匹配元素的迭代器（iterator）。ElementTree对象也具备这些方法，相应地它的查找是从根节点开始的。</p><p><strong>ProductInfo元素之下所有tag为ProductFormat的元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> tree.iterfind(<span class="hljs-string">&#x27;ProductInfo/ProductFormat&#x27;</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(e.tag, e.attrib, e.text)<br><span class="hljs-meta">... </span><br>ProductFormat &#123;&#125; HDF5<span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p><strong>查找所有具备某个name属性的branch元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># for elem in tree.iterfind(&#x27;branch[@name=&quot;release01&quot;]&#x27;):</span><br><span class="hljs-comment">#     print elem.tag, elem.attrib</span><br></code></pre></td></tr></table></figure><h3 id="构建XML文档"><a href="#构建XML文档" class="headerlink" title="构建XML文档"></a>构建XML文档</h3><p>利用ET，很容易就可以完成XML文档构建，并写入保存为文件。ElementTree对象的write方法就可以实现这个需求。</p><p>一般来说，有两种主要使用场景。一是你先读取一个XML文档，进行修改，然后再将修改写入文档，二是从头创建一个新XML文档。</p><p>修改文档的话，可以通过调整Element对象来实现。请看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>root = tree.getroot()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> root[<span class="hljs-number">2</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>root[<span class="hljs-number">0</span>].<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> subelem <span class="hljs-keyword">in</span> root:<br><span class="hljs-meta">... </span>  <span class="hljs-built_in">print</span> subelem.tag, subelem.attrib<br>...<br>branch &#123;<span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;hash&#x27;</span>: <span class="hljs-string">&#x27;1cdf045c&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;codingpy.com&#x27;</span>&#125;<br>branch &#123;<span class="hljs-string">&#x27;hash&#x27;</span>: <span class="hljs-string">&#x27;f200013e&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;release01&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们删除了root元素的第三个子元素，为第一个子元素增加了新属性。这个树可以重新写入至文件中。最终的XML文档应该是下面这样的：</p><p>请注意，文档中元素的属性顺序与原文档不同。这是因为ET是以字典的形式保存属性的，而字典是一个无序的数据结构。当然，XML也不关注属性的顺序。</p><p>从头构建一个完整的文档也很容易。ET模块提供了一个SubElement工厂函数，让创建元素的过程变得很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = ET.Element(<span class="hljs-string">&#x27;elem&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>c = ET.SubElement(a, <span class="hljs-string">&#x27;child1&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>c.text = <span class="hljs-string">&quot;some text&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d = ET.SubElement(a, <span class="hljs-string">&#x27;child2&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = ET.Element(<span class="hljs-string">&#x27;elem_b&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>root = ET.Element(<span class="hljs-string">&#x27;root&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>root.extend((a, b))<br><span class="hljs-meta">&gt;&gt;&gt; </span>tree = ET.ElementTree(root)<br><span class="hljs-meta">&gt;&gt;&gt; </span>tree.write(sys.stdout)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tree.<span class="hljs-built_in">iter</span>():<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(i.tag, i.attrib, i.text)<br><span class="hljs-meta">... </span>    <br>root &#123;&#125; <span class="hljs-literal">None</span><br>elem &#123;&#125; <span class="hljs-literal">None</span><br>child1 &#123;&#125; some text<br>child2 &#123;&#125; <span class="hljs-literal">None</span><br>elem_b &#123;&#125; <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h3 id="利用iterparse解析XML流"><a href="#利用iterparse解析XML流" class="headerlink" title="利用iterparse解析XML流"></a>利用iterparse解析XML流</h3><p>ML文档通常都会比较大，如何直接将文档读入内存的话，那么进行解析时就会出现问题。这也就是为什么不建议使用DOM，而是SAX API的理由之一。</p><p>我们上面谈到，ET可以将XML文档加载为保存在内存里的树（in-memory tree），然后再进行处理。但是在解析大文件时，这应该也会出现和DOM一样的内存消耗大的问题吧？没错，的确有这个问题。为了解决这个问题，ET提供了一个类似SAX的特殊工具——iterparse，可以循序地解析XML。</p><p>接下来，笔者为大家展示如何使用iterparse，并与标准的树解析方式进行对比。我们使用一个<a href="https://link.juejin.cn/?target=http://www.xml-benchmark.org/generator.html">自动生成的XML文档</a>，下面是该文档的开头部分：</p><p>……</p><hr><h2 id="模块方法"><a href="#模块方法" class="headerlink" title="模块方法"></a>模块方法</h2><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment()"></a>Comment()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.Comment(text=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>创建一个特别的element，通过标准序列化使其代表了一个comment。comment可以为bytestring或unicode。</p><h3 id="dump"><a href="#dump" class="headerlink" title="dump()"></a>dump()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.dump(elem)<br></code></pre></td></tr></table></figure><p>生成一个element tree，通过sys.stdout输出，elem可以是元素树或单个元素。这个方法最好只用于debug。</p><h3 id="fromstring"><a href="#fromstring" class="headerlink" title="fromstring()"></a>fromstring()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.fromstring(text) <br></code></pre></td></tr></table></figure><p>text是一个包含XML数据的字符串，与XML()方法类似，返回一个Element实例。</p><h3 id="fromstringlist"><a href="#fromstringlist" class="headerlink" title="fromstringlist()"></a>fromstringlist()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.fromstringlist(sequence, parser=<span class="hljs-literal">None</span>) <br></code></pre></td></tr></table></figure><p>从字符串的序列对象中解析xml文档。缺省parser为XMLParser，返回Element实例。 </p><p>New in version 2.7.</p><h3 id="iselement"><a href="#iselement" class="headerlink" title="iselement()"></a>iselement()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.iselement(element)<br></code></pre></td></tr></table></figure><p>检查是否是一个element对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">iterparse() <br>xml.etree.ElementTree.iterparse(source, events=<span class="hljs-literal">None</span>, parser=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>将文件或包含xml数据的文件对象递增解析为element tree，并且报告进度。events是一个汇报列表，如果忽略，将只有end事件会汇报出来。 </p><p>注意，iterparse()只会在看见开始标签的”&gt;”符号时才会抛出start事件，因此届时属性是已经定义了，但是text和tail属性在那时还没有定义，同样子元素也没有定义，因此他们可能不能被显示出来。如果你想要完整的元素，请查找end事件。</p><h3 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.parse(source, parser=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>将一个文件或者字符串解析为element tree。</p><h3 id="SubElement"><a href="#SubElement" class="headerlink" title="SubElement()"></a>SubElement()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.SubElement(parent, tag, attrib=&#123;&#125;, **extra)<br></code></pre></td></tr></table></figure><p>子元素工厂，创建一个Element实例并追加到已知的节点。</p><h3 id="tostring"><a href="#tostring" class="headerlink" title="tostring()"></a>tostring()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.tostring(element, encoding=<span class="hljs-string">&quot;us-ascii&quot;</span>, method=<span class="hljs-string">&quot;xml&quot;</span>)<br></code></pre></td></tr></table></figure><p>生成一个字符串来表示表示xml的element，包括所有子元素。element是Element实例，method为”xml”,”html”,”text”。返回包含了xml数据的字符串。</p><h3 id="tostringlist"><a href="#tostringlist" class="headerlink" title="tostringlist()"></a>tostringlist()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xml.etree.ElementTree.tostringlist(element, encoding=<span class="hljs-string">&quot;us-ascii&quot;</span>, method=<span class="hljs-string">&quot;xml&quot;</span>)<br></code></pre></td></tr></table></figure><p>生成一个字符串来表示表示xml的element，包括所有子元素。element是Element实例，method为”xml”,”html”,”text”。返回包含了xml数据的字符串列表。</p><hr><p>参考：</p><p><a href="https://juejin.cn/post/6844903426740994056#heading-8">https://juejin.cn/post/6844903426740994056#heading-8</a></p><p><a href="https://zhuanlan.zhihu.com/p/152207687">https://zhuanlan.zhihu.com/p/152207687</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>数据处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据类型</title>
    <link href="/2023/03/08/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/03/08/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1><p>Redis 支持五种基本类型：<strong>String（字符串）</strong>，<strong>Hash（哈希）</strong>，<strong>List（列表）</strong>，<strong>Set（集合）</strong>及**SortedSet（zset：有序集合)**。</p><p>其他特殊类型有 <strong>GEO（主要用于存储地理位置信息）</strong>，<strong>BitMap（位图）</strong>，<strong>HyperLogLog（用来做基数统计的算法）</strong>。</p><h1 id="Redis-数据结构介绍"><a href="#Redis-数据结构介绍" class="headerlink" title="Redis 数据结构介绍"></a>Redis 数据结构介绍</h1><p>Redis 将操作不同数据类型的命令做了分组，官网（<a href="https://redis.io/commands%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E3%80%82">https://redis.io/commands）可以查看命令。</a></p><table><thead><tr><th>类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td>String(字符串)</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—</td></tr><tr><td>Hash(字典)</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td>List(列表)</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td>Set(集合)</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1)； 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td>Sorted Set(有序集合)</td><td>将Set中的元素增加一个权重参数score，元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table><h1 id="Redis-通用命令"><a href="#Redis-通用命令" class="headerlink" title="Redis 通用命令"></a>Redis 通用命令</h1><p>通用命令是部分数据类型的，都可以使用的命令，常见的有：</p><ul><li><code>KEYS</code>：查看符合模板的所有 key（不建议在生产环境设备上使用，如果数据量较大，会阻塞所有请求）。</li><li><code>DEL</code>：删除指定的 key（可跟多个key批量删除）</li><li><code>EXISTS</code>：判断 key 是否存在</li><li><code>EXPIRE</code>：给一个 key 设置有效期，有效期到期时该 key 会被自动删除</li><li><code>TTL</code>：查看一个 key 的剩余有效期（<code>-2</code>已过期，<code>-1</code>永久有效）</li></ul><p>通过 <code>help [command]</code> 可以查看一个命令的具体用法</p><h1 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h1><p>String 类型，是 Redis 中最简单的存储类型。</p><p>其 value 是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自  减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m。</p><h2 id="String-常用命令"><a href="#String-常用命令" class="headerlink" title="String 常用命令"></a>String 常用命令</h2><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/redis/strings-set.html">SET</a> key value</td><td>设置指定 key 的值。</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/redis/strings-get.html">GET</a> key</td><td>获取指定 key 的值。</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/strings-mset.html">MSET</a> key value [key value …]</td><td>同时设置一个或多个 key-value 对。</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/strings-mget.html">MGET</a> key1 [key2..]</td><td>获取所有(一个或多个)给定 key 的值。</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/redis/strings-setex.html">SETEX</a> key seconds value</td><td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/redis/strings-setnx.html">SETNX</a> key value</td><td>只有在 key 不存在时设置 key 的值。</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/redis/strings-incr.html">INCR</a> key</td><td>将 key 中储存的数字值自增1。</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY</a> key increment</td><td>将 key 所储存的值自增并指定步长 ，如：incrby num 2 让num自增2</td></tr><tr><td>9</td><td><a href="https://www.runoob.com/redis/strings-decr.html">DECR</a> key</td><td>将 key 中储存的数字值减一。</td></tr><tr><td>10</td><td><a href="https://www.runoob.com/redis/strings-append.html">APPEND</a> key value</td><td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td></tr></tbody></table><h2 id="key-层级格式"><a href="#key-层级格式" class="headerlink" title="key 层级格式"></a>key 层级格式</h2><p>Redis 没有类似 MySQL 中的 Table 的概念，如何区分不同类型的 key 呢？比如用户 id 和商品 id ？</p><ul><li>Redis 的 key 允许有多个单词形成层级结构，多个单词之间用<code>:</code>分隔，格式如：<code>项目名:业务名:类型:id</code></li></ul><p>例，假设项目名为 kingshit，有 user 和 product 两种不同类型的数据，可以这样定义key：</p><ul><li>user 相关的 key：<code>kingshit:user:1</code></li><li>product 相关的 key：<code>kingshit:product:1</code></li></ul><h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><p>如果 value 是一个 Java 对象，则可以将对象序列化为 JSON 字符串后存储：</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>kingshit:user:1</td><td>{“id”: 1, “name”: “rwj”, “age”: 28}</td></tr><tr><td>kingshit:product:1</td><td>{“id”: 1, “name”: “Redmi K50 Ultra”, “price”: 3000}</td></tr></tbody></table><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>存储单个值，如用户信息、计数器等。</p><h1 id="Hash-类型"><a href="#Hash-类型" class="headerlink" title="Hash 类型"></a>Hash 类型</h1><p>Redis Hash 类型，也叫<strong>散列</strong>，其 value 是一个无序字典，类似于 Java 中的 HashMap 结构。</p><p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿），特别适合用于存储<strong>对象</strong>（上文将对象序列化为JSON方式存储不方便修改某个字段）。</p><h2 id="对象存储（better）"><a href="#对象存储（better）" class="headerlink" title="对象存储（better）"></a>对象存储（better）</h2><p>Hash结构：可以将对象中的每个字段独立存储，可针对单个字段做CRUD：</p><table><thead><tr><th>KEY</th><th>VALUE</th><th></th></tr></thead><tbody><tr><td>field</td><td>value</td><td></td></tr><tr><td>kingshit:user:1</td><td>name</td><td>rwj</td></tr><tr><td>age</td><td>28</td><td></td></tr><tr><td>kingshit:user:2</td><td>name</td><td>niu</td></tr><tr><td>age</td><td>27</td><td></td></tr></tbody></table><h2 id="Hash-常用命令"><a href="#Hash-常用命令" class="headerlink" title="Hash 常用命令"></a>Hash 常用命令</h2><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/redis/hashes-hset.html">HSET</a> key field value</td><td>将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/redis/hashes-hget.html">HGET</a> key field</td><td>获取存储在哈希表中指定字段的值。</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL</a> key</td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS</a> key</td><td>获取一个hash类型的key中所有的field</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/redis/hashes-hvals.html">HVALS</a> key</td><td>获取一个hash类型的key中所有的value</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY</a> key field increment</td><td>为哈希表 key 中的指定字段的整数值自增并指定步长。</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX</a> key field value</td><td>只有在字段 field 不存在时，设置哈希表字段的值。</td></tr></tbody></table><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>存储对象的字段和值，如存储用户对象、文章对象等。</p><h1 id="List-类型"><a href="#List-类型" class="headerlink" title="List 类型"></a>List 类型</h1><p>Redis 中的是简单的字符串列表，按照插入顺序排序。支持正向和反向检索。</p><p>常用来存储一个有序数据，例如：评论列表、点赞列表等。</p><p>类似 Java 的 LinkedList。</p><p>特征：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除速度快</li><li>查询速度一般</li></ul><h2 id="List-常用命令"><a href="#List-常用命令" class="headerlink" title="List 常用命令"></a>List 常用命令</h2><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/redis/lists-lpush.html">LPUSH</a> key value1 [value2]<a href="https://www.runoob.com/redis/lists-rpush.html">RPUSH</a> key value1 [value2]</td><td>将一个或多个值插入到列表头部将一个或多个值添加到列表尾部</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP</a> key<a href="https://www.runoob.com/redis/lists-rpop.html">RPOP</a> key</td><td>移出并获取列表的第一个元素，没有则返回nil移出并获取列表的最后一个元素，没有则返回nil</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE</a> key start stop</td><td>获取列表指定范围内的元素</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/lists-blpop.html">BLPOP</a> key1 [key2 ] timeout<a href="https://www.runoob.com/redis/lists-brpop.html">BRPOP</a> key1 [key2 ] timeout</td><td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr></tbody></table><p>思考：</p><p>利用 LIst 结构模拟一个栈</p><ul><li>入口和出口在同一侧（L或者R），存取数据用LPUSH+LPOP结合（或都是R）</li></ul><p>利用 List 结构模拟一个队列</p><ul><li>入口和出口在不同侧，存取数据用首尾结合方式（LPUSH+RPOP）（或RL）</li></ul><p>利用 List 结构模拟一个阻塞队列</p><ul><li>入口和出口在不同侧</li><li>出队时采用 BLPOP 或 BRPOP</li></ul><h2 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h2><p>存储有序的字符串列表。如消息队列、最新消息列表等。</p><h1 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h1><p>是 String 类型的无序集合。集合成员是唯一的，即集合中不能出现重复的数据。</p><p>集合对象的编码可以是 intset 或者 hashtable。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>类似 Java 的 HashSet。</p><p>特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查询速度快</li><li>支持交集、并集、差集等功能</li></ul><h2 id="Set-常用命令"><a href="#Set-常用命令" class="headerlink" title="Set 常用命令"></a>Set 常用命令</h2><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/redis/sets-sadd.html">SADD</a> key member1 [member2]</td><td>向集合添加一个或多个元素</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/redis/sets-srem.html">SREM</a> key member1 [member2]</td><td>移除集合中一个或多个元素</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/sets-scard.html">SCARD</a> key</td><td>获取集合的成员数（元素个数）</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER</a> key member</td><td>判断 member 元素是否是集合 key 的成员</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS</a> key</td><td>返回集合中的所有元素</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/redis/sets-sinter.html">SINTER</a> key1 [key2]</td><td>返回给定所有集合的交集</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/redis/sets-sdiff.html">SDIFF</a> key1 [key2]</td><td>返回第一个集合与其他集合之间的差异（差集）。</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/redis/sets-sunion.html">SUNION</a> key1 [key2]</td><td>返回所有给定集合的并集</td></tr></tbody></table><h2 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h2><p>存储无序的唯一元素，如标签、好友列表等。</p><h1 id="SortedSet-类型"><a href="#SortedSet-类型" class="headerlink" title="SortedSet 类型"></a>SortedSet 类型</h1><p>Redis 的 SortedSet 是一个可排序的 set 集合。</p><p>SortedSet 中每个元素都会关联一个 double 类型的分数 score，可以基于 score 属性对元素排序，底层的实现是一个跳表（SkipList）+ hash 表。</p><p>有序集合的成员不可重复，但 score 可重复。</p><p>与 Java 中的 TreeSet 类似，但底层数据结构差别很大。</p><p>特征：</p><ul><li>可排序</li><li>元素不可重复</li><li>查询速度快</li></ul><p>因为 SortedSet 的可排序性，经常被用来实现排行榜这样的功能。</p><h2 id="SortedSet-常用命令"><a href="#SortedSet-常用命令" class="headerlink" title="SortedSet 常用命令"></a>SortedSet 常用命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zadd.html">ZADD</a> key score1 member1 [score2 member2]</td><td>向有序集合添加一个或多个成员，若已存在则更新其 score 值</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrem.html">ZREM</a> key member [member …]</td><td>移除有序集合中的一个或多个成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE</a> key member</td><td>返回有序集中，成员的 score 值</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK</a> key member</td><td>返回有序集合中指定成员的排名（索引）</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD</a> key</td><td>获取有序集合的成员个数</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT</a> key min max</td><td>计算在有序集合中指定区间分数的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY</a> key increment member</td><td>有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrange.html">ZRANGE</a> key start stop [WITHSCORES]</td><td>通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">ZRANGEBYSCORE</a> key min max [WITHSCORES] [LIMIT]</td><td>通过分数返回有序集合指定区间内的成员</td></tr><tr><td>ZDIFF、ZINTER、ZUNION</td><td>求差集、交集、并集</td></tr></tbody></table><p>注意：所有的排名默认都是升序，如果要降序则在命令的 Z 后添加 REV 即可，如：</p><h2 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h2><p>存储有序的唯一元素，每个元素都关联一个分数，常用于排行榜、计分系统等。</p><h1 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a>使用场景分析</h1><ul><li><strong>缓存</strong>：使用<strong>字符串</strong>存储缓存数据，列表存储消息队列，集合存储用户标签等。</li><li><strong>计数器</strong>：使用<strong>字符串的 INCR 命令</strong>实现计数器功能。</li><li><strong>会话管理</strong>：使用<strong>哈希表</strong>存储用户会话信息，如用户登录状态、权限等。</li><li><strong>发布订阅</strong>：使用发布订阅功能实现消息广播。</li><li><strong>排行榜</strong>：使用<strong>有序集合</strong>存储用户分数，实现排行榜功能。</li><li><strong>实时统计</strong>：使用<strong>计数器</strong>、<strong>有序集合</strong>等数据结构实现实时统计功能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis安装配置</title>
    <link href="/2023/03/08/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/03/08/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis-简介"><a href="#一、Redis-简介" class="headerlink" title="一、Redis 简介"></a>一、Redis 简介</h1><p>Redis（Remote Dictionary Server），远程词典服务器，是一个基于内存的键值型 NoSQL 数据库。</p><p>特征</p><ul><li>键值型，value 支持多种不同数据结构</li><li>单线程，每个命令具备原子性。意思是要么成功执行要么失败完全不执行。</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li></ul><h1 id="二、什么是NoSQL"><a href="#二、什么是NoSQL" class="headerlink" title="二、什么是NoSQL"></a>二、什么是NoSQL</h1><p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。</p><ul><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>键 - 值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理</li><li>高性能，高可用性和可伸缩性</li></ul><h1 id="三、Redis-服务安装"><a href="#三、Redis-服务安装" class="headerlink" title="三、Redis 服务安装"></a>三、Redis 服务安装</h1><h2 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1 下载"></a>3.1 下载</h2><p>Redis 使用标准的做法进行版本管理: 主版本号.副版本号.补丁号。 偶数 副版本号 表示一个 稳定的 发布，像 1.2, 2.0, 2.2, 2.4, 2.6, 2.8。奇数副版本号表示 不稳定的 发布，例如 2.9.x 发布是一个不稳定版本，下一个稳定版本将会是Redis 3.0。</p><p>Redis 最新的稳定版本可以在 <a href="https://download.redis.io/redis-stable.tar.gz">https://download.redis.io/redis-stable.tar.gz</a> 下载 。 相应的 SHA256 校验和 <a href="https://download.redis.io/redis-stable.tar.gz.SHA256SUM%E3%80%82">https://download.redis.io/redis-stable.tar.gz.SHA256SUM。</a> 最新稳定版本的源码可以在 <a href="https://download.redis.io/redis-stable">这里获得 ,</a> 使用 <strong>src&#x2F;version.h</strong> 文件以便可以自动获取版本信息。更多：<a href="https://redis.com.cn/download.html">Redis下载和安装</a>。</p><p>Linux版（官网）：<a href="https://redis.io/">https://redis.io/</a></p><p>在线下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://download.redis.io/releases/redis-x.x.x.tar.gz<br></code></pre></td></tr></table></figure><p>Windows版：<a href="https://github.com/tporadowski/redis/releases%EF%BC%88%E5%AE%98%E6%96%B9%E5%B9%B6%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9Bwin%E7%89%88%EF%BC%8Cwin%E7%89%88%E6%98%AF%E5%BE%AE%E8%BD%AF%E7%BC%96%E8%AF%91%E7%9A%84%EF%BC%89">https://github.com/tporadowski/redis/releases（官方并没有提供win版，win版是微软编译的）</a></p><h2 id="3-2-单机安装"><a href="#3-2-单机安装" class="headerlink" title="3.2 单机安装"></a>3.2 单机安装</h2><h3 id="3-2-1-安装-Redis-依赖"><a href="#3-2-1-安装-Redis-依赖" class="headerlink" title="3.2.1 安装 Redis 依赖"></a>3.2.1 安装 Redis 依赖</h3><p>Redis 是基于 C 语言编写的，因此首先需要安装 Redis 所需要的 gcc 依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y gcc tcl<br></code></pre></td></tr></table></figure><h3 id="3-2-2-上传安装包并解压"><a href="#3-2-2-上传安装包并解压" class="headerlink" title="3.2.2 上传安装包并解压"></a>3.2.2 上传安装包并解压</h3><h4 id="3-2-2-1-上传"><a href="#3-2-2-1-上传" class="headerlink" title="3.2.2.1 上传"></a>3.2.2.1 上传</h4><p>把安装包上传到 Linux 服务器任意目录（在 Linux 下载可跳过此步），例如，我放到了<code>usr/local/src</code>目录。</p><h4 id="3-2-2-2-解压缩"><a href="#3-2-2-2-解压缩" class="headerlink" title="3.2.2.2 解压缩"></a>3.2.2.2 解压缩</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xzf redis-7.0.9.tar.gz<br></code></pre></td></tr></table></figure><h4 id="3-2-2-3-安装"><a href="#3-2-2-3-安装" class="headerlink" title="3.2.2.3 安装"></a>3.2.2.3 安装</h4><p>进入到redis目录，安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>默认的安装路径是在<code>/usr/local/bin</code>目录下：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/redis%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95.png" alt="redis默认安装目录"></p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行命令。其中：</p><ul><li>redis-cli：是 redis 提供的命令行客户端</li><li>redis-server：是 redis 的服务端启动脚本</li><li>redis-sentinel：是 redis 的哨兵启动脚本</li></ul><h2 id="3-3-Redis-启动"><a href="#3-3-Redis-启动" class="headerlink" title="3.3 Redis 启动"></a>3.3 Redis 启动</h2><p>redis 的启动方式有很多种，如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="3-3-1-默认启动（不推荐）"><a href="#3-3-1-默认启动（不推荐）" class="headerlink" title="3.3.1 默认启动（不推荐）"></a>3.3.1 默认启动（不推荐）</h3><p>使用 <code>redis-server</code> 命令即可启动 Redis：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/redis-server%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8.png" alt="redis-server命令启动"></p><p>这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭 Redis 会停止，不推荐使用。</p><h3 id="3-3-2-指定配置启动"><a href="#3-3-2-指定配置启动" class="headerlink" title="3.3.2 指定配置启动"></a>3.3.2 指定配置启动</h3><p>后台启动必须修改 Redis 配置文件，位于解压后的目录内：<code>/usr/local/src/redis-6.2.6/redis.conf</code>。</p><p>先将配置文件进行备份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp redis.conf redis.conf.bck<br></code></pre></td></tr></table></figure><p>然后修改<code>redis.conf</code>文件中的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">守护进程，修改为 <span class="hljs-built_in">yes</span> 后即可后台运行</span><br>daemonize yes<br></code></pre></td></tr></table></figure><p>启动 Redis：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入 redis 安装目录</span><br>cd /usr/local/src/redis=6.2.6<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>停止 Redis：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">利用redis-cli执行shutdown命令，停止redis服务</span><br>redis-cli shutdown<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果配置了密码，需要加上-u参数指定密码</span><br>redis-cli -u 123456 shutdown<br></code></pre></td></tr></table></figure><h3 id="3-3-3-开机自启"><a href="#3-3-3-开机自启" class="headerlink" title="3.3.3 开机自启"></a>3.3.3 开机自启</h3><ol><li>新建系统服务文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/systemd/system/redis.service<br></code></pre></td></tr></table></figure><p>关于 &#x2F;etc&#x2F;systemd&#x2F;system 目录更多请参考：<a href="https://www.yuque.com/kingshit/wz61vk/lcigqnkrd2ndd557">关于system目录</a></p><p>新增内容：</p><p>注意<code>ExecStart</code>的内容要修改为自己服务器的实际路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">[Unit]<br>Description=redis-server<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ol><li>重载系统服务：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br></code></pre></td></tr></table></figure><ol><li>现在就可以用下面这组命令来操作 redis 了：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>systemctl start redis<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止</span><br>systemctl stop redis<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启</span><br>systemctl restart redis<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span><br>systemctl status redis<br></code></pre></td></tr></table></figure><ol><li>执行下面的命令，让 redis 开机自启：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable redis<br></code></pre></td></tr></table></figure><h1 id="四、Redis-配置文件"><a href="#四、Redis-配置文件" class="headerlink" title="四、Redis 配置文件"></a>四、Redis 配置文件</h1><h2 id="4-1-查看配置项"><a href="#4-1-查看配置项" class="headerlink" title="4.1 查看配置项"></a>4.1 查看配置项</h2><h2 id="4-2-更改配置项"><a href="#4-2-更改配置项" class="headerlink" title="4.2 更改配置项"></a>4.2 更改配置项</h2><h2 id="4-3-更改配置文件"><a href="#4-3-更改配置文件" class="headerlink" title="4.3 更改配置文件"></a>4.3 更改配置文件</h2><p>Redis 某些配置信息无法直接通过命令修改，此时就需要修改配置文件。</p><p>比如设置 Redis 允许远程连接的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注释掉本地IP地址,绑定要访问的外部IP</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">bind</span> 127.0.0.1 ::1</span><br>bind 192.168.75.129           # listens on specific IPv4 addresses<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭保护模式(把<span class="hljs-built_in">yes</span>改为no)</span><br>protected-mode no<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Linux重启</span><br>sudo /etc/init.d/redis-server restart<br></code></pre></td></tr></table></figure><h2 id="4-4-常用配置"><a href="#4-4-常用配置" class="headerlink" title="4.4 常用配置"></a>4.4 常用配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">监听的地址，默认是 127.0.0.1，会导致只能在本地访问。修改为 0.0.0.0 则可以在任意IP访问</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意：生产环境不要设置为 0.0.0.0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">bind</span> 127.0.0.1 -::1</span><br>bind 0.0.0.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">守护进程，修改为 <span class="hljs-built_in">yes</span> 后即可后台运行</span><br>daemonize yes<br><span class="hljs-meta prompt_"># </span><span class="language-bash">密码，设置后访问 Redis 必须输入密码</span><br>requirepass 123456<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">监听的端口</span><br>port 6379<br><span class="hljs-meta prompt_"># </span><span class="language-bash">工作目录，默认是当前目录，即运行 redis-server 时的命令，日志、持久化等文件会保存在这个目录</span><br>dir .<br><span class="hljs-meta prompt_"># </span><span class="language-bash">数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br>databases 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 redis 能够使用的最大内存</span><br>maxmemory 512mb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志文件，默认为空，不记录日志，可以指定日志文件名</span><br>logfile &quot;redis.log&quot;<br></code></pre></td></tr></table></figure><blockquote><p>vim 常用指令：</p><p><code>/pattern</code>：向后查找字符串pattern</p><p><code>?pattern</code>：向前搜索字符串pattern</p><p><code>n</code>： 下一个匹配(如果是&#x2F;搜索，则是向下的下一个，?搜索则是向上的下一个)</p><p><code>N</code>：上一个匹配(同上)</p><p><code>u</code>：撤销</p></blockquote><h2 id="4-5-其它配置说明"><a href="#4-5-其它配置说明" class="headerlink" title="4.5 其它配置说明"></a>4.5 其它配置说明</h2><table><thead><tr><th>配置项</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>daemonize</td><td>no&#x2F;yes</td><td>默认为 no，表示 Redis 不是以守护进程的方式运行，通过修改为 yes 启用守护进程。</td></tr><tr><td>pidfile</td><td>文件路径</td><td>当 Redis 以守护进程方式运行时，会把进程 pid 写入自定义的文件中。</td></tr><tr><td>port</td><td>6379</td><td>指定 Redis 监听端口，默认端口为 6379。</td></tr><tr><td>bind</td><td>127.0.0.1</td><td>绑定的主机地址。</td></tr><tr><td>timeout</td><td>0</td><td>客户端闲置多长秒后关闭连接，若指定为 0 ，表示不启用该功能。</td></tr><tr><td>loglevel</td><td>notice</td><td>指定日志记录级别，支持四个级别：debug、verbose、notice、warning，默认为 notice。</td></tr><tr><td>logfile</td><td>stdout</td><td>日志记录方式，默认为标准输出。</td></tr><tr><td>databases</td><td>16</td><td>设置数据库的数量（0-15个）共16个，Redis 默认选择的是 0 库，可以使用 SELECT 命令来选择使用哪个数据库储存数据。</td></tr><tr><td>save[seconds][changes]</td><td>可以同时配置三种模式：save 900 1save 300 10save 60 10000</td><td>表示在规定的时间内，执行了规定次数的写入或修改操作，Redis 就会将数据同步到指定的磁盘文件中。比如 900s 内做了一次更改，Redis 就会自动执行数据同步。</td></tr><tr><td>rdbcompression</td><td>yes&#x2F;no</td><td>当数据存储至本地数据库时是否要压缩数据，默认为 yes。</td></tr><tr><td>dbfilename</td><td>dump.rdb</td><td>指定本地存储数据库的文件名，默认为 dump.rdb。</td></tr><tr><td>dir</td><td>.&#x2F;</td><td>指定本地数据库存放目录。</td></tr><tr><td>slaveof</td><td>主从复制配置选项</td><td>当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动与 master 主机进行数据同步。</td></tr><tr><td>requirepass</td><td>foobared 默认关闭</td><td>密码配置项，默认关闭，用于设置 Redis 连接密码。如果配置了连接密码，客户端连接 Redis 时需要通过 密码认证。</td></tr><tr><td>maxmemory</td><td>最大内存限制配置项</td><td>指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会尝试清除已到期或即将到期的 Key，当此方法处理 后，若仍然到达最大内存设置，将无法再进行写入操作，但可以进行读取操作。</td></tr><tr><td>appendfilename</td><td>appendonly.aof</td><td>指定 AOF 持久化时保存数据的文件名，默认为 appendonly.aof。</td></tr><tr><td>glueoutputbuf</td><td>yes</td><td>设置向客户端应答时，是否把较小的包合并为一个包发送，默认开启状态。</td></tr></tbody></table><h1 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h1><h2 id="5-1-无法连接到远程redis服务器"><a href="#5-1-无法连接到远程redis服务器" class="headerlink" title="5.1 无法连接到远程redis服务器"></a>5.1 无法连接到远程redis服务器</h2><p><strong>①：检查是否ping通（略）</strong></p><p><strong>②：查看端口是否打开</strong></p><p>参考：<a href="https://blog-21n.pages.dev/2023/05/23/%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/">开放端口</a></p><p>一般到第②步就成功了，如果不行就继续往下</p><p><strong>③：关闭防火墙</strong></p><p>检查防火墙状态（是否 <code>dead</code> 状态）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status iptables<br>systemctl status firewalld<br></code></pre></td></tr></table></figure><p>关闭防火墙两种方式：</p><p>iptables 形式防火墙关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service iptables stop<br>chkconfig iptables off # 永久关闭<br></code></pre></td></tr></table></figure><p>firewalld 形式防火墙关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop firewalld &amp;&amp; systemctl disable firewalld <br>chkconfig firewalld off # 永久关闭<br></code></pre></td></tr></table></figure><p><strong>④：修改</strong><code>**redis.conf**</code><strong>配置文件</strong></p><p>（参考<a href="https://www.cnblogs.com/gara/p/9524014.html">网上</a>，在第③步还搞不定的情况下）</p><h2 id="5-2-因虚拟机IP地址改变无法启动"><a href="#5-2-因虚拟机IP地址改变无法启动" class="headerlink" title="5.2 因虚拟机IP地址改变无法启动"></a>5.2 因虚拟机IP地址改变无法启动</h2><p><strong>IP 变化的原因</strong></p><ul><li>DHCP 分配 IP 地址后，有一个租用时长，默认两小时，到了租用时长，ip 就会过期，主机会重新申请 ip 地址，这样地址就变了。</li></ul><p><strong>解决方法一：修改 ip 租用时长</strong></p><p>编辑 - 虚拟网络编辑器 - 更改设置 - 选择带NAT模式的网络（比如我的VMnet8）- DHCP设置</p><p>把默认和最长租用时间调大。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/DHCP%E8%AE%BE%E7%BD%AE.png" alt="DHCP设置"></p><p><strong>解决方法二：固定 ip 地址</strong></p><ol><li><strong>VMware查看虚拟机网络配置</strong></li></ol><p>编辑 - 虚拟网络编辑器 - 更改设置 - 选择带NAT模式的网络（比如我的VMnet8）</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="虚拟网络编辑器"></p><p>查看网关 IP：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BD%91%E5%85%B3IP.png" alt="网关IP"></p><p>查看 IP 范围：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/IP%E8%8C%83%E5%9B%B4.png" alt="IP范围"></p><p>获取到 IP 地址范围、网关地址、子网掩码后，就可以到虚拟机系统操作了。</p><ol><li><strong>修改网卡配置</strong></li></ol><p>启动虚拟机系统（本例使用 CentOS7 系统），在终端输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p>注：ens33 为网卡名称，<code>ifconfig</code>命令可以查看。</p><p>工作模式设置为<code>&quot;static&quot;</code>（即将 ip 分配协议改为静态分配），再依次添加规定范围内的固定 ip 地址、子网掩码、网关地址配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">BOOTPROTO=&quot;static&quot;<br>IPADDR=192.168.75.129<br>GATEWAY=192.168.75.2<br>NETMASK=255.255.255.0<br>DNS1=8.8.8.8<br></code></pre></td></tr></table></figure><p>修改后如下图：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE.png" alt="网卡配置"></p><ol><li><strong>重启网卡</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">systemctl restart network<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github + hexo 搭建博客过程</title>
    <link href="/2022/12/26/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/12/26/Github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h3><ul><li><p>Node.js（LTS长期支持版）：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><ul><li>安装后包含两个组件：node 和 npm（包管理器）</li></ul></li><li><p>git</p></li></ul><h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><h3 id="1-3-安装国内镜像源-cnpm"><a href="#1-3-安装国内镜像源-cnpm" class="headerlink" title="1.3 安装国内镜像源 cnpm"></a>1.3 安装国内镜像源 cnpm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org # -g：global 全局安装 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证，查看版本号</span> <br>cnpm -v<br></code></pre></td></tr></table></figure><h3 id="1-4-安装-hexo-框架"><a href="#1-4-安装-hexo-框架" class="headerlink" title="1.4 安装 hexo 框架"></a>1.4 安装 hexo 框架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g hexo-cli # -g：全局安装<br></code></pre></td></tr></table></figure><h2 id="二、博客-初始化与启动"><a href="#二、博客-初始化与启动" class="headerlink" title="二、博客 初始化与启动"></a>二、博客 初始化与启动</h2><h3 id="2-1-hexo-init-初始化博客"><a href="#2-1-hexo-init-初始化博客" class="headerlink" title="2.1 hexo init 初始化博客"></a>2.1 hexo init 初始化博客</h3><ol><li>新建一个存放博客资源的目录 blog</li><li>进入上述的 blog 目录，使用初始化命令：<code>hexo init</code></li></ol><p>初始化后，目录中生成了以下文件：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/blog_dir.png" alt="blog_dir"></p><h3 id="2-2-hexo-s-启动博客"><a href="#2-2-hexo-s-启动博客" class="headerlink" title="2.2 hexo s 启动博客"></a>2.2 hexo s 启动博客</h3><p>使用启动命令 <code>hexo s</code> 或者 <code>hexo server</code> 启动并预览博客。</p><p>启动后在本地的<code>4000</code>端口访问：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">D:\blog&gt;hexo s<br><span class="hljs-keyword">INFO</span> Validating config<br><span class="hljs-keyword">INFO</span> <span class="hljs-keyword">Start</span> processing<br><span class="hljs-keyword">INFO</span> Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span>/. Press Ctr1+C <span class="hljs-keyword">to</span> stop.<br></code></pre></td></tr></table></figure><h2 id="三、博客-新建与发布"><a href="#三、博客-新建与发布" class="headerlink" title="三、博客 新建与发布"></a>三、博客 新建与发布</h2><h3 id="3-1-hexo-n-新建博文"><a href="#3-1-hexo-n-新建博文" class="headerlink" title="3.1 hexo n 新建博文"></a>3.1 hexo n 新建博文</h3><p>使用 <code>hexo n</code> 或 <code>hexo new</code> 新建一篇博客文章：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&#x27;neo-first-blog&#x27;</span><br></code></pre></td></tr></table></figure><p>可见，在<code>\blog\source\_posts\</code>目录下生成了一个 <code>.markdown</code> 格式的文件。</p><p>然后就可以通过编辑该<code>.md</code>文件编辑博客内容。</p><h3 id="3-2-hexo-clean-清除缓存"><a href="#3-2-hexo-clean-清除缓存" class="headerlink" title="3.2 hexo clean 清除缓存"></a>3.2 hexo clean 清除缓存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件<code>db.json</code>和已生成的静态文件<code>public</code>。</p><p>网站显示异常时可以执行这条命令试试。</p><h3 id="3-3-hexo-g-生成"><a href="#3-3-hexo-g-生成" class="headerlink" title="3.3 hexo g 生成"></a>3.3 hexo g 生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g # generate<br></code></pre></td></tr></table></figure><p>生成网站静态文件到默认设置的<code>public</code>文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令。</li></ul><h2 id="四、部署到远端仓库"><a href="#四、部署到远端仓库" class="headerlink" title="四、部署到远端仓库"></a>四、部署到远端仓库</h2><h3 id="4-1-新建仓库"><a href="#4-1-新建仓库" class="headerlink" title="4.1 新建仓库"></a>4.1 新建仓库</h3><p>仓库名必须遵循指定格式：<code>owner.github.io</code>，如：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/repo.png" alt="repo"></p><h3 id="4-2-安装git部署插件"><a href="#4-2-安装git部署插件" class="headerlink" title="4.2 安装git部署插件"></a>4.2 安装git部署插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="4-3-添加配置"><a href="#4-3-添加配置" class="headerlink" title="4.3 添加配置"></a>4.3 添加配置</h3><p>打开本地<code>/blog/_config.yml</code>配置文件，在底部添加配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Deployment</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span><br>deploy:<br>  type: git<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">你的仓库地址</span><br>  repo: git@github.com:boxpiggy/boxpiggy.github.io.git<br>  branch: main<br></code></pre></td></tr></table></figure><h3 id="4-4-部署到远程仓库"><a href="#4-4-部署到远程仓库" class="headerlink" title="4.4 部署到远程仓库"></a>4.4 部署到远程仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d  # deploy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>hexo clean     # 清除缓存<br>hexo generate  # 生成静态文件<br>hexo deploy    # 部署到Github<br></code></pre></td></tr></table></figure><p>自动生成网站静态文件，并部署到设定的仓库。</p><p>需要输入目标仓库的用户名（boxpiggy）和密码（***）</p><p>据说部署前要先配置git全局用户：git config –global user.name “xxx”; git config –global user.email</p><p>每次修改完配置都要保存，然后hexo clean &amp; </p><h2 id="五、自定义主题与插件"><a href="#五、自定义主题与插件" class="headerlink" title="五、自定义主题与插件"></a>五、自定义主题与插件</h2><p>Hexo具有很强的自定义能力，可以打开 Hexo的官网，顶栏上就有 Themes 和 Plugins 的入口。</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>首先需要去 Themes 页面找到一款心仪的主题（可以通过点击图片来访问主题的演示站点），然后点击主题的名称进入主题的 GitHub 页面。</p><p>可以通过<code>git clone</code>命令将其克隆至博客根目录下的<code>themes</code>文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">git clone https:<span class="hljs-comment">//github.com/&lt;username&gt;/&lt;reponame&gt;</span><br></code></pre></td></tr></table></figure><p>或者通过 GitHub 自带的下载，下载源码的<code>zip</code>包，将其解压缩至<code>themes</code>文件夹中。</p><p>详细安装流程查看主题的<code>README.MD</code></p><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><p>每个主题文件夹中，都有着自己的<code>_config.yml</code>，管理着这个主题的一些配置，因此如果想要切换主题，在下载下来后，一定要到文件夹中去查看<code>_config.yml</code>的配置，并进行自己的个性化修改。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>本人使用了 Fluid 主题，<a href="https://hexo.fluid-dev.com/docs/guide/">官方文档</a>。</p><p><strong>安装</strong>（hexo 5.0.0 以上版本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p><strong>指定主题：</strong>修改 _config.yml 站点配置文件中的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">theme: fluid<br></code></pre></td></tr></table></figure><p>清除缓存并本地预览：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hexo c &amp; hexo s<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/fluid.png" alt="fluid"></p><p>图片位于：<code>node_modules\hexo-theme-fluid\source\img\</code>目录下</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>而如果是插件，那么就与主题的安装大不相同了。先找到需要的插件，然后再进入到插件的 GitHub 页面，一般在 <code>README.md</code> 中都会详细介绍如何安装。</p><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="①-hexo部署到gitee后无样式问题"><a href="#①-hexo部署到gitee后无样式问题" class="headerlink" title="① hexo部署到gitee后无样式问题"></a>① hexo部署到gitee后无样式问题</h3><details class="lake-collapse"><summary id="u4ba7e748"><span class="ne-text">参考</span></summary><p id="u08f876ee" class="ne-p" style="margin: 0; padding: 0; min-height: 24px"><span class="ne-text" style="font-size: 14px"></span><a href="https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank" data-href="https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank" target="_blank" class="ne-link"><span class="ne-text">https://lin_daren.gitee.io/lindada-blog/2020/06/13/%E5%AE%8C%E7%BE%8E%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E5%90%8E%E6%A0%B7%E5%BC%8Fbug/?_blank</span></a></p></details><ol><li>修改 <code>_config.yml</code> 配置，添加 <code>url</code> 和 <code>root</code> 两个配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, ......</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://boxpiggy.gitee.io/kingshit</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/kingshit/</span><br></code></pre></td></tr></table></figure><p><code>url</code> 为 Gitee Pages 上的网址</p><p><code>root </code> 为”仓库名”</p><ol start="2"><li>最后更新 Gitee Pages</li></ol><hr><p><strong>参考教程</strong></p><p><a href="https://www.cnblogs.com/visugar/p/6821777.html">https://www.cnblogs.com/visugar/p/6821777.html</a></p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p><p><a href="https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg">https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg</a></p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&vd_source=8a4e439fa8e8c5283477bc164e9a7126">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=8a4e439fa8e8c5283477bc164e9a7126</a></p><p><a href="https://sspai.com/post/59337">https://sspai.com/post/59337</a></p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven安装配置</title>
    <link href="/2022/11/08/Maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/08/Maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Maven核心程序解压与配置"><a href="#一、Maven核心程序解压与配置" class="headerlink" title="一、Maven核心程序解压与配置"></a>一、Maven核心程序解压与配置</h1><h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><p>Maven官网下载：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/maven%E4%B8%8B%E8%BD%BD.png" alt="maven下载"></p><h2 id="2-解压Maven核心程序"><a href="#2-解压Maven核心程序" class="headerlink" title="2. 解压Maven核心程序"></a>2. 解压Maven核心程序</h2><p>核心程序压缩包：<code>apache-maven-3.8.6-bin.zip</code>，解压到非中文目录</p><p>在解压目录中，Maven 核心配置文件：<code>conf / settings.xml</code></p><h2 id="3-指定本地仓库"><a href="#3-指定本地仓库" class="headerlink" title="3. 指定本地仓库"></a>3. 指定本地仓库</h2><p>本地仓库默认值：<code>用户home目录/.m2/repository</code>。（将来仓库中 jar 包越来越多，仓库体积增大，建议不要放在C盘）</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/maven%E6%8C%87%E5%AE%9A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="maven指定本地仓库"></p><h2 id="4-配置镜像仓库（阿里云提供）"><a href="#4-配置镜像仓库（阿里云提供）" class="headerlink" title="4. 配置镜像仓库（阿里云提供）"></a>4. 配置镜像仓库（阿里云提供）</h2><p>Maven 下载 jar 包默认访问境外的中央仓库，速度慢，因此需要改成阿里云提供的镜像仓库。</p><p>配置方式：将<code>&lt;mirror&gt;</code>标签整体复制到核心配置文件 <code>settings.xml</code> 的<code>&lt;mirrors&gt;</code>标签内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">  &lt;mirrorOf&gt;可以设置为哪个中央仓库做镜像，Maven默认中央仓库的id为central </span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">    也有人说新版仓库地址是 https://maven.aliyun.com/repository/public</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-配置-Maven-工程的基础-JDK-版本"><a href="#5-配置-Maven-工程的基础-JDK-版本" class="headerlink" title="5. 配置 Maven 工程的基础 JDK 版本"></a>5. 配置 Maven 工程的基础 JDK 版本</h2><p>如果按照默认配置运行，java工程使用的默认 JDK 版本是1.5，我们可以改成熟悉的 JDK1.8。</p><p>配置方式：将<code>&lt;profile&gt;</code>标签复制到核心配置文件 <code>settings.xml</code> 的<code>&lt;profiles&gt;</code>标签内部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="二、配置环境变量"><a href="#二、配置环境变量" class="headerlink" title="二、配置环境变量"></a>二、配置环境变量</h1><h2 id="1-检查-JAVA-HOME-配置是否正确"><a href="#1-检查-JAVA-HOME-配置是否正确" class="headerlink" title="1. 检查 JAVA_HOME 配置是否正确"></a>1. 检查 JAVA_HOME 配置是否正确</h2><p>Maven 是一个用 Java 语言开发的程序，必须基于 JDK 来运行，需要通过 JAVA_HOME 来找到 JDK 的安装位置。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="jdk环境变量"></p><h2 id="2-配置-MAVEN-HOME"><a href="#2-配置-MAVEN-HOME" class="headerlink" title="2. 配置 MAVEN_HOME"></a>2. 配置 MAVEN_HOME</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/MAVEN_HOME%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="MAVEN_HOME环境变量"></p><p>配置环境变量的规律：</p><ul><li>XXX_HOME 通常指向的是 bin 目录的上一级</li><li>PATH 指向的是 bin 目录</li></ul><h2 id="3-配置-PATH"><a href="#3-配置-PATH" class="headerlink" title="3. 配置 PATH"></a>3. 配置 PATH</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%8A%A0%E5%85%A5%E5%88%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="加入到环境变量"></p><h2 id="4-验证"><a href="#4-验证" class="headerlink" title="4. 验证"></a>4. 验证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn -v<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>开发效率</category>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL操作数据库</title>
    <link href="/2022/10/11/MySQL%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/10/11/MySQL%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h1><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h2><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt; CHARACTER SET &lt;字符集名&gt; COLLATE &lt;校对规则名&gt;;<br></code></pre></td></tr></table></figure><p>其中，<code>[ ]</code>内容表示可选。</p><ul><li><p><strong>IF NOT EXISTS</strong>：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。【此选项可以用来避免数据库已经存在而重复创建的错误。】</p></li><li><p>**&lt;数据库名&gt;**：创建数据库的名称。【数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。】</p></li><li><p><strong>[DEFAULT] CHARACTER SET</strong>：指定数据库采用的字符集，默认utf8</p></li><li><p><strong>[DEFAULT] COLLATE</strong>：指定数据库字符集的校对规则</p></li><li><ul><li>utf8_bin 区分大小写</li><li>utf8_general_ci 不区分大小写（默认）</li><li>…</li></ul></li></ul><blockquote><p>【字符集】是用来定义 MySQL 存储字符串的方式，【校对规则】定义了比较字符串的方式。</p></blockquote><blockquote><p>在创建数据库&#x2F;表的时候，为了规避关键字，可以使用反引号（<code>），且使用反引号命名更符合规范。如：</code>CREATE DATABASE <code>database</code>;&#96;</p></blockquote><h2 id="2-查看数据库的定义信息"><a href="#2-查看数据库的定义信息" class="headerlink" title="2. 查看数据库的定义信息"></a>2. 查看数据库的定义信息</h2><p>可以使用<code>SHOW CREATE DATABASE</code>查看 db01 数据库的定义声明，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">CREATE DATABASE IF NOT EXISTS `db01` CHARACTER SET utf8 COLLATE utf8_bin;</span><br>Query OK, 1 row affected (0.00 sec)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SHOW CREATE DATABASE db01;</span><br>+----------+--------------------------------------------------------------------------------+<br>| Database | Create Database                                                                |<br>+----------+--------------------------------------------------------------------------------+<br>| db01     | CREATE DATABASE `db01` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_bin */ |<br>+----------+--------------------------------------------------------------------------------+<br>1 row in set (0.03 sec)<br></code></pre></td></tr></table></figure><p>发现该数据库的指定字符集为 utf8，校对规则为utf8_bin。</p><blockquote><p>如果 MySQL 的版本 ≥ 5.5.3，可以把编码设置为 utf8mb4，utf8mb4 和 utf8 完全兼容，但它支持最新的 Unicode 标准，可以显示 emoji 字符。😀</p></blockquote><h2 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3. 删除数据库"></a>3. 删除数据库</h2><p>慎用！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">DROP DATABASE [IF EXISTS] db_name;<br></code></pre></td></tr></table></figure><h2 id="4-备份-x2F-恢复数据库"><a href="#4-备份-x2F-恢复数据库" class="headerlink" title="4. 备份 &#x2F; 恢复数据库"></a>4. 备份 &#x2F; 恢复数据库</h2><p>备份数据库（在 DOS 执行）：<code>mysqldump</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n &gt; 路径\\文件名.sql<br></code></pre></td></tr></table></figure><p>恢复数据库（在 mysql 命令行执行）：<code>source</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-built_in">source</span> 路径\\文件名.sql;</span><br></code></pre></td></tr></table></figure><p>备份数据库表：<code>mysqldump</code>（不要<code>-B</code>参数）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -u 用户名 -p 数据库名 表1 表2 表n &gt; 路径\\文件名.sql<br></code></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1-1-数值类型"><a href="#1-1-数值类型" class="headerlink" title="1.1 数值类型"></a>1.1 数值类型</h2><p>可选参数：<code>[UNSIGNED]</code>（无符号）， <code>[ZEROFILL]</code>（补零）</p><table>    <tr>        <td colspan="2">类型名称</td>        <td>字节</td>        <td>类型名称</td>        <td>存储需求（无符号）</td>        <td>有符号</td>        <td>说明</td>    </tr>    <tr>        <td rowspan="5" colspan="2">整型</td>        <td>1</td>        <td>tinyint</td>        <td>0-2^8-1（255）</td>        <td>-2^7~2^7-1</td>        <td></td>    </tr>    <tr>        <td>2</td>        <td>smallint</td>        <td>0-2^16-1（65535）</td>        <td>-2^15~2^15-1</td>        <td></td>    </tr>    <tr>        <td>3</td>        <td>mediumint</td>        <td>0-2^24-1（16777215）</td>        <td></td>        <td></td>    </tr>    <tr>        <td>4</td>        <td>int</td>        <td>0-2^32-1</td>        <td></td>        <td></td>    </tr>    <tr>        <td>8</td>        <td>bigint</td>        <td>0-2^64-1</td>        <td></td>        <td></td>    </tr>    <tr>        <td rowspan="3">小数</td>        <td rowspan="2">浮点型</td>        <td></td>        <td>float [(M,D)]</td>        <td>单精度 4个字节</td>        <td></td>        <td>- M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度（精度）和小数位数（标度）；<br>- M 和 D 在 FLOAT 和DOUBLE 中是可选的；<br>- 浮点型不指定精度，默认会按照实际的精度（由计算机硬件和操作系统决定）</td>    </tr>    <tr>        <td></td>        <td>double [(M,D)]</td>        <td>双精度 8个字节</td>        <td></td>        <td></td>    </tr>    <tr>        <td>定点型</td>        <td></td>        <td>decimal [(M,D)]</td>        <td>变长，取决于M和D，参见下面讨论</td>        <td></td>        <td>- M：精度，表示有效数字数的总数；<br>- D：标度，表示小数点后的位数；<br>- 要求：M（1~65），D（0~30），D&lt;=M；<br>- D省略默认是0，M省略默认是10，即默认(10,0)；<br>- 常用于货币数据等高精度数据。</td>    </tr>    <tr>        <td colspan="2">位字段类型</td>        <td></td>        <td>BIT(M)</td>        <td>大约(M+7)/8个字节</td>        <td></td>        <td></td>    </tr></table><p>UNSIGNED</p><p>默认为有符号，如果指定<code>unsigned</code>关键字，则代表无符号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CREATE TABLE t1 (id TINYINT UNSIGNED);<br></code></pre></td></tr></table></figure><h3 id="定点类型-DECIMAL-详解"><a href="#定点类型-DECIMAL-详解" class="headerlink" title="定点类型 DECIMAL 详解"></a>定点类型 DECIMAL 详解</h3><p><strong>DECIMAL(M,D) 解释示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">amount DECIMAL(6,2);<br></code></pre></td></tr></table></figure><p>表示<code>amount</code>列最多可以存储<code>6</code>位数字，小数位数为<code>2</code>位; 因此，<code>amount</code>列的范围是从<code>-9999.99</code>到<code>9999.99</code>。</p><p><strong>DECIMAL默认值：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">CREATE TABLE t3 (d1 DECIMAL);</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">desc t3;</span><br>+-------+---------------+------+-----+---------+-------+<br>| Field | Type          | Null | Key | Default | Extra |<br>+-------+---------------+------+-----+---------+-------+<br>| d1    | decimal(10,0) | YES  |     | NULL    |       |<br>+-------+---------------+------+-----+---------+-------+<br></code></pre></td></tr></table></figure><p><strong>DECIMAL存储需求</strong></p><p>DECIMAL（和 NUMERIC）的存储需求与具体版本有关（<a href="https://www.mysqlzh.com/doc/110.html%EF%BC%89">https://www.mysqlzh.com/doc/110.html）</a></p><p>（<a href="https://juejin.cn/post/6952527628616073230%EF%BC%89">https://juejin.cn/post/6952527628616073230）</a></p><ul><li><p>使用二进制格式将<font color="red">9</font>个十进制(基于10)数压缩为<font color="red">4</font>个字节，来表示 DECIMAL 列值。</p></li><li><p>每个值的整数和分数部分的存储分别确定。</p></li><li><p>每个9位数的倍数需要4个字节，并且“剩余的”位需要4个字节的一部分。下表给出了超出位数的存储需求：</p><table><thead><tr><th>组中包含的十进制位数</th><th>占用存储空间大小（单位：字节）</th></tr></thead><tbody><tr><td>1或2</td><td>1</td></tr><tr><td>3或4</td><td>2</td></tr><tr><td>5或6</td><td>3</td></tr><tr><td>7或8或9</td><td>4</td></tr></tbody></table></li></ul><blockquote><p>提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</p></blockquote><p><strong>BIT</strong></p><ul><li>BIT(M)。M指定位数，默认值1，范围1~64；</li><li>BIT(M)字段按 位的方式（二进制）显示；</li><li>查询使用 添加的数值。</li></ul><h2 id="1-2-字符串类型"><a href="#1-2-字符串类型" class="headerlink" title="1.2 字符串类型"></a>1.2 字符串类型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th><th>存储需求</th><th>详细说明</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字符数，0&lt;&#x3D;M&lt;&#x3D;255</td><td>0-2^8-1（255）</td><td>查询速度：char &gt; varchar</td></tr><tr><td>VARCHAR(M)</td><td>变长非二进制字符串</td><td>L+1字节，在此，L&lt; &#x3D; M且 0&lt;&#x3D;M&lt;&#x3D;255</td><td>0-2^16-1（65535）</td><td>实际占用空间：实际数据大小 + 1<del>3个字节。（本身需要占用1</del>3个字节记录存放内容长度）VARCHAR列的有效最大长度为65,532字符。</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td><td></td><td></td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td><td></td><td></td></tr><tr><td>TINYBLOB</td><td></td><td>L+1字节，在此，L&lt;2^8</td><td></td><td></td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td><td>0-2^8-1</td><td></td></tr><tr><td>BLOB</td><td>小的二进制字符串(字节字符串)</td><td>L+2字节，在此，L&lt;2^16</td><td></td><td>不能有默认值</td></tr><tr><td>TEXT</td><td>小的非二进制字符串（字符字符串）</td><td>L+2字节，在此，L&lt;2^16</td><td>0-2^16-1</td><td>如果varchar不够用，可以使用texttext不能有默认值</td></tr><tr><td>MEDIUMBLOB</td><td></td><td>L+3字节，在此，L&lt;2^24</td><td></td><td></td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td><td>0-2^24-1</td><td></td></tr><tr><td>LONGBLOB</td><td></td><td>L+4字节，在此，L&lt;2^32</td><td></td><td></td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td><td>0-2^32-1</td><td></td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td><td></td><td></td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td><td></td><td></td></tr></tbody></table><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ul><li>char(m)、varchar(m)：m表示字符数，不管是中文还是字母都是按m计算，都以定义好的表的编码来存放。</li><li>要想计算用于保存具体CHAR、VARCHAR或者TEXT列值的字节数，需要考虑该列使用的字符集。</li><li>VARCHAR、BLOB和TEXT类是变长类型。每个类型的存储需求取决于列值的实际长度(用前面的表中的L表示)，而不是该类型的最大可能的大小。例如，VARCHAR(10)列可以容纳最大长度为10的字符串。实际存储需求是字符串(L)的长度，加上一个记录字符串长度的字节。对于字符串’abcd’，L是4，存储需要5个字节。</li><li>NDBCLUSTER引擎只支持固定宽度的列。这说明MySQL簇中的表中的VARCHAR列的行为如同类型CHAR(不同的是每个记录仍然有一个额外字节空间)。例如，在Cluster表中，声明为VARCHAR(100)的列中的每个记录存储时将占用101个字节，无论实际存储的记录中的字符串的长度为多少。</li><li>BLOB和TEXT类需要 1、2、3或者4个字节来记录列值的长度，取决于该类的最大可能的长度。参见<a href="https://www.mysqlzh.com/doc/109/269.html">11.4.3节，“BLOB和TEXT类型”</a>。</li><li>在NDB Cluster存储引擎中，TEXT和BLOB列的实施是不同的，其中TEXT列中的每个记录由两个单独部分组成。一个是固定大小(256字节)，并且实际上保存在原表中。另一个包括超出256字节的任何数据，保存在隐含的表中。第2个表中的记录总是2,000字节长。这说明如果size&lt;&#x3D; 256，TEXT列的大小为256(其中size表示记录的大小)；否则，大小是256 +size+(2000–(size–256)%2000)。</li><li>ENUM对象的大小由不同的枚举值的数目确定。枚举用一个字节，可以有255个可能的值。当枚举的值位于256和65,535之间时，用两个字节。见<a href="https://www.mysqlzh.com/doc/109/270.html">11.4.4节，“ENUM类型”</a>。</li><li>SET对象的大小由不同的set成员数量确定。如果set大小是N，对象占(N+7)&#x2F;8个字节，四舍五入到1、2、3、4或者8个字节。SET最多可以有64个成员。见<a href="https://www.mysqlzh.com/doc/109/271.html">11.4.5节，“SET类型”</a>。</li></ul><h2 id="1-4-日期时间类型"><a href="#1-4-日期时间类型" class="headerlink" title="1.4 日期时间类型"></a>1.4 日期时间类型</h2><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T3 (<br>  birthday <span class="hljs-type">DATE</span>,<br>  job_time DATETIME,<br>  login_time <span class="hljs-type">TIMESTAMP</span><br>    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <br>    <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>  <span class="hljs-comment">-- 可以为【初始值】使用当前的时间戳</span><br>    <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>);  <span class="hljs-comment">-- 可以为【自动更新的值】使用当前的时间戳，TIMESTAMP在INSERT和UPDATE时，自动更新。</span><br></code></pre></td></tr></table></figure><p>在<code>CREATE TABLE</code>语句中，可以使用下列语句声明第1个<code>TIMESTAMP</code>列：</p><ul><li>用<code>DEFAULT CURRENT_TIMESTAMP</code>和<code>ON UPDATE CURRENT_TIMESTAMP</code>子句，列为<strong>默认值使用当前的时间戳，并且自动更新</strong>。</li><li>不用<code>DEFAULT</code>子句但用<code>ON UPDATE CURRENT_TIMESTAMP</code>子句，列有默认值0并自动更新。</li><li>……</li></ul><p><strong>MAXDB 模式</strong></p><p>当服务器以<code>MAXDB</code>模式运行时，<code>TIMESTAMP</code>与<code>DATETIME</code>相等。也就是说，如果创建表时服务器以<code>MAXDB</code>模式运行，<code>TIMESTAMP</code>列创建为<code>DATETIME</code>列。结果是，该列使用<code>DATETIME</code>显示格式，有相同的值范围，并且没有自动对当前的日期和时间进行初始化或更新。</p><p>要想启用<code>MAXDB</code>模式，在启动服务器时使用<code>--sql-mode=MAXDB</code>服务器选项或在运行时通过设置全局<code>sql_mode</code>变量将SQL服务器模式设置为<code>MAXDB</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SET GLOBAL sql_mode=MAXDB；</span><br></code></pre></td></tr></table></figure><p>客户端可以按照下面方法让服务器为它的连接以MAXDB模式运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SET SESSION sql_mode=MAXDB;</span><br></code></pre></td></tr></table></figure><h1 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h1><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1 创建表"></a>1 创建表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">CREATE TABLE table_name (<br>    field1 datatype,<br>    field2 datatype,<br>    field3 datatype<br>) CHARACTER SET 字符集 COLLATE 校对规则 ENGINE 存储引擎<br></code></pre></td></tr></table></figure><p><code>field</code>：指定列名（字段名）  <code>datatype</code>：指定列类型（字段类型）</p><p><code>character set</code>：缺省为所在数据库字符集</p><p><code>collate</code>：缺省为所在数据库校对规则</p><p><code>engine</code>：引擎</p><p><strong>字段设置</strong></p><ol><li><p><code>NOT NULL</code>：把字段设置为 “不允许为空”。</p></li><li><p><code>DEFAULT &#39;value&#39;</code>：为字段设置默认值。</p></li><li><p><code>AUTO_INCREMENT</code>：把字段设置为自增。</p></li><li><ol><li>自增主键的分配，是由InnoDB数据字典内部一个计数器来决定的，而该计数器只在内存中维护，并不会持久化到磁盘中。当数据库重启时，该计数器会通过这种方式初始化：<code>SELECT MAX(ai_col) FROM table_name FOR UPDATE;</code>（来源：<a href="https://www.jianshu.com/p/68b2cae7e5ed%EF%BC%89">https://www.jianshu.com/p/68b2cae7e5ed）</a></li><li>若中途删除表中记录使自增id断层，可通过<code>ALTER TABLE 表名 AUTO_INCREMENT=n;</code>把自增id重置为指定的值，重新开始计数。</li></ol></li><li><p><code>PRIMARY KEY ( </code>字段名<code> )</code>：把字段设置为主键。</p></li></ol><h2 id="2-修改表"><a href="#2-修改表" class="headerlink" title="2 修改表"></a>2 修改表</h2><p>使用<code>ALTER TABLE</code>语句追加(<code>ADD</code>)、修改（<code>MODIFY</code>）、删除（<code>DROP</code>）列，修改字符集（<code>CHARSET</code> &#x2F; <code>CHARACTER SET</code>），修改列名（<code>CHANGE</code>）</p><p>修改表名：<code>RENAME TABLE 表名 TO 新表名</code>，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 在`resume`列后增加`image`列，设置不允许为空，默认值为空<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br>    <span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] image <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> AFTER resume;  <span class="hljs-comment">-- [COLUMN]可省略</span><br><br># 把`image`列类型长度修改为<span class="hljs-number">60</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br>    MODIFY [<span class="hljs-keyword">COLUMN</span>] image <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">60</span>);<br><br># 删除`image`列<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br>    <span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] image;<br>    <br># 修改表`emp`字符集为utf8mb4<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> employee <br>    CHARSET utf8mb4;<br>    <br># 修改表`emp`名为`employee`<br>RENAME <span class="hljs-keyword">TABLE</span> emp <span class="hljs-keyword">TO</span> employee;<br><br># 列名`name`修改为`user_name`<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> employee<br>    CHANGE `name` `user_name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="3-查看表"><a href="#3-查看表" class="headerlink" title="3 查看表"></a>3 查看表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESC</span> table_name;<br></code></pre></td></tr></table></figure><h2 id="4-删除表"><a href="#4-删除表" class="headerlink" title="4 删除表"></a>4 删除表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> table_name;<br></code></pre></td></tr></table></figure><h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><p>示例：创建一个商品表goods，添加id、goods_name、price字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `goods` (<br>    id <span class="hljs-type">INT</span>,<br>    goods_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br>    price <span class="hljs-keyword">DOUBLE</span>);<br></code></pre></td></tr></table></figure><h2 id="INSERT（增加）"><a href="#INSERT（增加）" class="headerlink" title="INSERT（增加）"></a>INSERT（增加）</h2><p>基本语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, …) VALUES (值1, 值2, …);</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> [IGNORE] <span class="hljs-keyword">INTO</span> `goods` (id, goods_name, price)  <span class="hljs-comment">-- [IGNORE]表示如果记录已经存在，就啥事也不干直接忽略</span><br>    <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;iphone13 pro max&#x27;</span>, <span class="hljs-number">9000</span>);<br></code></pre></td></tr></table></figure><p>注意事项</p><ol><li>插入的数据值<strong>类型</strong>、<strong>长度</strong>和<strong>顺序</strong>要满足字段的要求，且需要一一对应；</li><li>列可以插入空值，前提是该字段允许为空，<code>INSERT INTO 表名 (列名1, 列名2, 列名3) VALUE(数据1, 数据2, null);</code>：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `goods`(id, goods_name, price) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">110</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><ol><li>添加多条记录：<code>INSERT INTO 表名 (列名1, 列名2, ...) VALUES (), (), ()...;</code>：</li><li>如果是给表中所有字段添加数据，可以省略(字段名)：<code>INSERT INTO 表名 VALUES(数据1, 数据2, 数据3);</code>：</li><li>默认值，当没有给某个字段赋值，如果该字段有默认值则自动赋默认值，如果该字段没有指定默认值，且没有指定not null，则默认赋null；</li></ol><blockquote><p>另外，自增主键也可以在INSERT中省略</p></blockquote><ol><li>避免插入重复数据的方法（前提条件：插入的数据字段设置了主键或唯一索引）</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL安装配置</title>
    <link href="/2022/10/10/MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/10/10/MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h1><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/%EF%BC%88MySQL">https://dev.mysql.com/downloads/mysql/（MySQL</a> Community Server）</p><p>下载、解压到任意盘</p><h1 id="二、添加环境变量"><a href="#二、添加环境变量" class="headerlink" title="二、添加环境变量"></a>二、添加环境变量</h1><p>设置环境变量（添加bin目录的路径到path）</p><h1 id="三、新建配置文件（5-7版本）"><a href="#三、新建配置文件（5-7版本）" class="headerlink" title="三、新建配置文件（5.7版本）"></a>三、新建配置文件（5.7版本）</h1><p>在安装目录（E:\MySQL\mysql-5.7.19-winx64\）下创建<code>my.ini</code>文件，进行以下配置（还有很多配置参数可自定义）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">[client]<br># 客户端默认端口号为3306 (在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server)<br>port=3306<br><br># 客户端使用字符集默认为utf-8<br>default-character-set=utf8<br><br>[mysqld]<br># 设置为自己MySQL的安装目录<br>basedir=E:\MySQL\mysql-5.7.19-winx64\<br><br># 设置为MySQL数据库的数据存放目录<br>datadir=E:\MySQL\mysql-5.7.19-winx64\data\<br><br># 设置端口号<br>port=3306<br><br># 运行最大连接数<br># max_connections=200<br><br># 运行连接失败的次数。这也是为了防止有人从该主机试图攻击数据库系统<br># max_connect_errors=10<br><br># 服务端使用的字符集默认为utf-8<br>character_set_server=utf8<br><br># 跳过安全检查（跳过验证密码，注销后，需要输入正确的用户名和密码）<br># skip-grant-tables<br></code></pre></td></tr></table></figure><h1 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h1><p>使用管理员身份打开cmd，并切换到<code>bin</code>目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqld -install<br></code></pre></td></tr></table></figure><h1 id="五、初始化"><a href="#五、初始化" class="headerlink" title="五、初始化"></a>五、初始化</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqld --initialize-insecure --user=mysql<br></code></pre></td></tr></table></figure><p>如果执行成功，会生成 data 目录。</p><p><strong>常见失败</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%A2%AB%E8%BD%AC%E4%B9%89.png" alt="被转义"></p><p>由于<code>my.ini</code>配置文件的路径中，含有<code>\t</code>、<code>\s</code>等转义字符，如上例中的<code>&quot;D:\soft\...&quot;</code>，因此需要使用<code>&quot;/&quot;</code>或<code>&quot;\\&quot;</code>替代。</p><h1 id="六、启动服务"><a href="#六、启动服务" class="headerlink" title="六、启动服务"></a>六、启动服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 mysql 服务</span><br>net start mysql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止 mysql 服务</span><br>net stop mysql<br></code></pre></td></tr></table></figure><h1 id="七、进入MySQL管理终端"><a href="#七、进入MySQL管理终端" class="headerlink" title="七、进入MySQL管理终端"></a>七、进入MySQL管理终端</h1><p>（不需要输入密码）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u root -p<br></code></pre></td></tr></table></figure><p>格式为：<code>mysql -h 主机ip -P 端口号 -u 用户名 -p</code></p><p>只要是服务就会监听一个端口</p><p>如果是 mysql 所在的本机，且用默认的端口3306，直接输入：<code>mysql -u root -p</code></p><blockquote><p>MySQL Client 的可执行程序是 mysql，MySQL Server 的可执行程序是 mysqld，在后台运行。</p></blockquote><h1 id="八、修改root用户密码"><a href="#八、修改root用户密码" class="headerlink" title="八、修改root用户密码"></a>八、修改root用户密码</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>用<code>UPDATE</code>直接编辑 user 表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">use mysql;<br>update user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host=&#x27;localhost&#x27;;  # 提示语法错误<br>flush privileges;  # 刷新权限<br></code></pre></td></tr></table></figure><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>用<code>SET PASSWORD</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set password for 用户名@localhost = password(‘新密码’);<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set password for root@localhost = password(&#x27;123456&#x27;);  # 提示语法错误<br></code></pre></td></tr></table></figure><h2 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h2><p>利用 mysqladmin，我们不需要先登录，但是需要知道原来的密码；我们可以直接修改。</p><p>修改密码格式为：<code>mysqladmin -u用户名 -p旧密码 password 新密码</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqladmin -uroot -p123456 password 123<br></code></pre></td></tr></table></figure><h2 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure><h1 id="九、退出MySQL管理终端"><a href="#九、退出MySQL管理终端" class="headerlink" title="九、退出MySQL管理终端"></a>九、退出MySQL管理终端</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">quit <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span> <br>exit<br></code></pre></td></tr></table></figure><h1 id="十、删除MySQL"><a href="#十、删除MySQL" class="headerlink" title="十、删除MySQL"></a>十、删除MySQL</h1><p>删除已经安装好的 MySQL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sc delete mysql<br></code></pre></td></tr></table></figure><h1 id="十一、常见错误"><a href="#十一、常见错误" class="headerlink" title="十一、常见错误"></a>十一、常见错误</h1><h2 id="①-启动-mysql-发生错误"><a href="#①-启动-mysql-发生错误" class="headerlink" title="① 启动 mysql 发生错误"></a>① 启动 mysql 发生错误</h2><p>若启动 mysql 服务出现  【发生系统错误 2。系统找不到指定的文件。】的错误，则可通过修改注册表【HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL】的ImagePath 的路径，（MySQL解压位置的bin目录下的mysqld.exe），如：”E:\MySQL\mysql-8.0.25-winx64\bin\mysqld”</p><h2 id="②-远程主机无法连接数据库服务器"><a href="#②-远程主机无法连接数据库服务器" class="headerlink" title="② 远程主机无法连接数据库服务器"></a>② 远程主机无法连接数据库服务器</h2><p>本人在 192.168.2.25 服务器安装配置好了 mysql，然后使用本人主机远程连接失败：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="客户端无法连接数据库"></p><p><strong>处理流程：</strong></p><ol><li>连接服务器: mysql -u root -p</li><li>看当前所有数据库：show databases;</li><li>进入 mysql 数据库：use mysql;</li><li>查看 mysql 数据库中所有的表：show tables;</li><li>查看 user 表中的数据：select Host, User, authentication_string from user;</li><li>修改 user 表中的 Host：update user set Host&#x3D;’%’ where User&#x3D;’root’;</li><li>最后刷新一下：flush privileges;</li></ol><p><strong>主要步骤：</strong></p><p>修改 mysql 数据库中的 user 表中的 root 用户的主机名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">select `Host`, `User` from user;<br>update user set Host=&#x27;%&#x27; where User=&#x27;root&#x27;;<br></code></pre></td></tr></table></figure><p>如果在 Navicate 中登录的用户名不是 <code>localhost</code> 就都会被 <code>not allowed</code>，可以将 Host 改为通配符<code>%</code>：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E9%80%9A%E9%85%8D%E7%AC%A6.png" alt="通配符"></p><p>刷新后连接成功。</p><hr><p>其他参考</p><p>旧版安装，很详细：<a href="https://www.bilibili.com/video/BV18x411H7qD?p=10&vd_source=8a4e439fa8e8c5283477bc164e9a7126">https://www.bilibili.com/video/BV18x411H7qD?p=10&amp;vd_source=8a4e439fa8e8c5283477bc164e9a7126</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux查看系统配置</title>
    <link href="/2022/09/15/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/09/15/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="lscpu"><a href="#lscpu" class="headerlink" title="lscpu"></a><code>lscpu</code></h2><p>显示cpu架构信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">[xxx@localhost ~]$ lscpu<br>Architecture:          x86_64             <span class="hljs-comment"># 架构</span><br>CPU op-mode(s):        32-bit, 64-bit<br>Byte Order:            Little Endian<br>CPU(s):                48　　　　　　　　　 <span class="hljs-comment"># 总处理器核心数量</span><br>On-line CPU(s) list:   0-47<br>Thread(s) per core:    2　　　　　　　　　　<span class="hljs-comment"># 每个核心支持的线程数量。1表示只支持一个线程，即不支持超线程</span><br>Core(s) per socket:    12　　　　　　　　　 <span class="hljs-comment"># 每个 插槽（处理器/物理cpu）的核心数量</span><br>Socket(s):             2　　　　　　　　　　<span class="hljs-comment"># 座/插槽：处理器数量</span><br>NUMA node(s):          2<br>Vendor ID:             GenuineIntel<br>CPU family:            6<br>Model:                 85                  <span class="hljs-comment"># 型号</span><br>Model name:            Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz<br>Stepping:              7                   <span class="hljs-comment"># 步进</span><br>CPU MHz:               999.963<br>CPU max MHz:           3200.0000<br>CPU min MHz:           1000.0000<br>BogoMIPS:              4400.00 <br>Virtualization <span class="hljs-built_in">type</span>:   VT-x                <span class="hljs-comment"># cpu支持的虚拟化技术</span><br>L1d cache:             32K                 <span class="hljs-comment"># 一级缓存（具体表示cpu的L1数据缓存）</span><br>L1i cache:             32K                 <span class="hljs-comment"># 一级缓存（具体为L1指令缓存）</span><br>L2 cache:              1024K<br>L3 cache:              16896K<br>NUMA node0 CPU：    0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46<br>NUMA node1 CPU：    1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47<br><br>[xxx@localhost ~]$ man lscpu<br>   COLUMNS<br>       CPU    The logical CPU number of a CPU as used by the Linux kernel.　　　　 <span class="hljs-comment"># 逻辑CPU数量</span><br>       CORE   The logical core number. A core can contain several CPUs.　　　　　　<span class="hljs-comment"># 逻辑核心数量</span><br>       SOCKET The logical socket number. A socket can contain several cores.　　　 <span class="hljs-comment"># 逻辑插槽（路）数量</span><br></code></pre></td></tr></table></figure><p>对操作系统来说，逻辑 CPU 的数量 &#x3D; Socket * Core * Thread。</p><p>举例来说，如果某个服务器“2 路 4 核 超线程”，也就是 2 个插槽，4 核心，默认为 2 thread，即 2<em>4</em>2 是 16 逻辑 CPU。</p><ul><li>Socket 具体是指的主板上 CPU 的插槽数量，一般笔记本只有一个，而服务器可能会有多个。如果有两个插槽，通常称为两路；</li><li>Core 具体是指 CPU 的核心，也就是平常说的几核，比如八核之类；</li><li>thread 是指的每个 Core 的硬件线程数，超线程</li></ul><h2 id="cat-proc-cpuinfo"><a href="#cat-proc-cpuinfo" class="headerlink" title="cat /proc/cpuinfo"></a><code>cat /proc/cpuinfo</code></h2><p>查看 CPU 详细信息（内容过多，使用管道符以及grep命令过滤）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看物理CPU个数</span><br><span class="hljs-built_in">cat</span> /proc/cpuinfo | grep <span class="hljs-string">&quot;physical id&quot;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span><br><br><span class="hljs-comment"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="hljs-built_in">cat</span> /proc/cpuinfo | grep <span class="hljs-string">&quot;cpu cores&quot;</span> | <span class="hljs-built_in">uniq</span><br><br><span class="hljs-comment"># 查看每个物理CPU中线程的个数</span><br><span class="hljs-built_in">cat</span> /proc/cpuinfo | grep <span class="hljs-string">&quot;siblings&quot;</span> | <span class="hljs-built_in">uniq</span><br><br><span class="hljs-comment"># 查看逻辑CPU的个数</span><br><span class="hljs-built_in">cat</span> /proc/cpuinfo| grep <span class="hljs-string">&quot;processor&quot;</span><br><br><span class="hljs-comment"># 查看CPU型号</span><br><span class="hljs-built_in">cat</span> /proc/cpuinfo | grep <span class="hljs-string">&quot;model name&quot;</span> | <span class="hljs-built_in">uniq</span><br><br><span class="hljs-comment"># grep 命令用于查找文件里符合条件的字符串</span><br><span class="hljs-comment"># uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用</span><br></code></pre></td></tr></table></figure><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>查看<code>**/proc/meminfo**</code>或者使用<code>**free**</code>命令。<code>free</code>命令就是从<code>meminfo</code>中获取的信息。</p><h1 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h1><h2 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h2><p>blk 是 block 的缩写。列出块设备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[xxx@localhost ~]$ lsblk<br>NAME                        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sr0                          11:0    1 1024M  0 rom  <br>sdb                           8:16   0  100G  0 disk <br>└─sdb1                        8:17   0  100G  0 part /data<br>sda                           8:0    0   60G  0 disk <br>├─sda1                        8:1    0  500M  0 part /boot<br>└─sda2                        8:2    0 59.5G  0 part <br>  ├─VolGroup-lv_root (dm-0) 253:0    0   50G  0 lvm  /<br>  ├─VolGroup-lv_swap (dm-1) 253:1    0    4G  0 lvm  [SWAP]<br>  └─VolGroup-lv_home (dm-2) 253:2    0  5.6G  0 lvm  /home<br></code></pre></td></tr></table></figure><p>其中，<code>TYPE=disk</code>表示硬盘。可以看出，硬盘分为 sda 和 sdb，一共 160G。</p><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>查看硬盘使用情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[xxx@localhost ~]$ <span class="hljs-built_in">df</span> -h<br>Filesystem                    Size  Used Avail Use% Mounted on<br>/dev/mapper/VolGroup-lv_root   50G  1.7G   46G   4% /<br>tmpfs                         3.9G     0  3.9G   0% /dev/shm<br>/dev/sda1                     485M   39M  421M   9% /boot<br>/dev/mapper/VolGroup-lv_home  5.5G  165M  5.1G   4% /home<br>/dev/sdb1                      99G  188M   94G   1% /data<br></code></pre></td></tr></table></figure><h1 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># lspci | grep -i &#x27;eth&#x27;  # 未找到命令</span><br>02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 06)<br></code></pre></td></tr></table></figure><p>查看系统的所有网络接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># ifconfig -a</span><br>eth0      Link encap:以太网  硬件地址 b8:97:5a:17:b3:8f  <br>          .....<br>lo        Link encap:本地环回  <br>          .....<br></code></pre></td></tr></table></figure><p>如果要查看某个网络接口的详细信息，例如 eth0 的详细参数和指标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># ethtool eth0</span><br>Settings <span class="hljs-keyword">for</span> eth0:<br>    Supported ports: [ TP MII ]<br>    Supported <span class="hljs-built_in">link</span> modes:   10baseT/Half 10baseT/Full <br>                            100baseT/Half 100baseT/Full <br>                            1000baseT/Half 1000baseT/Full <span class="hljs-comment">#支持千兆半双工，全双工模式</span><br>    Supported pause frame use: No <br>    Supports auto-negotiation: Yes <span class="hljs-comment">#支持自适应模式，一般都支持</span><br>    Advertised <span class="hljs-built_in">link</span> modes:  10baseT/Half 10baseT/Full <br>                            100baseT/Half 100baseT/Full <br>                            1000baseT/Half 1000baseT/Full<br>    Advertised pause frame use: Symmetric Receive-only<br>    Advertised auto-negotiation: Yes <span class="hljs-comment">#默认使用自适应模式</span><br>    Link partner advertised <span class="hljs-built_in">link</span> modes:  10baseT/Half 10baseT/Full <br>                                         100baseT/Half 100baseT/Full <br>    .....<br>    Speed: 100Mb/s <span class="hljs-comment">#现在网卡的速度是100Mb,网卡使用自适应模式，所以推测路由是100Mb，导致网卡从支持千兆，变成要支持百兆</span><br>    Duplex: Full   <span class="hljs-comment">#全双工</span><br>    .....<br>    Link detected: <span class="hljs-built_in">yes</span>    <span class="hljs-comment">#表示有网线连接，和路由是通的</span><br></code></pre></td></tr></table></figure><h1 id="查看Linux内核版本命令（2种方法）"><a href="#查看Linux内核版本命令（2种方法）" class="headerlink" title="查看Linux内核版本命令（2种方法）"></a>查看Linux内核版本命令（2种方法）</h1><p><a href="https://www.cnblogs.com/still-smile/p/11597620.html">Linux内核版本介绍与查询 - Smah - 博客园</a></p><h2 id="cat-x2F-proc-x2F-version"><a href="#cat-x2F-proc-x2F-version" class="headerlink" title="cat &#x2F;proc&#x2F;version"></a>cat &#x2F;proc&#x2F;version</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cat /proc/version</span><br>Linux localhost.localdomain 3.10.0-1160.el7.x86_64 <span class="hljs-comment">#1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></code></pre></td></tr></table></figure><p>major.minor.patch-build.desc：3.10.0-1160.el7</p><p>major : 主版本号，有结构变化才变更 </p><p>minor : 次版本号，新增功能时才发生变化，一般技术表示测试版，偶数表示生产版 </p><p>patch : 补丁包数或次版本的修改次数 </p><p>build : 编译（或构建）的次数，每次编译可能对少量程序做优化或修改，但一般没有大的（可控的）功能变化。</p><p>desc  : 当前版本的特殊信息，其信息由编译时指定，具有较大的随意性，有如下的标识是常用的： </p><p>​    rc（或r），表示发行候选版本（release candidate），rc后的数字表示该正式版本的第几个候选版本，多数情况下，各候选版本之间数字越大越接近正式版。</p><p>​    smp，表示对称多处理器（Symmetric MultiProcessing）。</p><p>​    pp，在Red Hat Linux中常用来表示测试版本（pre-patch）。</p><p>​    EL，在Red Hat Linux中用来表示企业版Linux（Enterprise Linux）。</p><p>​    mm，表示专门用来测试新的技术或新功能的版本。</p><p>​    fc，在Red Hat Linux中表示Fedora Core。  </p><h2 id="uname-a"><a href="#uname-a" class="headerlink" title="uname -a"></a>uname -a</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># uname -a</span><br>Linux version 3.10.0-1160.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) <span class="hljs-comment">#1 SMP Mon Oct 19 16:18:59 UTC 2020</span><br></code></pre></td></tr></table></figure><h1 id="查看Linux系统版本的命令（3种方法）"><a href="#查看Linux系统版本的命令（3种方法）" class="headerlink" title="查看Linux系统版本的命令（3种方法）"></a>查看Linux系统版本的命令（3种方法）</h1><h2 id="lsb-release-a，"><a href="#lsb-release-a，" class="headerlink" title="lsb_release -a，"></a>lsb_release -a，</h2><p>列出所有版本信息：</p><p>未找到命令……</p><h2 id="cat-x2F-etc-x2F-redhat-release"><a href="#cat-x2F-etc-x2F-redhat-release" class="headerlink" title="cat &#x2F;etc&#x2F;redhat-release"></a>cat &#x2F;etc&#x2F;redhat-release</h2><p>这种方法只适合 Redhat 系的 Linux</p><h2 id="cat-x2F-etc-x2F-issue"><a href="#cat-x2F-etc-x2F-issue" class="headerlink" title="cat &#x2F;etc&#x2F;issue"></a>cat &#x2F;etc&#x2F;issue</h2><p>此命令也适用于所有的 Linux 发行版。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="查看-pci-信息"><a href="#查看-pci-信息" class="headerlink" title="查看 pci 信息"></a>查看 pci 信息</h2><p>即主板所有硬件槽信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># lspci  # 未找到命令</span><br>00:00.0 Host bridge: Intel Corporation 2nd Generation Core Processor Family DRAM Controller (rev 09) <span class="hljs-comment">#主板芯片</span><br>00:02.0 VGA compatible controller: Intel Corporation 2nd Generation Core Processor Family Integrated Graphics Controller (rev 09) <span class="hljs-comment">#显卡</span><br>00:14.0 USB controller: Intel Corporation Panther Point USB xHCI Host Controller (rev 04) <span class="hljs-comment">#usb控制器</span><br>00:16.0 Communication controller: Intel Corporation Panther Point MEI Controller <span class="hljs-comment">#1 (rev 04)</span><br>00:1a.0 USB controller: Intel Corporation Panther Point USB Enhanced Host Controller <span class="hljs-comment">#2 (rev 04)</span><br>00:1b.0 Audio device: Intel Corporation Panther Point High Definition Audio Controller (rev 04) <span class="hljs-comment">#声卡</span><br>00:1c.0 PCI bridge: Intel Corporation Panther Point PCI Express Root Port 1 (rev c4) <span class="hljs-comment">#pci 插槽</span><br>00:1c.2 PCI bridge: Intel Corporation Panther Point PCI Express Root Port 3 (rev c4)<br>00:1c.3 PCI bridge: Intel Corporation Panther Point PCI Express Root Port 4 (rev c4)<br>00:1d.0 USB controller: Intel Corporation Panther Point USB Enhanced Host Controller <span class="hljs-comment">#1 (rev 04)</span><br>00:1f.0 ISA bridge: Intel Corporation Panther Point LPC Controller (rev 04)<br>00:1f.2 IDE interface: Intel Corporation Panther Point 4 port SATA Controller [IDE mode] (rev 04) <span class="hljs-comment">#硬盘接口</span><br>00:1f.3 SMBus: Intel Corporation Panther Point SMBus Controller (rev 04)<br>00:1f.5 IDE interface: Intel Corporation Panther Point 2 port SATA Controller [IDE mode] (rev 04) <span class="hljs-comment">#硬盘接口</span><br>02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 06) <span class="hljs-comment">#网卡</span><br>03:00.0 PCI bridge: Integrated Technology Express, Inc. Device 8893 (rev 41)<br></code></pre></td></tr></table></figure><h2 id="查看bios信息"><a href="#查看bios信息" class="headerlink" title="查看bios信息"></a>查看bios信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># dmidecode -t bios</span><br>......<br>BIOS Information<br>    Vendor: American Megatrends Inc.<br>    Version: 4.6.5<br>    Release Date: 04/25/2012<br>    .......<br>    BIOS Revision: 4.6<br>......<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>常用命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 序列化与反序列化</title>
    <link href="/2022/08/01/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/08/01/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化?"></a>什么是序列化和反序列化?</h1><ul><li>序列化：将数据结构或对象转换成二进制字节流（一个byte[]数组）的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>维基百科的介绍：</p><blockquote><p><strong>序列化（serialization）</strong>在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><h1 id="为什么需要序列化"><a href="#为什么需要序列化" class="headerlink" title="为什么需要序列化"></a>为什么需要序列化</h1><p>序列化后可以把二进制字节流<code>byte[]</code>保存到文件中，或者通过网络传输到远程。</p><p>总的来说，如果我们<strong>需要持久化 Java 对象</strong>比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，就要用到序列化。</p><p>同理，有了反序列化，保存到文件中或者从网络上读取的二进制字节流<code>byte[]</code>就可以转换回 Java 对象，读取到程序中进行处理。</p><p><strong>常见应用场景：</strong></p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><p>综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/20240827162203.png"></p><h1 id="序列化协议"><a href="#序列化协议" class="headerlink" title="序列化协议"></a>序列化协议</h1><p>序列化协议对应于 TCP&#x2F;IP 模型的哪一层？<strong>表示层</strong></p><blockquote><p>四层：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol></blockquote><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="OSI七层模型"></p><h2 id="常见序列化协议"><a href="#常见序列化协议" class="headerlink" title="常见序列化协议"></a>常见序列化协议</h2><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><h2 id="JDK-自带的序列化方式"><a href="#JDK-自带的序列化方式" class="headerlink" title="JDK 自带的序列化方式"></a>JDK 自带的序列化方式</h2><p>JDK 自带的序列化，只需实现<code>java.io.Serializable</code>接口即可。</p><blockquote><p><code>Serializable</code>接口属于“标记接口”，没有定义任何方法，它是一个空接口，仅仅是给自身贴了个“标记”。</p><p>一个Java对象要支持序列化机制，其类必须是可序列化的，该类必须实现一个特殊的 <code>java.io.Serializable</code>接口。（或者<code>Externalizable</code>接口，该接口继承了 <code>Serializable</code>，需要实现接口方法，不常用）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>serialVersionUID 有什么作用？</strong></p><p>序列化号<code>serialVersionUID</code>属于版本控制的作用。反序列化时，会检查<code>serialVersionUID</code>是否和当前类的<code>serialVersionUID</code>一致。如果<code>serialVersionUID</code>不一致则会抛出 <code>InvalidClassException</code>异常。强烈推荐每个序列化类都手动指定其<code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的<code>serialVersionUID</code>。</p><p><strong>不指定 serialVersionUID 会如何？</strong></p><p>如果没有指定，在序列化过程中，jvm 会自动计算出一个值作为<code>serialVersionUID</code>，由于这种运行时计算<code>serialVersionUID</code>的方式依赖于 jvm 的实现方式，如果序列化和反序列化的 jvm 实现方式不一样可能会导致抛出异常<code>InvalidClassException</code>，所以在使用原生序列化方式的时候<a href="https://docs.oracle.com/javase/6/docs/platform/serialization/spec/class.html#4100">官方</a>是强烈建议指定一个<code>serialVersionUID</code>的。</p><p><strong>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</strong></p><p>static 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，serialVersionUID 是一个特例，serialVersionUID 的序列化做了特殊处理。当一个对象被序列化时，serialVersionUID 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。</p><p>官方说明：</p><blockquote><p>A serializable class can declare its own serialVersionUID explicitly by declaring a field named “serialVersionUID” that must be static, final, and of type long;</p><p>如果想显式指定 serialVersionUID ，则需要在类中使用 static 和 final 关键字来修饰一个 long 类型的变量，变量名字必须为 “serialVersionUID” 。</p></blockquote><p>也就是说，<code>serialVersionUID</code>只是用来被 JVM 识别，实际并没有被序列化。</p><p><strong>如果有些字段不想进行序列化怎么办？</strong></p><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code>关键字的作用：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被<code>transient</code>修饰的变量值不会被持久化和恢复。</p><p><strong>注意细节：</strong></p><ul><li><code>transient</code>只能修饰变量，不能修饰类和方法。</li><li><code>transient</code>修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰<code>int</code>类型，那么反序列后结果就是 0。</li><li><code>static</code>变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li></ul><p><strong>为什么不推荐使用 JDK 自带的序列化？</strong></p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：<a href="https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/">应用安全:JAVA 反序列化漏洞之殇 - Cryin</a>、<a href="https://www.zhihu.com/question/37562657/answer/1916596031">Java 反序列化安全漏洞怎么回事? - Monica</a></li></ul><h2 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h2><p>Kryo 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p><p>GitHub 地址：<a href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a></p><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p><blockquote><p>Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto 文件，然后使用 IDL 编译器编译成你需要的语言。</p></blockquote><p>一个简单的 proto 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// protobuf的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span><br>message Person &#123;<br>  <span class="hljs-comment">//string类型字段</span><br>  <span class="hljs-type">string</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// int 类型字段</span><br>  <span class="hljs-type">int32</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>GitHub 地址：<a href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p><h2 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h2><p>由于 Protobuf 的易用性较差，它的哥哥 Protostuff 诞生了。</p><p>protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p><p>GitHub 地址：<a href="https://github.com/protostuff/protostuff">https://github.com/protostuff/protostuff</a></p><h2 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h2><p>Hessian 是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。</p><p>Dubbo2.x 默认启用的序列化方式是 Hessian2，但是，Dubbo 对 Hessian2 进行了修改，不过大体结构还是差不多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的<a href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/user/serialization/">一篇文章</a>中提到说推荐使用 Kryo 作为生产环境的序列化方式。</p><p>像 Protobuf、 ProtoStuff、hessian 这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p><p>除了上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p><hr><p>参考：</p><p><a href="https://javaguide.cn/java/basis/serialization.html">Java 序列化详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO流</title>
    <link href="/2022/08/01/Java-IO%E6%B5%81/"/>
    <url>/2022/08/01/Java-IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="IO-流简介"><a href="#IO-流简介" class="headerlink" title="IO 流简介"></a>IO 流简介</h1><p>IO 即 Input&#x2F;Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>例如，</p><ul><li>输入：把文件从磁盘读取到内存；网络读取数据到内存</li><li>输出：把数据从内存写入到文件；数据从内存输出到网络</li></ul><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>Java IO 流的 40 多个类都是从以下 4 个抽象类基类中派生出来的。</p><ul><li><p><code>InputStream</code> &#x2F; <code>OutputStream</code></p></li><li><ul><li>IO 流以<code>byte</code>（字节）为最小单位，因此有的地方也称为<strong>字节流</strong>。</li><li><code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流。</li></ul></li><li><p><code>Reader</code> &#x2F; <code>Writer</code></p></li><li><ul><li>Java 用<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</li><li>本质上是一个能自动编解码的<code>InputStream</code>和<code>OutputStream</code>。</li></ul></li></ul><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/IO%E6%B5%81%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="IO流继承关系"></p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="InputStream（字节输入流）"><a href="#InputStream（字节输入流）" class="headerlink" title="InputStream（字节输入流）"></a>InputStream（字节输入流）</h2><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p><p>InputStream 常用方法：</p><ul><li><code>read()</code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li><li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li><li><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li><li><code>available()</code>：返回输入流中可以读取的字节数。</li><li><code>close()</code>：关闭输入流释放相关的系统资源。</li></ul><p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p><ul><li><code>readAllBytes()</code>：读取输入流中的所有字节，返回字节数组。</li><li><code>readNBytes(byte[] b, int off, int len)</code>：阻塞直到读取 <code>len</code> 个字节。</li><li><code>transferTo(OutputStream out)</code>：将所有字节从一个输入流传递到一个输出流。</li></ul><p><strong>关于</strong><code>**close()**</code></p><p>在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</p><blockquote><p>A program has to do more than rely on the garbage collector (GC) to reclaim a resource’s memory when it’s finished with it. The program must also release the resoure back to the operating system, typically by calling the resource’s close method. However, if a program fails to do this before the GC reclaims the resource, then the information needed to release the resource is lost. The resource, which is still considered by the operaing system to be in use, has leaked.</p></blockquote><p><code>InputStream</code>和<code>OutputStream</code>都是通过<code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p><code>FileInputStream</code>是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Number of remaining bytes:&quot;</span><br>            + fis.available());<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fis.skip(<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>一般我们是不会直接单独使用<code>FileInputStream</code>,通常会配合<code>BufferedInputStream</code>（字节缓冲输入流，后文会讲到）来使用。</p><p>像下面这段代码在我们的项目中就比较常见，我们通过 readAllBytes() 读取输入流所有字节并将其直接赋值给一个 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br><span class="hljs-comment">// 读取文件的内容并复制到 String 对象中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufferedInputStream.readAllBytes());<br>System.out.println(result);<br></code></pre></td></tr></table></figure><h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p><code>ObjectInputStream</code>用于从输入流中读取 Java 对象(反序列化),<code>ObjectOutputStream</code>用于将对象写入到输出流(序列化)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br><span class="hljs-comment">// 读取文件的内容并复制到 String 对象中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bufferedInputStream.readAllBytes());<br>System.out.println(result);<br></code></pre></td></tr></table></figure><h3 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h3><p>用于读取指定类型数据，不能单独使用，必须结合其它流，比如 <code>FileInputStream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br><span class="hljs-comment">//必须将fileInputStream作为构造参数才能使用</span><br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dataInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(fileInputStream);<br><span class="hljs-comment">//可以读取任意具体的类型数据</span><br>dataInputStream.readBoolean();<br>dataInputStream.readInt();<br>dataInputStream.readUTF();<br></code></pre></td></tr></table></figure><h2 id="OutputStream（字节输出流）"><a href="#OutputStream（字节输出流）" class="headerlink" title="OutputStream（字节输出流）"></a>OutputStream（字节输出流）</h2><p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p><p><code>OutputStream</code> 常用方法：</p><ul><li><code>write(int b)</code>：将特定字节写入输出流。</li><li><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li><li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li><li><code>close()</code>：关闭输出流释放相关的系统资源。</li></ul><blockquote><p>向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。</p><p>通常情况下，我们不需要调用这个<code>flush()</code>方法，因为缓冲区写满了<code>OutputStream</code>会自动调用它，并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用       <code>flush()</code>方法。</p><p>但是，在某些情况下，我们必须手动调用<code>flush()</code>方法。举个栗子：</p><p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code>OutputStream</code>的<code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，这是为啥？</p><p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p><p>解决办法就是每输入一句话后，立刻调用<code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p></blockquote><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p><code>FileOutputStream</code>是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p><p>类似于 <code>FileInputStream</code>，<code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流，后文会讲到）来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// new FileOutputStream(filePath) 写入内容时，会覆盖原来的内容</span><br><span class="hljs-comment">// new FileOutputStream(filePath, true) 写入内容时，追加到原内容后面</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fileOutputStream)<br></code></pre></td></tr></table></figure><h3 id="ObjectInputStream-1"><a href="#ObjectInputStream-1" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p><code>ObjectInputStream</code>用于从输入流中读取 Java 对象（<code>ObjectInputStream</code>，反序列化），<code>ObjectOutputStream</code>将对象写入到输出流(<code>ObjectOutputStream</code>，序列化)。</p><h3 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h3><p><code>DataOutputStream</code> 用于写入指定类型数据，不能单独使用，必须结合其它流，比如       <code>FileOutputStream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出流</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;out.txt&quot;</span>);<br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dataOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(fileOutputStream);<br><span class="hljs-comment">// 输出任意数据类型</span><br>dataOutputStream.writeBoolean(<span class="hljs-literal">true</span>);<br>dataOutputStream.writeByte(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？</p><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li><li>如果我们不知道编码类型就很容易出现乱码问题。</li></ul><p>字符流默认采用的是 Unicode 编码，我们可以通过构造方法自定义编码。</p><p><code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节</p><h2 id="Reader（字符输入流）"><a href="#Reader（字符输入流）" class="headerlink" title="Reader（字符输入流）"></a>Reader（字符输入流）</h2><p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p><p><code>Reader</code>本质上是一个基于<code>InputStream</code>的<code>byte</code>到<code>char</code>的转换器。</p><p><code>**Reader**</code><strong>常用方法：</strong></p><ul><li><code>read()</code> : 从输入流读取一个字符，读取字符流的下一个字符，并返回字符表示的       <code>int</code>，范围是<code>0~65535</code>。如果已读到末尾，返回<code>-1</code>。</li><li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组             <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li><li><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数），返回读取的字符的个数，到达流的末尾则返回<code>-1</code>。</li><li><code>skip(long n)</code>：忽略输入流中的 n 个字符，返回实际忽略的字符数。</li><li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li></ul><p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节流转换为字符流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStreamReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于读取字符文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamReader</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>FileReader 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);) &#123;<br>    <span class="hljs-type">int</span> content;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">skip</span> <span class="hljs-operator">=</span> fileReader.skip(<span class="hljs-number">3</span>);<br>    System.out.println(<span class="hljs-string">&quot;The actual number of bytes skipped:&quot;</span> + skip);<br>    System.out.print(<span class="hljs-string">&quot;The content read from file:&quot;</span>);<br>    <span class="hljs-keyword">while</span> ((content = fileReader.read()) != -<span class="hljs-number">1</span>) &#123;<br>        System.out.print((<span class="hljs-type">char</span>) content);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br>input.txt<br>你好，我是Guide<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">The actual number of bytes skipped:3<br>The content read from file:我是Guide。<br></code></pre></td></tr></table></figure><h2 id="Writer（字符输出流）"><a href="#Writer（字符输出流）" class="headerlink" title="Writer（字符输出流）"></a>Writer（字符输出流）</h2><p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p><p><code>Writer</code>本质上是一个基于<code>OutputStream</code>的<code>char</code>到<code>byte</code>的转换器。</p><p><code>**Writer**</code> <strong>常用方法：</strong></p><ul><li><code>write(int c)</code> : 写入单个字符。</li><li><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li><li><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li><li><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li><li><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li><li><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</li><li><code>close()</code>:关闭输出流释放相关的系统资源。</li></ul><p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符流转换为字节流的桥梁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputStreamWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>&#125;<br><span class="hljs-comment">// 用于写入字符到文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OutputStreamWriter</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="节点流-amp-处理流-包装流"><a href="#节点流-amp-处理流-包装流" class="headerlink" title="节点流 &amp; 处理流(包装流)"></a>节点流 &amp; 处理流(包装流)</h1><p>直接使用继承，为各种<code>InputStream</code>附加更多的功能，根本无法控制代码的复杂度，很快就会失控。</p><p>为了解决依赖继承会导致子类数量失控的问题，以 <code>InputStream</code> 为例，JDK 首先将      <code>InputStream</code>分为两大类：</p><p>一类是直接提供数据的基础InputStream，例如：</p><ul><li>FileInputStream</li><li>ByteArrayInputStream</li><li>ServletInputStream</li><li>…</li></ul><p>一类是提供额外附加功能的InputStream，例如：</p><ul><li>BufferedInputStream</li><li>DigestInputStream</li><li>CipherInputStream</li><li>…</li></ul><h2 id="Filter模式-x2F-装饰器模式"><a href="#Filter模式-x2F-装饰器模式" class="headerlink" title="Filter模式&#x2F;装饰器模式"></a>Filter模式&#x2F;装饰器模式</h2><p>当我们需要给一个“基础”InputStream附加各种功能时，我们先确定这个能提供数据源的InputStream，因为我们需要的数据总得来自某个地方，例如，FileInputStream，数据来源自文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.gz&quot;</span>);<br></code></pre></td></tr></table></figure><p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用 <code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">buffered</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(file);<br></code></pre></td></tr></table></figure><p>最后，假设该文件已经用<code>gzip</code>压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">gzip</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GZIPInputStream</span>(buffered);<br></code></pre></td></tr></table></figure><p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/20240827160813.png"></p><p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为 <strong>Filter 模式（或者装饰器模式：Decorator）</strong>。<code>OutputStream</code>也一样。这样就可以让我们通过少量的类来实现各种功能的组合。</p><h2 id="节点流-amp-处理流-包装流-1"><a href="#节点流-amp-处理流-包装流-1" class="headerlink" title="节点流 &amp; 处理流(包装流)"></a>节点流 &amp; 处理流(包装流)</h2><p><strong>节点流：</strong>属于底层流，直接跟数据源相接，可以从一个特定的数据源读写数据。</p><p><strong>处理流（</strong>也叫<strong>包装流）：</strong>包装节点流，“连接”在已存在的流（节点流或处理流）之上，不会直接与数据源相连，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/IO%E6%B5%81%E5%88%86%E7%B1%BB.png" alt="IO流分类"></p><h1 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h1><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p><p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强                  <code>FileInputStream</code> 的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <br>        <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br></code></pre></td></tr></table></figure><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p><p>使用<code>write(int b)</code>和<code>read()</code>方法，分别通过字节流和字节缓冲流复制一个<code>524.9 mb</code> 的 PDF 文件耗时对比如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_buffer_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>));<br>         <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;<br>        <span class="hljs-type">int</span> content;<br>        <span class="hljs-keyword">while</span> ((content = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            bos.write(content);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copy_pdf_to_another_pdf_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 记录开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统.pdf&quot;</span>);<br>         <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> content;<br>        <span class="hljs-keyword">while</span> ((content = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>            fos.write(content);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 记录结束时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="hljs-string">&quot; 毫秒&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">使用缓冲流复制PDF文件总耗时:<span class="hljs-number">15428</span> 毫秒<br>使用普通字节流复制PDF文件总耗时:<span class="hljs-number">2555062</span> 毫秒<br></code></pre></td></tr></table></figure><p>可见，两者耗时差别非常大，缓冲流耗费的时间是字节流的 1&#x2F;165。</p><p>如果是调用 <code>read(byte b[])</code> 和 <code>write(byte b[], int off, int len)</code> 这两个写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</p><h2 id="BufferedInputStream（字节缓冲输入流）"><a href="#BufferedInputStream（字节缓冲输入流）" class="headerlink" title="BufferedInputStream（字节缓冲输入流）"></a>BufferedInputStream（字节缓冲输入流）</h2><p><code>BufferedInputStream</code>从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p><p>BufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>    <span class="hljs-comment">// 内部缓冲区数组</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">byte</span> buf[];<br>    <span class="hljs-comment">// 缓冲区的默认大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>;<br>    <span class="hljs-comment">// 使用默认的缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br>    <span class="hljs-comment">// 自定义缓冲区大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓冲区大小默认为<code>8192</code>字节，可以通过<code>BufferedInputStream(InputStream in, int size)</code>这个构造方法来指定缓冲区的大小。</p><h2 id="BufferedOutputStream（字节缓冲输出流）"><a href="#BufferedOutputStream（字节缓冲输出流）" class="headerlink" title="BufferedOutputStream（字节缓冲输出流）"></a>BufferedOutputStream（字节缓冲输出流）</h2><p><code>BufferedOutputStream</code>将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))) &#123;<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-string">&quot;JavaGuide&quot;</span>.getBytes();<br>    bos.write(array);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>类似于 <code>BufferedInputStream</code>，<code>BufferedOutputStream</code> 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <code>8192</code> 字节。</p><h1 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h1><p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader</span> &#123;<br>    <span class="hljs-comment">// Reader对象</span><br>    <span class="hljs-keyword">private</span> Reader in;<br>    <span class="hljs-comment">// 内部缓冲区数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> cb[];<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> nChars, nextChar;<br></code></pre></td></tr></table></figure><p><code>BufferedReader</code>类中，有属性<code>Reader</code>，即封装了一个字符输入流，该节点流可以是任意的<code>Reader</code>的子类。查看【图2 - IO流分类】可知，BufferedReader可以处理文件、数组、管道等多种数据源。</p><h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><p><code>PrintStream</code> 属于字节打印流，与之对应的是 <code>PrintWriter</code>（字符打印流）。          <code>PrintStream</code> 是 <code>OutputStream</code> 的子类，<code>PrintWriter</code> 是 <code>Writer</code> 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterOutputStream</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Appendable</span>, Closeable &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Writer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>PrintStream</code>最终输出的总是<code>byte</code>数据。</p><p>我们熟知的<code>System.out</code>实际是用于获取一个<code>PrintStream</code>对象，<code>print</code>方法实际调用的是<code>PrintStream</code>对象的 <code>write</code> 方法。</p><h1 id="随机访问流-RandomAccessFile"><a href="#随机访问流-RandomAccessFile" class="headerlink" title="随机访问流 RandomAccessFile"></a>随机访问流 RandomAccessFile</h1><p><code>RandomAccessFile</code> 支持随意跳转到文件的任意位置进行读写。</p><p>构造方法如下，我们可以指定 mode（读写模式）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file, String mode)</span><br>    <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-built_in">this</span>(file, mode, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">// 私有方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file, String mode, <span class="hljs-type">boolean</span> openAndDelete)</span>  <span class="hljs-keyword">throws</span> FileNotFoundException&#123;<br>  <span class="hljs-comment">// 省略大部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读写模式主要有下面四种：</p><ul><li><code>r</code> : 只读模式。</li><li><code>rw</code>: 读写模式</li><li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li><li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li></ul><p><strong>文件内容</strong>指的是文件中实际保存的数据，<strong>元数据</strong>则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p><h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><p><code>RandomAccessFile</code> 中有一个<strong>文件指针</strong>用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p><p><code>RandomAccessFile</code> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;input.txt&quot;</span>), <span class="hljs-string">&quot;rw&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br><span class="hljs-comment">// 指针当前偏移量为 6</span><br>randomAccessFile.seek(<span class="hljs-number">6</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br><span class="hljs-comment">// 从偏移量 7 的位置开始往后写入字节数据</span><br>randomAccessFile.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>&#125;);<br><span class="hljs-comment">// 指针当前偏移量为 0，回到起始位置</span><br>randomAccessFile.seek(<span class="hljs-number">0</span>);<br>System.out.println(<span class="hljs-string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="hljs-string">&quot;,当前读取到的字符&quot;</span> + (<span class="hljs-type">char</span>) randomAccessFile.read() + <span class="hljs-string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());<br>input.txt`文件内容：`ABCDEFG<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1<br>读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7<br>读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1<br></code></pre></td></tr></table></figure><p><code>input.txt</code> 文件内容变为 <code>ABCDEFGHIJK</code> 。</p><h2 id="数据覆盖"><a href="#数据覆盖" class="headerlink" title="数据覆盖"></a>数据覆盖</h2><p><code>RandomAccessFile</code> 的 <code>write</code> 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;input.txt&quot;</span>), <span class="hljs-string">&quot;rw&quot;</span>);<br>randomAccessFile.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure><p>假设运行上面这段程序之前<code>input.txt</code>文件内容变为<code>ABCD</code> ，运行之后则变为<code>HIJK</code> 。</p><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p><code>RandomAccessFile</code>比较常见的一个应用就是实现大文件的<strong>断点续传</strong>。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><p><code>RandomAccessFile</code> 可以帮助我们合并文件分片，示例代码如下：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/20240827161001.png"></p><p><code>RandomAccessFile</code> 的实现依赖于 <code>FileDescriptor</code> (文件描述符) 和 <code>FileChannel</code> （内存映射文件）。</p><h1 id="关于流的关闭"><a href="#关于流的关闭" class="headerlink" title="关于流的关闭"></a>关于流的关闭</h1><p>使用 Java7 的 <code>try-with-resources</code> 来关闭资源，只需要编写 <code>try()</code> 语句，就可以让编译器自动为我们关闭资源。</p><p>《Effective Java》中明确指出：</p><p>面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是 try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources 语句让我们更容易编写必须要关闭的资源的代码，若采用 try-finally 则几乎做不到这点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)));<br>     <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;out.txt&quot;</span>)))) &#123;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">while</span> ((b = bin.read()) != -<span class="hljs-number">1</span>) &#123;<br>        bout.write(b);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编译器只看</strong><code>**try(resource = ...)**</code><strong>中的对象是否实现了</strong><code>**java.lang.AutoCloseable**</code><strong>接口</strong>，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p><p><strong>关闭流只需要关闭最外层</strong></p><p>注意到在包装多个流对象的时候，只需要持有最外层，如<code>InputStream</code>，当最外层的     <code>InputStream</code>关闭时（在<code>try(resource)</code>块的结束处自动关闭），内层的<code>InputStream</code>的<code>close()</code>方法也会被自动调用，并最终调用到最核心的“基础”<code>InputStream</code>，因此不存在资源泄露。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间日期处理</title>
    <link href="/2022/07/05/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <url>/2022/07/05/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第三代日期类（JDK8）"><a href="#第三代日期类（JDK8）" class="headerlink" title="第三代日期类（JDK8）"></a>第三代日期类（JDK8）</h1><h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><p><code>LocalDateTime</code>：日期时间 &#x2F; 年月日时分秒（<code>LocalDate</code>：日期 &#x2F; 年月日、<code>LocalTime</code>：时间 &#x2F; 时分秒）</p><ul><li><p>表示本地日期和时间。</p></li><li><p>默认严格按照 ISO 8601 规定的日期和时间格式进行打印。</p></li><li><p>ISO 8601 规定的日期和时间分隔符是T。标准格式如下：</p></li><li><ul><li>日期：yyyy-MM-dd</li><li>时间：HH:mm:ss</li><li>带毫秒的时间：HH:mm:ss.SSS</li><li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li><li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li></ul></li><li><p>自定义格式打印需要使用<code>DateTimeFormatter</code>类。</p></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// now(): 获取当前时间</span><br>LocalDateTime.now()<br><br><span class="hljs-comment">// of(): 指定的日期和时间创建 LocalDateTime 实例</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dt2</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2019</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>);<br><br><span class="hljs-comment">// plusXxx(): 日期时间的加减（方法的参数都是long型，返回值都是LocalDateTime）</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">plusYearsResult</span> <span class="hljs-operator">=</span> localDateTime.plusYears(<span class="hljs-number">2L</span>);  <span class="hljs-comment">// 2025-10-30T09:51:26.062</span><br><br><span class="hljs-comment">// 时间 转 字符串</span><br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().format(formatter);  <span class="hljs-comment">// 2023-10-30 09:48:01</span><br><span class="hljs-comment">// 字符串 转 时间</span><br><span class="hljs-type">String</span> <span class="hljs-variable">dateTimeStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-10-30 09:48:11&quot;</span>;<br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> LocalDateTime.parse(dateTimeStr, dtf);  <span class="hljs-comment">// 2023-10-30T09:48:11</span><br><br><span class="hljs-comment">// toInstant 指定时区生成毫秒数（这里指定国际时间 UTC 0，实际上就是 System.currentTimeMillis() + 时区偏移毫秒数）</span><br>LocalDateTime.now().toInstant();<br><span class="hljs-comment">// toEpochSecond(): 获取秒数  .toEpochMilli(): 获取毫秒数</span><br><span class="hljs-type">Long</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.of(<span class="hljs-string">&quot;+8&quot;</span>));  <span class="hljs-comment">// 1698630422</span><br></code></pre></td></tr></table></figure><h2 id="格式日期类（DateTimeFormatter）"><a href="#格式日期类（DateTimeFormatter）" class="headerlink" title="格式日期类（DateTimeFormatter）"></a>格式日期类（DateTimeFormatter）</h2><p>格式化类型，取代了<code>SimpleDateFormat</code>。</p><p><strong>示例一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//-----------------------------------------------创建对象---------------------------------------------//</span><br><span class="hljs-comment">// now()方法：获取本地日期时间，总是以当前默认时区返回</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now();  <span class="hljs-comment">//LocalDate.now()  LocalTime.now()</span><br>System.out.println(ldt);  <span class="hljs-comment">//2022-07-05T19:22:21.955</span><br><br><span class="hljs-comment">/// of()方法：指定日期和时间创建对象:</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2017</span>, <span class="hljs-number">1</span>, <span class="hljs-number">29</span>); <span class="hljs-comment">// 2017-1-29</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>); <span class="hljs-comment">// 15:16:17</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dt2</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2017</span>, <span class="hljs-number">1</span>, <span class="hljs-number">29</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>);  <br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dt3</span> <span class="hljs-operator">=</span> LocalDateTime.of(d2, t2);<br>System.out.println(dt2);  <span class="hljs-comment">// 2017-01-29T15:16:17</span><br><br><span class="hljs-comment">// 获取指定属性（年月日时分秒）</span><br>System.out.println(<span class="hljs-string">&quot;年：&quot;</span> + ldt.getYear());  <span class="hljs-comment">// 年：2022</span><br>System.out.println(<span class="hljs-string">&quot;月：&quot;</span> + ldt.getMonthValue());  <span class="hljs-comment">// 月：7  （getMonth()：JULY）</span><br><br><span class="hljs-comment">// 使用DateTimeFormatter格式化日期时间</span><br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);  <span class="hljs-comment">// 创建DateTimeFormatter对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> dtf.format(ldt);<br>System.out.println(<span class="hljs-string">&quot;格式化后：&quot;</span> + format);  <span class="hljs-comment">//格式化后：2022年07月05日 19小时22分钟21秒</span><br><br><span class="hljs-comment">// plusDays(n)：获取n天后的日期时间（其他属性同理）</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> ldt.plusDays(<span class="hljs-number">180</span>);  <span class="hljs-comment">// 180天后，是什么时候</span><br>System.out.println(<span class="hljs-string">&quot;180天后的现在 = &quot;</span> + dtf.format(localDateTime));  <span class="hljs-comment">// 180天后的现在 = 2023年01月01日 19小时19分钟14秒</span><br><br><span class="hljs-comment">//minusMinutes(n)：获取n分钟前的日期时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime1</span> <span class="hljs-operator">=</span> ldt.minusMinutes(<span class="hljs-number">3456</span>);  <span class="hljs-comment">// 3456分钟前是什么时候</span><br>System.out.println(<span class="hljs-string">&quot;3456分钟前是 = &quot;</span> + dtf.format(localDateTime1));  <span class="hljs-comment">// 3456分钟前是 = 2022年07月03日 09小时46分钟21秒</span><br></code></pre></td></tr></table></figure><h2 id="时区（ZoneDateTime）"><a href="#时区（ZoneDateTime）" class="headerlink" title="时区（ZoneDateTime）"></a>时区（ZoneDateTime）</h2><p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p><p>可以简单地把<code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。<code>ZoneId</code>是<code>java.time</code>引入的新的时区类。</p><p><strong>创建ZoneDateTime对象的两种方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. now()方法创建ZonedDateTime对象</span><br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zbj</span> <span class="hljs-operator">=</span> ZonedDateTime.now(); <span class="hljs-comment">// 默认时区</span><br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zny</span> <span class="hljs-operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>)); <span class="hljs-comment">// 用指定时区获取当前时间</span><br>System.out.println(zbj);  <span class="hljs-comment">// 2022-07-05T20:06:24.139+08:00[Asia/Shanghai]</span><br>System.out.println(zny);  <span class="hljs-comment">// 2022-07-05T08:06:24.141-04:00[America/New_York]</span><br><br><span class="hljs-comment">//2. 通过LocalDateTime -&gt; ZonedDateTime (给一个LocalDateTime对象附加一个ZoneId)</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2019</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>);<br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zbj2</span> <span class="hljs-operator">=</span> ldt.atZone(ZoneId.systemDefault());<br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zny2</span> <span class="hljs-operator">=</span> ldt.atZone(ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>));<br>System.out.println(zbj2);  <span class="hljs-comment">//2019-09-15T15:16:17+08:00[Asia/Shanghai]</span><br>System.out.println(zny2);  <span class="hljs-comment">//2019-09-15T15:16:17-04:00[America/New_York]</span><br></code></pre></td></tr></table></figure><h2 id="时间、日期差（Duration-和-Period）"><a href="#时间、日期差（Duration-和-Period）" class="headerlink" title="时间、日期差（Duration 和 Period）"></a>时间、日期差（Duration 和 Period）</h2><p><code>Duration</code>表示两个时刻之间的时间间隔。<code>Period</code>表示两个日期之间的天数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2020</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">19</span>, <span class="hljs-number">48</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">48</span>, <span class="hljs-number">30</span>);<br><span class="hljs-type">Duration</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Duration.between(start, end);<br>System.out.println(d); <span class="hljs-comment">// PT16872H30S</span><br><br><span class="hljs-type">Period</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2020</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>).until(LocalDate.of(<span class="hljs-number">2022</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>));<br>System.out.println(p); <span class="hljs-comment">// P1Y11M4D</span><br></code></pre></td></tr></table></figure><p>代码解释：两个<code>LocalDateTime</code>之间的差值使用<code>Duration</code>表示，<code>PT16872H30S</code>表示16872小时30秒。而两个<code>LocalDate</code>之间的差值用<code>Period</code>表示，<code>P1Y11M4D</code>表示1年11个月4天。</p><p><code>Duration</code>和<code>Period</code>的表示方法也符合ISO 8601的格式，它以<code>P...T...</code>的形式表示。</p><h2 id="时间戳（Instant）"><a href="#时间戳（Instant）" class="headerlink" title="时间戳（Instant）"></a>时间戳（Instant）</h2><p>Java提供的<code>System.currentTimeMillis()</code>返回的就是以毫秒(long类型)表示的当前时间戳。</p><p>这个当前时间戳在<code>java.time</code>中以<code>Instant</code>类型表示，我们用<code>Instant.now()</code>获取当前时间戳，效果和<code>System.currentTimeMillis()</code>类似</p><p>实际上，Instant内部只有两个核心字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> seconds;  <span class="hljs-comment">// 以秒为单位的时间戳</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> nanos;  <span class="hljs-comment">//更精确的纳秒精度</span><br></code></pre></td></tr></table></figure><p>Instant是时间戳，那么，给它附加上一个时区，就可以创建出ZonedDateTime：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Instant</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> Instant.ofEpochSecond(<span class="hljs-number">1568568760</span>);  <span class="hljs-comment">// 以指定时间戳创建Instant:</span><br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zdt</span> <span class="hljs-operator">=</span> ins.atZone(ZoneId.systemDefault());<br>System.out.println(zdt);  <span class="hljs-comment">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure><p>可见，对于某一个时间戳，给它关联上指定的<code>ZoneId</code>，就得到了<code>ZonedDateTime</code>，继而可以获得了对应时区的<code>LocalDateTime</code>。</p><p><code>LocalDateTime</code>，<code>ZoneId</code>，<code>Instant</code>，<code>ZonedDateTime</code>和<code>long</code>都可以互相转换：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/LocalDateTime&ZoneId&ZonedDateTime.png" alt="LocalDateTime&amp;ZoneId&amp;ZonedDateTime"></p><h1 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h1><h2 id="Calendar类（JDK1-1引入）"><a href="#Calendar类（JDK1-1引入）" class="headerlink" title="Calendar类（JDK1.1引入）"></a>Calendar类（JDK1.1引入）</h2><p>1）是一个抽象类，并且构造器是<code>private</code></p><p>2）可以通过<code>getInstance()</code>方法来获取实例</p><p>3）Calendar没有提供对应的格式化的类，需要开发者自己组合显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>System.out.println(c);  <span class="hljs-comment">//java.util.GregorianCalendar[time=1657010957876,areFieldsSet=true,...]</span><br><span class="hljs-comment">//</span><br>System.out.println(<span class="hljs-string">&quot;年：&quot;</span> + c.get(Calendar.YEAR));<br>System.out.println(<span class="hljs-string">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class="hljs-number">1</span>));<br>System.out.println(<span class="hljs-string">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));<br>System.out.println(<span class="hljs-string">&quot;时：&quot;</span> + c.get(Calendar.HOUR));<br>System.out.println(<span class="hljs-string">&quot;分：&quot;</span> + c.get(Calendar.MINUTE));<br>System.out.println(<span class="hljs-string">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));<br><br><span class="hljs-comment">//Calendar没有专门的格式化方法，需要开发者自己组合显式</span><br>System.out.println(c.get(Calendar.YEAR) + <span class="hljs-string">&quot;-&quot;</span> + (c.get(Calendar.MONTH) + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;-&quot;</span> + c.get(Calendar.DAY_OF_MONTH)<br>        + <span class="hljs-string">&quot; &quot;</span> + c.get(Calendar.HOUR_OF_DAY) + <span class="hljs-string">&quot;:&quot;</span> + c.get(Calendar.MINUTE) + <span class="hljs-string">&quot;:&quot;</span> + c.get(Calendar.SECOND));<br></code></pre></td></tr></table></figure><p><strong>前两代的不足</strong></p><p><code>Date</code>类的大多数方法已经在引入<code>Calendar</code>类后被弃用。</p><p>（1）可变性：像日期和时间这样的类应该是不可变的；</p><p>（2）偏移性：<code>Date</code>中年份是从1900开始，而月份都从0开始；</p><p>（3）格式化：格式化类只支持<code>Date</code>，不支持<code>Calendar</code>；</p><p>（4）其他：线程不安全、不能处理闰秒等（每隔2天，多出1s）</p><h1 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h1><h2 id="Date类（JDK1-0引入）"><a href="#Date类（JDK1-0引入）" class="headerlink" title="Date类（JDK1.0引入）"></a>Date类（JDK1.0引入）</h2><p>精确到毫秒，代表特定的瞬间</p><h2 id="SimpleDateFormat类：格式化和解析日期的类"><a href="#SimpleDateFormat类：格式化和解析日期的类" class="headerlink" title="SimpleDateFormat类：格式化和解析日期的类"></a>SimpleDateFormat类：格式化和解析日期的类</h2><p>允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="获取当前系统时间"><a href="#获取当前系统时间" class="headerlink" title="获取当前系统时间"></a>获取当前系统时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();  <span class="hljs-comment">//获取当前系统时间</span><br>System.out.println(<span class="hljs-string">&quot;当前日期 = &quot;</span> + date1);  <span class="hljs-comment">//当前日期 = Tue Jul 05 15:38:28 CST 2022</span><br><br><span class="hljs-comment">//创建 SimpleDateFormat对象，可以指定格式</span><br><span class="hljs-comment">//格式遵循规定</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> sdf.format(date1);<br>System.out.println(<span class="hljs-string">&quot;当前日期 = &quot;</span> + format);  <span class="hljs-comment">//当前日期 = 2022年07月05日 03:49:28 星期二</span><br></code></pre></td></tr></table></figure><h3 id="把一个格式化的-String-转成对应的-Date"><a href="#把一个格式化的-String-转成对应的-Date" class="headerlink" title="把一个格式化的 String 转成对应的 Date"></a>把一个格式化的 String 转成对应的 Date</h3><p>在把<code>String</code> -&gt; <code>Date</code>时，使用的<code>sdf</code>格式需要和给定的<code>String</code>格式一致，否则会抛出转换异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2022年07月05日 03:49:28 星期二&quot;</span>;<br><span class="hljs-type">Date</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> sdf.parse(s);<br><span class="hljs-comment">//得到 Date 仍然按国外形式输出，需要转换</span><br>System.out.println(<span class="hljs-string">&quot;parse = &quot;</span> + parse);  <span class="hljs-comment">//parse = Tue Jul 05 03:49:28 CST 2022</span><br>System.out.println(<span class="hljs-string">&quot;format_parse = &quot;</span> + sdf.format(parse));  <span class="hljs-comment">//format_parse = 2022年07月05日 03:49:28 星期二</span><br></code></pre></td></tr></table></figure><h3 id="通过指定毫秒数得到日期时间"><a href="#通过指定毫秒数得到日期时间" class="headerlink" title="通过指定毫秒数得到日期时间"></a>通过指定毫秒数得到日期时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">999999999</span>);<br>System.out.println(date2);  <span class="hljs-comment">//Mon Jan 12 21:46:39 CST 1970</span><br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>ISO 8601规定的日期和时间分隔符是T。标准格式如下：</p><ul><li>日期：yyyy-MM-dd</li><li>时间：HH:mm:ss</li><li>带毫秒的时间：HH:mm:ss.SSS</li><li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li><li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 异常</title>
    <link href="/2022/06/29/Java-%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/06/29/Java-%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p>Java语言中，程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。</p><p><code>Throwable</code> 类有两个重要的子类：</p><ul><li><p><strong>Exception（异常）</strong>：因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (非受检查异常，可以不处理)。</p></li><li><ul><li>如：空指针访问、试图读取不存在的文件、网络连接中断等等。</li></ul></li><li><p><strong>Error（错误）</strong>：<code>Error</code>属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获。例如 Java 虚拟机运行错误（<code>Virtual</code> MachineError）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p></li></ul><h1 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h1><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE.png" alt="异常体系图"></p><h1 id="受检异常和非受检异常"><a href="#受检异常和非受检异常" class="headerlink" title="受检异常和非受检异常"></a>受检异常和非受检异常</h1><p><strong>受检查异常（Checked Exception）</strong>：Java 代码在编译过程中，如果受检查异常没有被捕获<code>catch</code>或者抛出<code>throws</code>处理的话，就没办法通过编译。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。</p><p><strong>非受检查异常（Unchecked Exception）</strong>：Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code>及其子类都统称为非受检查异常，常见的有：</p><ul><li><code>NullPointerException</code>(空指针异常)</li><li><code>IllegalArgumentException</code>(参数异常 比如方法入参类型异常)</li><li><code>NumberFormatException</code>（字符串转换为数字格式异常，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界异常）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术异常）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><h1 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a><code>Throwable</code>类常用方法</h1><p><code>String getMessage()</code>：返回异常发生时的简要描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>()<span class="hljs-string">`：返回异常发生时的详细信息`</span><span class="hljs-title class_">String</span><br></code></pre></td></tr></table></figure><p><code>getLocalizedMessage()</code>：返回异常对象的本地化信息。使用<code>Throwable</code>的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</p><p><code>void printStackTrace()</code>：在控制台上打印<code>Throwable</code>对象封装的异常信息</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p><code>try-catch-finally</code>：程序员在代码中捕获发生的异常，自行处理。</p><p><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/try-catch-finally%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="try-catch-finally处理机制示意图"></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/throws%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="throws处理机制示意图"></p><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>Java提供<code>try-catch</code>块来处理异常。</p><p><code>try</code>用于包含可能出错得代码；<code>catch</code>块用于处理<code>try</code>块中发生的异常。</p><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>如果异常发生了，异常发生后面的代码不会执行，直接进入到<code>catch</code>块；</li><li>如果异常没有发生，则顺序执行<code>try</code>的代码块，不会进入到<code>catch</code>；</li><li>如果希望不管是否发生异常，都执行某段代码（比如关闭连接、释放资源等），则使用<code>finally&#123;&#125;</code>；</li><li>可以有多个<code>catch</code>语句，捕获不同的异常（进行不同的业务处理），要求子类异常在前，要求父类异常在后（如<code>Exception</code>要在<code>NullPointerException</code>后面）。如果发生异常，只会匹配一个<code>catch</code>；</li><li>可以进行<code>try-finally</code>配合使用，相当于没有捕获异常，因此执行完<code>finally</code>后程序会直接退出。（应用场景：执行一段代码，不管是否发生异常，都必须执行某个业务逻辑。）</li></ol><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol><li>如果没有出现异常，则执行<code>try</code>块中所有语句，不执行<code>catch</code>块中语句，最后还需要执行<code>finally</code>里面的语句（如果有<code>finally</code>）；</li><li>如果出现异常，则直接从异常语句直接跳到<code>catch</code>块中的语句，如果有<code>finally</code>，最后还需要执行<code>finally</code>中的语句</li><li>当在<code>try</code>块或<code>catch</code>块中遇到<code>return</code>语句时，<code>finally</code>语句块将在方法返回之前被执行。（示例1）；</li><li>由于异常已被处理，程序不会崩溃，继续执行下去，因此还要执行<code>try-catch-finally</code>后面的代码</li></ol><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        i++;  <span class="hljs-comment">// i=2</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">if</span> (names[i].equals(<span class="hljs-string">&quot;tom&quot;</span>)) &#123;  <span class="hljs-comment">// 空指针异常</span><br>            System.out.printin(names[<span class="hljs-number">1</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            names[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;jerry&quot;</span>;        <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutofBoundsException e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>        <span class="hljs-keyword">return</span> ++i; <span class="hljs-comment">//i=3 -&gt; </span><br>        <span class="hljs-comment">// 底层会把值保存在临时变量temp=3</span><br>        <span class="hljs-comment">// (由于return不能马上执行，需要先执行finally块的语句)</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ++i;  <span class="hljs-comment">// i=4</span><br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);  <span class="hljs-comment">// i=4</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(string[] args)</span> &#123;<br>    System.out.printin(method());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">i=4<br>3<br></code></pre></td></tr></table></figure><p><strong>注意：不要在</strong><code>**finally**</code><strong>语句块中使用</strong><code>**return**</code><strong>!</strong> 当<code>try/catch</code>语句和<code>finally</code>语句中都有<code>return</code>语句时，<code>try/catch</code>语句块中的<code>return</code>语句会被忽略。这是因为<code>try/catch</code>语句中的<code>return</code>返回值会先被暂存在一个本地变量中，当执行到<code>finally</code>语句中的<code>return</code>之后，这个本地变量的值就变为了<code>finally</code>语句中的<code>return</code>返回值。</p><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p>如果一个方法（中的语句执行时）可能产生某种异常，但是并不确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p><p>在方法声明中用<code>throws</code>语句可以声明抛出异常的列表，<code>throws</code>后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p><h3 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h3><ol><li><p>运行异常，程序中如果没有处理，默认就是<code>throws</code>的方式隐式处理（运行异常有默认处理机制）；</p></li><li><p>如果一个方法有可能抛出多个受查异常类型，必须<code>throws</code>列出所有异常，使用逗号分隔</p></li><li><p>子类重写父类的方法时，对抛出异常的规定：</p></li><li><ol><li>子类重写的方法，所抛出的异常类型要和父类抛出的异常一致或其子类型。</li><li>如果超类方法没有抛出任何受查异常， 子类也不能抛出任何受查异常。</li></ol></li></ol><p>总之，一个方法必须声明或捕获所有可能抛出的<strong>受查异常</strong>， 而<strong>非受查异常</strong>要么不可控制（Error），要么就应该避免发生（RuntimeException）。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>参考<code>Integer.parseInt()</code>方法，抛出异常分为两步：</p><p>1）创建某个<code>Exception</code>的实例；</p><p>2）用<code>throw</code>语句抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span> <span class="hljs-keyword">throws</span> NumberFormatException &#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(<span class="hljs-string">&quot;null&quot;</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><p>⚠ 捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</p><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><ol><li>自定义类（自定义异常类名）</li><li>继承<code>Exception</code>(编译异常)或<code>RuntimeException</code>(运行异常)</li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h2><p>不一定。以下特殊情况下，<code>finally</code>块的代码也不会被执行（<code>finally</code>执行前）：</p><ol><li>虚拟机被终止运行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>    <span class="hljs-comment">// 终止当前正在运行的Java虚拟机</span><br>    System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br>Try to <span class="hljs-keyword">do</span> something<br>Catch Exception -&gt; RuntimeException<br></code></pre></td></tr></table></figure><p>相关issue：<a href="https://github.com/Snailclimb/JavaGuide/issues/190">https://github.com/Snailclimb/JavaGuide/issues/190</a></p><h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 try-with-resources 代替try-catch-finally？</h2><p>适用范围（资源的定义）： 任何实现<code> java.lang.AutoCloseable</code>或者<code>java.io.Closeable</code>的对象</p><p>关闭资源和<code>finally</code>块的执行顺序： 在<code>try-with-resources</code>语句中，任何<code>catch</code>或 <code>finally</code>块在声明的资源关闭后运行</p><blockquote><p>《Effective Java》中明确指出：</p><p>面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。</p></blockquote><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取文本文件的内容</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://read.txt&quot;</span>));<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (scanner != <span class="hljs-literal">null</span>) &#123;<br>        scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更好的写法是使用 Java 7 之后的<code>try-with-resources</code>，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。</p><p>使用<code>try(resources)</code> 语句改造上面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;<br>    fnfe.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)));<br>     <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;out.txt&quot;</span>)))) &#123;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">while</span> ((b = bin.read()) != -<span class="hljs-number">1</span>) &#123;<br>        bout.write(b);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。<strong>编译器只看</strong><code>**try(resource = ...)**</code><strong>中的对象是否实现了</strong><code>**java.lang.AutoCloseable**</code><strong>接口</strong>，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p><h2 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h2><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 <code>new</code> 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>避免重复记录日志：如果在捕获异常的地方已经记录了足够的信息（包括异常类型、错误信息和堆栈跟踪等），那么在业务代码中再次抛出这个异常时，就不应该再次记录相同的错误信息。重复记录日志会使得日志文件膨胀，并且可能会掩盖问题的实际原因，使得问题更难以追踪和解决。</li><li>……</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 注解</title>
    <link href="/2022/06/28/Java-%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/06/28/Java-%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h1><p>Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><p>基本介绍</p><ol><li>注解也被称为元数据（Metadata），用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。</li><li>使用 Annotation 时要在前面加<code>@</code>符号，并把该 Annotation 当成一个修饰符使用，用于修饰它支持的程序元素。</li><li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</li><li>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。</li><li>在JavaEE中则占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li></ol><p>注解本质是一个继承了Annotation 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Override</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>JDK 提供了很多内置的注解，同时，我们还可以自定义注解。</p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code>注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解（比如 Spring 框架的<code>@Value</code>,<code>@Component</code>）都是通过反射来进行处理的。</li></ul><h1 id="三个基本的注解（修饰代码的注解）"><a href="#三个基本的注解（修饰代码的注解）" class="headerlink" title="三个基本的注解（修饰代码的注解）"></a>三个基本的注解（修饰代码的注解）</h1><ul><li><code>@Override</code>：限定某个方法 是重写父类方法，该注解只能用于方法</li><li><code>@Deprecated</code>：用于表示某个程序元素（类、方法等）已过时</li><li><code>@SuppressWarnings</code>：抑制编译器警告</li></ul><h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p><strong>使用说明</strong></p><ol><li><p><code>@Override</code>表示指定重写父类的方法（从编译层面验证），如果注解了没有重写则会报错。</p></li><li><p>重写的方法不写<code>@Override</code>注解，仍然构成重写。</p></li><li><p><code>@Override</code>只能修饰方法，不能修饰其他类、包、属性等。（查看源码可知：           <code>@Target(ElementType.METHOD)</code> ）</p></li><li><p><code>@Target</code>是修饰注解的注解，称为元注解。</p></li></ol><h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h2><p><strong>使用说明</strong></p><ol><li><p>用于表示某个程序元素已过时（被标记的元素调用时显示为删除线）</p></li><li><p>可以修饰构造器、字段、局部变量、方法、包、参数、类。（查看源码：<code>@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;) </code>）</p></li><li><p><code>@Deprecated</code>的作用可以做到新旧版本的兼容和过渡。</p></li></ol><h2 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h2><p><strong>使用说明</strong></p><ol><li>当不希望看到这些警告时，可以使用 SuppressWarnings注解来抑制警告信息</li><li>在{“”}中，可以指定你希望抑制（不显示）警告信息</li></ol><table><thead><tr><th>all</th><th>抑制所有警告</th></tr></thead><tbody><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td></tr><tr><td>fallthrough</td><td>抑制在 switch 中缺失 breaks 的警告</td></tr><tr><td>finally</td><td>抑制 finally 模块没有返回的警告</td></tr><tr><td>hiding</td><td>抑制相对于隐藏变量的局部变量的警告</td></tr><tr><td>incomplete-switch</td><td>忽略不完整的 switch 语句</td></tr><tr><td>nls</td><td>忽略非 nls 格式的字符</td></tr><tr><td>null</td><td>忽略对 null 的操作</td></tr><tr><td>rawtypes</td><td>使用 generics 时忽略没有指定相应的类型</td></tr><tr><td>restriction</td><td>抑制禁止使用劝阻或禁止引用的警告</td></tr><tr><td>serial</td><td>忽略在 serializable 类中没有声明 serialVersionUID 变量</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td></tr></tbody></table><h1 id="元注解（修饰注解的注解）"><a href="#元注解（修饰注解的注解）" class="headerlink" title="元注解（修饰注解的注解）"></a>元注解（修饰注解的注解）</h1><ul><li>@Retention - 指定注解的作用范围：SOURCE,CLASS,RUNTIME（标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问）</li><li>@Target - 标记这个注解应该是哪种 Java 成员。（可以在哪些地方使用）</li><li>@Documented - 标记这些注解是否包含在javadoc（用户文档）中。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>用于修饰注解定义，用于指定该注解可以保留多长时间。</p><p><code>SOURCE</code>：编译器使用后，直接丢弃这种策略的注释（当编译器编译时生效，不会写入到class 文件，也不会再 runtime (运行时)生效。）</p><p><code>CLASS</code>：默认值。编译器将把注解记录在 class 文件中。当运行 Java 程序时，JVM 不会保留注解。</p><p><code>RUNTIME</code>：编译器将把注解记录在 class 文件中。当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解。</p><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>用于修饰注解定义，用于指定被修饰的注解可修饰哪些程序元素</p><h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>用于指定被修饰的注解类将被 javadoc 工具提取成文档，即在生成文档时，可以看到该注解。</p><p>定义为<code>Documented</code>的注解必须设置<code>Retention</code>值为<code>RUNTIME</code>。</p><h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>被它修饰的注解将具有继承性，如果某个类使用了被<code>@Inherited</code>修饰的注解，则其子类将自动具有该注解。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面向对象</title>
    <link href="/2022/06/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/06/13/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、面向对象和面向过程的区别"><a href="#一、面向对象和面向过程的区别" class="headerlink" title="一、面向对象和面向过程的区别"></a>一、面向对象和面向过程的区别</h1><p>面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：</p><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>相较于 POP，OOP 开发的程序一般具有下面这些优点：</p><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><p>在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。</p><p>求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案</p><p><strong>面向对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-comment">// 定义圆的半径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算圆的面积</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算圆的周长</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPerimeter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * Math.PI * radius;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个半径为3的圆</span><br>        <span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">3.0</span>);<br><br>        <span class="hljs-comment">// 输出圆的面积和周长</span><br>        System.out.println(<span class="hljs-string">&quot;圆的面积为：&quot;</span> + circle.getArea());<br>        System.out.println(<span class="hljs-string">&quot;圆的周长为：&quot;</span> + circle.getPerimeter());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了一个 Circle 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。</p><p><strong>面向过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义圆的半径</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.0</span>;<br><br>        <span class="hljs-comment">// 计算圆的面积和周长</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.PI * radius * radius;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">perimeter</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * Math.PI * radius;<br><br>        <span class="hljs-comment">// 输出圆的面积和周长</span><br>        System.out.println(<span class="hljs-string">&quot;圆的面积为：&quot;</span> + area);<br>        System.out.println(<span class="hljs-string">&quot;圆的周长为：&quot;</span> + perimeter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接定义了圆的半径，并使用该半径直接计算出圆的面积和周长。</p><h1 id="二、面向对象三大特征"><a href="#二、面向对象三大特征" class="headerlink" title="二、面向对象三大特征"></a>二、面向对象三大特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><p>就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作【方法】，才能对数据进行操作</p><p><strong>步骤</strong></p><ol><li>对属性进行私有化private 【不能直接修改属性】</li><li>提供一个公共的 public set 方法，用于对属性判断并赋值 public void</li><li>提供一个公共的 public get 方法，用于获取属性的值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;  <span class="hljs-comment">// id属性私有化</span><br>    <span class="hljs-keyword">private</span> String name;  <span class="hljs-comment">// name属性私有化</span><br><br>    <span class="hljs-comment">//获取id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-comment">//设置id的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-comment">//获取name的方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-comment">//设置name的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造器 与 set 结合</strong></p><p>将 set 方法写在构造器中，仍然可以进行数据验证</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8Eset%E7%BB%93%E5%90%88.png" alt="构造器与set结合"></p><h2 id="继承（Extends）"><a href="#继承（Extends）" class="headerlink" title="继承（Extends）"></a>继承（Extends）</h2><p>继承可以解决代码复用。当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类无需重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承父类即可。</p><p>子类自动拥有父类定义的属性和方法。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="重要规则"><a href="#重要规则" class="headerlink" title="重要规则"></a>重要规则</h3><ol><li>子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过父类提供的公共方法去访问；</li><li>子类必须调用父类的构造器，完成对父类的初始化；</li><li>当创建子类对象时，不管使用子类哪个构造器，默认情况下总会去调用父类的无参构造器（<code>super();</code>）；（示例1）</li><li>如果父类没有无参构造器，则必须在子类的构造器中使用<code>super</code>去指定使用父类哪个构造器完成对父类的初始化工作，否则编译不通过；（示例2）</li><li>如果希望指定去调用父类的某个构造器，则显式地调用一下：<code>super(参数列表);</code></li><li><code>super</code>在使用时，必须放在构造器第一行；（<code>super</code>只能在构造器中使用）</li><li><code>super()</code> 和 <code>this()</code> 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>父类构造器的调用不限于直接父类！将一直往上追溯直到<code>Object</code>类（顶级父类）</li><li>java 是单继承机制：子类只能继承一个父类；</li><li>不能滥用继承关系，子类和父类之间必须满足 is-a 的逻辑关系。（Person is a Music? Music extends Person × Cat is a Animal? Cat extends Animal √ ）</li></ol><p><strong>示例2-1</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.png" alt="构造器调用顺序"></p><p><strong>示例2-2</strong></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%8C%87%E5%AE%9A%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="指定父类构造器"></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="继承内存分析"></p><p><strong>分析：</strong></p><p>（1）首先看子类是否有该属性；</p><p>（2）如果子类有，并且可以访问，则返回信息；（父类相同的属性就无法访问了）</p><p>（3）如果子类没有，就看父类有没有，如果父类有，并且可以访问，就返回信息；</p><p>（4）如果父类没有，就按照（3）的规则，继续找上级父类，知道 Object……</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>代表父类的引用，用于访问父类的属性、方法、构造器。</p><p><strong>调用父类的构造器的好处：</strong>分工明确，父类属性由父类初始化，子类属性由子类初始化。</p><p><strong>基本语法</strong></p><p>访问父类的属性（除<code>private</code>以外），<code>super.field;</code></p><p>访问父类的方法（除<code>private</code>以外），<code>super.method();</code></p><p>访问父类的构造器，<code>super(参数列表);</code> （只能放在构造器第一句，只能出现一句）</p><p><strong>重要规则</strong></p><ol><li><p>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过<code>super</code>。如果没有重名，使用<code>super</code>、<code>this</code>、直接访问是一样的效果。</p></li><li><ol><li><strong>查找同名方法和属性的规则：</strong></li><li>先找本类，如果有，则调用</li><li>如果本类没有，找上一级父类（有，并可以调用，则调用）</li><li>如果父类没有，继续往上找，直到<code>Object</code>类</li><li><code>method()</code>和<code>this.method()</code>等价遵循以上规则，<code>super.method()</code>则直接跳过本类查找父类</li></ol></li><li><p><code>super</code>的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名成员，则遵循就近原则。</p></li></ol><p><strong>super 和 this 的比较</strong></p><table><thead><tr><th></th><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>1</td><td>访问属性</td><td>访问本类中的属性，如果本类没有此属性，则从父类中继续查找</td><td>从父类开始查找属性</td></tr><tr><td>2</td><td>调用方法</td><td>访问本类中的方法，如果本类没有此方法，则从父类中继续查找</td><td>从父类开始查找方法</td></tr><tr><td>3</td><td>调用构造器</td><td>调用本类构造器，必须放在构造器首行</td><td>调用父类构造器，必须放在子类构造器首行</td></tr><tr><td>4</td><td>特殊</td><td>表示当前对象</td><td>子类中访问父类对象</td></tr></tbody></table><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>方法或对象具有多种形态</p><ol><li><p>方法的多态：方法重写和重载就体现多态</p></li><li><p>对象的多态（核心）：</p></li><li><ol><li>一个对象的编译类型和运行类型可以不一致； 如：<code>Animal animal = new Dog();</code></li><li>编译类型在定义对象时，就确定了，不能改变；</li><li>运行类型是可以变化的，可通过<code>getClass()</code>查看运行类型；</li><li>编译类型看定义时<code>=</code>号的左边，运行类型看<code>=</code>号的右边</li></ol></li></ol><h3 id="多态的特点"><a href="#多态的特点" class="headerlink" title="多态的特点"></a>多态的特点</h3><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p><strong>本质：</strong>父类的引用指向了子类的对象</p><p><strong>语法：</strong><code>父类类型 引用名 = new 子类类型();</code></p><p><strong>向上转型调用方法的规则如下：</strong></p><ol><li>可以调用父类中的所有成员（遵守访问权限）；不能调用子类中的特有成员；</li><li>在<strong>编译期</strong>，只能调用父类中声明的方法，但在<strong>运行期</strong>，实际执行的是子类重写父类的方法；</li><li>在编译阶段，能调用哪些成员，是由编译类型来决定的（编译器）；</li><li>最终运行效果看子类的具体实现。</li></ol><p><strong>示例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;动物&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;sleep&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;run&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;eat&quot;</span>);&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;cat eat fish&quot;</span>);&#125;  <span class="hljs-comment">//重写eat方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;System.out.println(<span class="hljs-string">&quot;cat catch mouse&quot;</span>);&#125;  <span class="hljs-comment">//Cat类特有的catchMouse方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        animal.eat();  <span class="hljs-comment">//输出：cat eat fish</span><br>        animal.run();  <span class="hljs-comment">//输出：run</span><br>        animal.show();  <span class="hljs-comment">//输出：hello</span><br>        animal.sleep();  <span class="hljs-comment">//输出：sleep</span><br>        animal.catchMouse();  <span class="hljs-comment">//报错，因为在编译阶段，能调用哪些成员，是由编译类型来决定的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>语法：<code>子类类型  引用名  =  (子类类型)父类引用;</code></p><ol><li>只能强转父类的引用，不能强转父类的对象；</li><li>要求父类的引用必须指向的是当前目标类型的对象；</li><li>当向下转型后，可以调用子类类型中所有的成员。</li></ol><p>编译类型和运行类型不一致才需要向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//续上示例3</span><br><span class="hljs-comment">//若要调用Cat的 catchMouse方法</span><br><span class="hljs-comment">//向下转型</span><br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal;<br>cat.catchMouse();  <span class="hljs-comment">//输出：cat catch mouse</span><br></code></pre></td></tr></table></figure><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><ol><li><strong>属性</strong>没有重写之说，属性的值看<strong>编译类型</strong>。（示例4）</li></ol><p><strong>示例4</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Base</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>        System.out.println(base.count);  <span class="hljs-comment">//输出 10</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; &#125;<br></code></pre></td></tr></table></figure><ol><li><code>instanceof</code> 比较操作符：用于判断对象的运行类型，是否为XX类型或者XX类的子类型。（示例5）</li></ol><p><strong>示例5</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//续上（示例4）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyTest03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Sub</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>        System.out.println(sub <span class="hljs-keyword">instanceof</span> Sub);  <span class="hljs-comment">//true</span><br>        System.out.println(sub <span class="hljs-keyword">instanceof</span> Base);  <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h3><ol><li>当调用对象<strong>方法</strong>时，该方法会和该对象的内存地址&#x2F;运行类型绑定</li><li>当调用对象<strong>属性</strong>时，没有动态绑定机制，哪里声明，哪里使用。</li></ol><p><strong>示例6</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicBinding</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        System.out.println(a.sum());  <span class="hljs-comment">// 30</span><br>        System.out.println(a.sum1());  <span class="hljs-comment">// 20</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getI() + <span class="hljs-number">10</span>;  <span class="hljs-comment">//调用运行类型的 getI() 方法 </span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//先找局部变量，局部变量没有i，再找属性，属性有则返回 i+10=&gt;10+10</span><br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">10</span>;  <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">//public int sum() &#123;</span><br>    <span class="hljs-comment">//    return i + 20;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">//属性没有动态绑定机制，哪里声明就使用哪里的，使用的是B类的属性i = 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h3><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。</p><p><strong>示例7</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// Student对象 和 Teacher对象，统一放在数组中，并调用每个对象的say方法</span><br>    Person[] persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[<span class="hljs-number">3</span>];<br>    persons[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">20</span>);<br>    persons[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;shit&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-number">99</span>);<br>    persons[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;boxpig&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20000</span>);<br><br>    <span class="hljs-comment">//循环遍历多态数组，调用say</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; persons.length; i++) &#123;<br>        <span class="hljs-comment">//persons[i] 编译类型是Person，运行类型是根据实际情况由JVM判断</span><br>        System.out.println(persons[i].say());  <span class="hljs-comment">//动态绑定机制</span><br>        <span class="hljs-comment">// 使用类型判断+向下转型</span><br>        <span class="hljs-comment">// 判断persons[i] 的运行类型是不是Student</span><br>        <span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Student) &#123;  <br>            <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) persons[i];  <span class="hljs-comment">//向下转型</span><br>            student.study();<br>            <span class="hljs-comment">//以上等价于 ((Student) persons[i]).study();</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (persons[i] <span class="hljs-keyword">instanceof</span> Teacher)&#123;<br>            ((Teacher) persons[i]).teach();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(persons[i] <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;你的类型有误...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p>方法定义的形参类型为父类类型，实参类型允许为子类类型。</p><h1 id="三、接口与抽象类"><a href="#三、接口与抽象类" class="headerlink" title="三、接口与抽象类"></a>三、接口与抽象类</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名 &#123;<br>    <span class="hljs-comment">//属性 总是(自带) public static final</span><br>    <span class="hljs-comment">//方法（ 1.抽象方法   2.默认实现方法   3.静态方法 ）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//接口中的抽象方法，public abstract可以省略</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;我是默认实现方法&quot;</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;我是静态方法&quot;</span>); &#125;<br>&#125;<br><br>class 类名 implements 接口 &#123;<br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-comment">//必须实现的接口的抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认方法和静态方法是 jdk8 新增，jdk7 以前接口内所有方法均无方法体，即都是抽象方法。</li><li>接口中的<strong>方法</strong>会被隐式的指定为 <code>public abstract</code></li><li>接口中的<strong>变量</strong>会被隐式的指定为 <code>public static final</code> 变量</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>由于自带<code>static</code>，接口中属性的访问语法：<code>接口名.属性名</code></li><li>一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是<code>public</code>；（IDEA快捷键：ctrl+i 或 alt shift enter）</li><li>抽象类实现接口，可以不用实现抽象方法；</li><li>接口支持多继承；（一个接口不能继承其他类，但是可以继承多个别的接口）</li><li>一个类可以同时实现多个接口；</li><li>接口的修饰符只能是 public 和 默认，这点和类一样。</li></ul><h3 id="为什么需要接口？"><a href="#为什么需要接口？" class="headerlink" title="为什么需要接口？"></a>为什么需要接口？</h3><ul><li>接口比抽象类还要抽象，可以更加规范地对子类进行约束，全面地实现了：规范和具体实现的分离。</li><li>接口就是规范，定义的是一组规则。本质是契约。</li><li>项目的具体需求是多变的，开发要以不变（规范）应万变。因此开发项目往往都是面向接口编程。</li></ul><p><strong>实现类可以不必覆写</strong><code>**default**</code><strong>方法。</strong><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><h3 id="接口的多态性"><a href="#接口的多态性" class="headerlink" title="接口的多态性"></a>接口的多态性</h3><p>接口引用可以指向实现了该接口的对象实例。</p><p>示例3-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IF</span> <span class="hljs-variable">if01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();    <span class="hljs-comment">//接口类型的变量 if01 可以指向 实现了IF接口的对象实例</span><br>        <span class="hljs-type">IF</span> <span class="hljs-variable">if02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IF</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>示例3-2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Camera</span> <span class="hljs-variable">camera</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        <span class="hljs-type">Phone</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        <span class="hljs-comment">//把手机、相机对象接入计算机</span><br>        computer.work(camera);<br>        computer.work(phone);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br>    <span class="hljs-comment">//1. UsbInterface usbInterface 形参是接口类型 UsbInterface</span><br>    <span class="hljs-comment">//2. 可以接收（实现了UsbInterface接口的类的）对象实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(UsbInterface usbInterface)</span> &#123;<br>        <span class="hljs-comment">//通过接口来调用方法</span><br>        usbInterface.start();<br>        usbInterface.stop();    <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//USB接口，规定接口的相关规范（方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//手机实现USB接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UsbInterface</span> &#123;&#125;  <span class="hljs-comment">//相机实现USB接口</span><br></code></pre></td></tr></table></figure><p>示例3-3（多态数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//多态数组 -&gt; 接口类型数组</span><br>        Usb[] usbs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Usb</span>[<span class="hljs-number">2</span>];<br>        usbs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br>        usbs[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        <span class="hljs-comment">//输出数组对象的方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; usbs.length; i++) &#123;<br>            usbs[i].work();  <span class="hljs-comment">//动态绑定...</span><br>            <span class="hljs-keyword">if</span> (usbs[i] instance of Phone) &#123;  <span class="hljs-comment">//判断运行类型是否为Phone，是才调用手机特有的call方法</span><br>                ((Phone) usbs[i]).call();  <span class="hljs-comment">//向下转型            </span><br>            &#125;        <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Usb</span>&#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>; &#125;  <span class="hljs-comment">//usb接口，规定了work方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;手机可以打电话&quot;</span>); &#125;  <span class="hljs-comment">//手机特有的call方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;手机工作中...&quot;</span>); &#125;  <span class="hljs-comment">//实现手机的work方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123; System.println.out(<span class="hljs-string">&quot;相机工作中...&quot;</span>); &#125;  <span class="hljs-comment">//实现相机的work方法</span><br>&#125;<br><br><span class="hljs-comment">//输出</span><br>手机工作中...<br>手机可以打电话<br>相机工作中...<br></code></pre></td></tr></table></figure><p>接口的多态传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfacePolyPass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 接口类型的变量 可以指向 实现了该接口的类的对象</span><br>        <span class="hljs-type">IA</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>        <span class="hljs-comment">// 如果IB继承了IA接口，而Apple类实现了IB接口，那实际上相当于Apple类也实现了IA接口</span><br>        <span class="hljs-type">IB</span> <span class="hljs-variable">ib</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IA</span> &#123;&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IA</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IB</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>没有任何方法的接口被称为标记接口。</p><p>标记接口是计算机科学中的一种设计思路，用于给那些面向对象的编程语言描述对象。因为编程语言本身并不支持为类维护元数据，而标记接口可以用作描述类的元数据，弥补了这个功能上的缺失。对于实现了标记接口的类，我们就可以在运行时通过反射机制去获取元数据。</p><p>以<code>Serializable</code>接口为例，如果一个类实现了这个接口，则表示这个类可以被序列化。因此，我们实际上是通过了<code>Serializable</code>这个接口给该类标记了【可被序列化】的元数据，打上了【可被序列化】的标签。这也是标记&#x2F;标签接口名字的由来。</p><p>在Java中，标记接口主要有以下两种目的：</p><ol><li>建立一个公共的父接口。比如<code>EventListener</code>接口，一个由几十个其它接口扩展的Java API，当一个接口继承了EventListener接口，Java虚拟机（JVM）就知道该接口将要被用于一个事件的代理方案。同样的，你可以使用一个标记接口来建立一组接口的父接口。</li><li>向一个类添加数据类型。这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法（因为标记接口根本就没有方法），但是该类通过 Java 的<strong>多态性</strong>可以变成一个接口类型。</li></ol><p>更多的，一些容器例如 Ejb 容器，Servlet 容器或运行时环境依赖标记接口识别类是否需要进行某种处理，比如<code>Serialialbe</code>接口标记类需要进行序列化操作。</p><p>当然了，在现在 Spring 流行的时代，注解（Annotation）已经成为了最好的维护元数据的方式。因为注解能声明在包、类、字段、方法、局部变量、方法参数等之上，既灵活又方便地起到维护元数据的目的。</p><h3 id="Java-8-新增"><a href="#Java-8-新增" class="headerlink" title="Java 8 新增"></a>Java 8 新增</h3><p>Java 8 引入的<code>default</code>方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method in the interface.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 8 引入的<code>static</code>方法无法在实现类中被覆盖，只能通过接口名直接调用（ <code>MyInterface.staticMethod()</code>），类似于类中的静态方法。<code>static</code>方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method in the interface.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 9 允许在接口中使用 <code>private</code> 方法。<code>private</code>方法可以用于在接口内部共享代码，不对外暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-comment">// default 方法</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        commonMethod();<br>    &#125;<br><br>    <span class="hljs-comment">// static 方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        commonMethod();<br>    &#125;<br><br>    <span class="hljs-comment">// 私有静态方法，可以被 static 和 default 方法调用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commonMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a private method used internally.&quot;</span>);<br>    &#125;<br><br>      <span class="hljs-comment">// 实例私有方法，只能被 default 方法调用。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceCommonMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a private instance method used internally.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>是一种模板模式。抽象类为所有子类提供一个通用模板，子类可以在这个模板的基础上进行扩展。</p><p>通过抽象类，可以避免子类设计的随意性。通过抽象类，严格限制子类的设计，使子类之间更加通用。</p><p>抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>有抽象方法的类只能定义为抽象类，抽象类不一定包含抽象方法；</li><li>抽象类不能实例化，即不能用<code>new</code>来实例化抽象类；</li><li>抽象类可以有任何成员（属性、方法、构造方法）【抽象类本质还是类】，但是构造方法不能用来new实例，只能用来被子类调用；</li><li>抽象类只能用来继承；</li><li>如果一个类继承了抽象类，则它必须<strong>实现</strong>抽象类的<strong>所有</strong>抽象方法，除非也声明为抽象类。即抽象方法必须被子类实现。</li><li>抽象方法不能有主体，即不能实现；（不能有{大括号}）</li><li>抽象方法不能用<code>private</code>、<code>final</code>和<code>static</code>来修饰，因为这些关键字都是和重写相违背。</li></ul><h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>把方法的设计与实现分离</p><p>设计：这个类有什么方法、方法的声明（方法名、返回值、形参）</p><p>实现：具体的方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-comment">//抽象类</span><br>    String str; <span class="hljs-comment">//可定义属性</span><br>    <span class="hljs-comment">// 抽象方法，不定义run()方法 (加abstract关键字，不要大括号&#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>; <br><br>    <span class="hljs-comment">// 可定义普通方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breath</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;呼吸&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 可以定义构造方法：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;创造一个动物&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本质是：</p><ul><li>上层代码只定义规范（例如：abstract class Person）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>需求：</strong></p><ol><li>有多个类，完成不同的任务job</li><li>要求统计得到各自完成任务的时间</li></ol><p><strong>设计一个抽象类（Template），能完成如下功能：</strong></p><ol><li>编写方法<code>calculateTime()</code>，可以计算某段代码的耗时时间</li><li>编写抽象方法<code>job()</code></li><li>编写一个子类<code>Sub</code>，继承抽象类<code>Template</code>，并实现<code>job</code>方法</li><li>编写一个测试类<code>TestTemplate</code>进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类//抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span> &#123;  <br>    <span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-comment">//实现方法，调用job方法，统计job方法的耗时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateTime</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">//得到开始时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        job();  <span class="hljs-comment">//动态绑定机制</span><br><br>        <span class="hljs-comment">//得到结束时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;任务执行时间：&quot;</span> + (end - start));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//子类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ajob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;<br>    <span class="hljs-comment">//计算任务A</span><br>    <span class="hljs-comment">//1+2+3+...+100000</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//实现了父类Template的抽象方法job</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000000</span>; i++) &#123;<br>            num += i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//子类B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bjob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;<br>    <span class="hljs-comment">//计算任务B</span><br>    <span class="hljs-comment">//1*2*3*...*800000</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">800000</span>; i++) &#123;<br>            num *= i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类和接口的异同点"><a href="#抽象类和接口的异同点" class="headerlink" title="抽象类和接口的异同点"></a>抽象类和接口的异同点</h2><p>接口和抽象类的共同点</p><p><strong>实例化</strong>：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</p><p><strong>抽象方法</strong>：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</p><p>接口和抽象类的区别</p><p><strong>设计目的</strong>：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p><p><strong>继承和实现</strong>：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。</p><p><strong>成员变量</strong>：接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（private, protected, public），可以在子类中被重新定义或赋值。</p><p><strong>方法</strong>： </p><ul><li>Java 8 之前，接口中的方法默认是 <code>public abstract</code> ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 default（默认） 方法和 static （静态）方法。 自 Java 9 起，接口可以包含 private 方法。</li><li>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。</li></ul><h1 id="四、类与对象"><a href="#四、类与对象" class="headerlink" title="四、类与对象"></a>四、类与对象</h1><h2 id="类与对象关系"><a href="#类与对象关系" class="headerlink" title="类与对象关系"></a>类与对象关系</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="类与对象的关系"></p><h2 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a>属性&#x2F;成员变量</h2><ol><li>从概念或叫法上看：成员变量 &#x3D; 属性 &#x3D; 字段（field）。</li><li>属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象、数组）。</li><li>属性的定义语法：访问修饰符 属性类型 属性名  示例：<code>protected String name;</code>。</li><li>属性的定义类型可以为任意类型，包括基本类型和引用类型。</li><li>属性如果没有赋值，有默认值，规则和数组一致：int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u0000, boolean false, String null;</li></ol><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><ol><li>先声明后创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Cat cat;<br>cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><ul><li>对象名 cat 在栈指向一个空的空间</li><li>在堆开辟空间，同时分配地址（只要有数据空间，就会有地址），把地址赋给 cat 对象名</li></ul><ol><li>直接创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>先在<strong>方法区</strong>加载<code>Cat</code>类信息（<strong>属性</strong>和<strong>方法</strong>信息，只会加载一次）；</li><li>在堆中分配空间，进行默认初始化；</li><li>把地址赋给<code>whiteCat</code>，<code>whiteCat</code>就指向对象；</li><li>进行指定初始化，比如  <code>whiteCat.name = &quot;小白&quot;;</code> <code>whiteCat.age = 6;``whiteCat.color = &quot;white&quot;;</code></li></ol><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="类与对象的内存布局"></p><p><strong>⚠</strong> <strong>JDK1.7 ，字符串常量池和静态变量从永久代（方法区）移动了 Java 堆中</strong></p><p>永久代是方法区的具体实现，和堆一样都是由 JVM 管理的运行时数据区域，但堆有更高的 GC 回收效率，因此把需要大量进行字符串回收的字符串常量池移到堆中。</p><p>JDK1.8 ，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存，不受 JVM 内存的限制。</p><p>详见：<a href="https://www.yuque.com/kingshit/java/crf342hk3xb326g3">Java内存区域详解</a></p><h3 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h3><p><strong>栈</strong>：一般存放基本数据类型（局部变量）</p><p><strong>堆</strong>：存放对象（Cat cat，数组等）</p><p><strong>方法区</strong>：常量池（常量，比如字符串），类加载信息</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%EF%BC%88jdk1.7%E4%BB%A5%E5%89%8D%EF%BC%89.png" alt="类与对象内存分配机制（jdk1.7以前）"></p><h3 id="对象创建的流程分析"><a href="#对象创建的流程分析" class="headerlink" title="对象创建的流程分析"></a>对象创建的流程分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="对象创建的流程分析"></p><p>jdk 1.7以前</p><p><strong>流程分析：</strong></p><ol><li>加载类信息（Xxx.class），只会加载一次</li><li>在堆中分配空间（地址）</li><li>完成对象初始化（默认初始化、显式初始化、构造器初始化）</li><li>把对象在堆中的地址返回给对象的引用（对象名）</li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="方法调用机制"><a href="#方法调用机制" class="headerlink" title="方法调用机制"></a>方法调用机制</h3><p>方法执行会开辟一个独立的栈空间，方法执行完毕该空间就会释放。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6.png" alt="方法调用机制"></p><center>（jdk 1.7以前）</center><p><strong>同一类中的方法调用</strong>：直接调用</p><p><strong>跨类中的方法调用</strong>：需要先创建对象，通过对象名调用</p><h3 id="成员方法的定义"><a href="#成员方法的定义" class="headerlink" title="成员方法的定义"></a>成员方法的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">访问修饰符 返回数据类型 方法名(形参列表...)&#123;  <span class="hljs-comment">// 方法体</span><br>    语句；<br>    返回值；<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>访问修饰符：控制方法使用的范围，public、protected、默认（不写）、private</p></li><li><p>形参列表：表示成员方法输入 ；</p></li><li><ol><li>可以有0或多个参数，用逗号分隔；</li><li>参数类型可以为任意类型，包括基本和引用类型；</li><li>调用带参数的方法时，一定要对应着参数列表传入相同类型或兼容类型的参数；</li><li>方法定义时的参数成为形式参数（形参&#x2F;虚参）；方法调用时传入的参数成为实际参数（实参）；实参和形参的类型要一致或兼容，个数、顺序也要一致；</li></ol></li><li><p>返回数据类型：表示成员方法输出，void 表示没有返回值：</p></li><li><ol><li>一个方法最多有一个返回值；（如果要返回多个值，可以声明数组类型）</li><li>返回类型可以为任意类型，包括基本和引用类型；</li><li>如果方法声明了返回数据类型，则方法体中最后的执行语句必须为 return 值；而且要求返回值类型必须和return的值类型一致或兼容</li><li>如果方法是 void，不能有返回值，方法体中可以没有 return 语句，或者只写 return；</li></ol></li><li><p>方法体：表示为了实现某一功能代码块；</p></li><li><ol><li>写完成功能的具体语句，可以为输入输出、变量、运算、分支、循环、方法调用等，但不能再定义方法，即方法不能嵌套定义。</li></ol></li><li><p><code>return</code> 语句不是必须的。</p></li></ol><h3 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p><code>AA</code>类中编写一个方法<code>swap</code>，接收两个整数，在方法中交换两个数，主方法中声明两个数，调用<code>swap</code>方法，看两数是否发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>        <span class="hljs-type">AA</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>();<br>        aa.swap(a, b);<br>        System.out.println(<span class="hljs-string">&quot;main方法：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:8, b:24</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a和b交换前：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:8, b:24</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>        a = b;<br>        b = tmp;<br>        System.out.println(<span class="hljs-string">&quot;a和b交换后：a = &quot;</span> + a + <span class="hljs-string">&quot; b = &quot;</span> + b);  <span class="hljs-comment">// a:24, b:8</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong>基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png" alt="基本数据类型传参机制"></p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>B类中编写一个方法test100，可以接收一个数组，在方法中修改该数组，看原数组是否变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BB</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BB</span>();<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        bb.test100(arr);<br>        <span class="hljs-comment">// 打印数组</span><br>        System.out.println(<span class="hljs-string">&quot;main中的数组：&quot;</span>);  <span class="hljs-comment">// 100 2 3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test100</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;test100中的数组：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong>引用类型，传递的是地址（其实传递也是值，但值是地址），可以通过形参影响实参</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6.png" alt="引用类型传参机制"></p><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>JVM 会给每个对象分配<code>this</code>，代表当前对象。</p><p>简单的说，哪个对象调用，<code>this</code>就代表哪个对象。</p><p><strong>示例</strong></p><p>由于 java 是在虚拟机上跑的，地址是虚拟机的地址，无法直接获取对象的地址。</p><p><code>hashCode()</code>方法会针对不同对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThisTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;皮蛋&quot;</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// 输出dog1对象的哈希值（根据对象内部地址转换）</span><br>        System.out.println(<span class="hljs-string">&quot;dog1 的 hashCode= &quot;</span> + dog1.hashCode());<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;皮球&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 输出dog2对象的哈希值</span><br>        System.out.println(<span class="hljs-string">&quot;dog2 的 hashCode= &quot;</span> + dog2.hashCode());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">27</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">// 构造器</span><br>        <span class="hljs-comment">// 把构造方法的实参赋给属性</span><br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">//this.name 就是当前对象的属性name</span><br>        <span class="hljs-built_in">this</span>.age = age;   <span class="hljs-comment">//this.age 就是当前对象的属性age</span><br>        <span class="hljs-comment">// 测试：当调用构造器初始化对象的时候，输出当前this的哈希值</span><br>        System.out.println(<span class="hljs-string">&quot;this.hashCode= &quot;</span> + <span class="hljs-built_in">this</span>.hashCode());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 成员方法，输出属性x信息</span><br>        System.out.println(name + <span class="hljs-string">&quot;\t&quot;</span> + age + <span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="输出结果"></p><p>由于<code>this</code>指向当前对象，因此<code>this</code>的地址与当前对象地址相同</p><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/this%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="this内存分析"></p><p>jdk 1.7以前</p><p>可以简单理解成（虽然现实可能不会这样）：在对象创建完成后，在堆内隐藏了一个this属性，指向对象本身。</p><h3 id="this-用法"><a href="#this-用法" class="headerlink" title="this 用法"></a>this 用法</h3><ol><li><code>this</code>关键字可以用来访问本类的属性、方法、构造器；</li><li><code>this</code>用于区分当前类的属性和局部变量；</li><li>访问成员方法的语法：<code>this.方法名(参数列表);</code> </li><li>访问构造器语法：<code>this(参数列表);</code>  注意只能在构造器中使用（即只能在构造器中访问另一个构造器），并只能放置在第一条语句；</li><li><code>this</code>不能在类定义的外部使用，只能在类定义的方法中使用。</li></ol><h1 id="五、深拷贝和浅拷贝？什么是引用拷贝？"><a href="#五、深拷贝和浅拷贝？什么是引用拷贝？" class="headerlink" title="五、深拷贝和浅拷贝？什么是引用拷贝？"></a>五、深拷贝和浅拷贝？什么是引用拷贝？</h1><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝的示例代码如下，我们这里实现了<code>Cloneable</code>接口，并重写了<code>clone()</code>方法。</p><p><code>clone()</code>方法的实现很简单，就是直接调用的是父类<code>Object</code>的<code>clone()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Address) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-keyword">return</span> person;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// true</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code>的克隆对象和<code>person1</code>使用的仍然是同一个<code>Address</code> 对象。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>简单对<code>Person</code>类的<code>clone()</code>方法进行修改，连带着要把<code>Person</code>对象内部的<code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        person.setAddress(person.getAddress().clone());<br>        <span class="hljs-keyword">return</span> person;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// false</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出，显然<code>person1</code>的克隆对象和<code>person1</code>包含的<code>Address</code>对象已经是不同的了。</p><h2 id="什么是引用拷贝？"><a href="#什么是引用拷贝？" class="headerlink" title="什么是引用拷贝？"></a>什么是引用拷贝？</h2><p>简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/shallow&deep-copy.png" alt="shallow&amp;deep-copy"></p><h1 id="六、static类变量和类方法"><a href="#六、static类变量和类方法" class="headerlink" title="六、static类变量和类方法"></a>六、<code>static</code>类变量和类方法</h1><h2 id="6-1-静态变量（类变量）"><a href="#6-1-静态变量（类变量）" class="headerlink" title="6.1 静态变量（类变量）"></a>6.1 静态变量（类变量）</h2><p>当我们需要让某个类的所有对象都共享一个变量时，就可以使用。比如：定义学生类，统计所有学生共交多少钱。</p><h3 id="6-1-1-基本概念"><a href="#6-1-1-基本概念" class="headerlink" title="6.1.1 基本概念"></a>6.1.1 基本概念</h3><p><strong>类变量</strong>也叫<strong>静态变量&#x2F;静态属性</strong>，是该类所有对象共享的变量。任何一个该类的对象去访问或修改它时，取到的和修改的都是同一个变量。</p><h3 id="6-1-2-语法"><a href="#6-1-2-语法" class="headerlink" title="6.1.2 语法"></a>6.1.2 语法</h3><p>定义：<code>访问修饰符 static 数据类型 变量名;</code> 【推荐】  或  <code>static 访问修饰符 数据类型 变量名</code></p><p>访问：<code>类名.类变量名</code> 【推荐】或  <code>对象名.类变量名</code></p><h3 id="6-1-3-类变量特点"><a href="#6-1-3-类变量特点" class="headerlink" title="6.1.3 类变量特点"></a>6.1.3 类变量特点</h3><ol><li><code>static</code>变量是同一个类所有对象共享；</li><li><code>static</code>变量是随着类的加载而创建，只执行一次，所以没有创建对象实例也可以访问。</li><li>类变量的访问，也必须遵守相关访问权限</li><li>类变量的生命周期随着类的加载开始，随着类的消亡而销毁。</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%B1%BB%E5%8F%98%E9%87%8F.png" alt="类变量"></p><p>jdk 1.7以前（from hsp）</p><blockquote><p><strong>2024-8-3更正上图</strong>：</p><p>方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。而<strong>字符串常量池</strong>、<strong>静态变量</strong> JDK1.7 开始就从永久代（即方法区）移动到了 Java 堆中。（上图的静态域，按我理解是存储静态变量的区域）</p><p>![JDK 1.7](<a href="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK">https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK</a> 1.7.png)</p></blockquote><h2 id="6-2-静态方法（类方法）"><a href="#6-2-静态方法（类方法）" class="headerlink" title="6.2 静态方法（类方法）"></a>6.2 静态方法（类方法）</h2><p><strong>类方法</strong>也叫<strong>静态方法</strong>。实际开发往往将一些通用的方法设计成静态方法，这样就不需要创建对象就可以使用，提高开发效率。</p><h3 id="6-2-1-语法"><a href="#6-2-1-语法" class="headerlink" title="6.2.1 语法"></a>6.2.1 语法</h3><p>定义：<code>访问修饰符 static 数据返回类型 方法名() &#123; &#125;</code></p><p>调用：<code>类名.类方法名</code>  或  <code>对象名.类方法名</code></p><p>特点</p><ol><li><p>静态方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：</p></li><li><ol><li>静态方法中无this参数；</li><li>普通方法中隐含this参数</li></ol></li><li><p>静态方法可以通过类名调用，也可以通过对象名调用</p></li><li><p>静态方法不中允许使用和对象相关的关键字，比如<code>this</code>和<code>super</code>。</p></li><li><p><strong>静态方法</strong>只能访问静态成员；<strong>普通成员</strong>方法可以访问静态成员和非静态成员。</p></li></ol><h2 id="6-3-main方法"><a href="#6-3-main方法" class="headerlink" title="6.3 main方法"></a>6.3 main方法</h2><p>1）<code>main</code>方法是虚拟机（JVM）调用；</p><p>2）JVM 需要调用类得<code>main()</code>方法，所以该方法得访问权限必须是<code>public</code>；</p><p>3）JVM 在执行<code>main()</code>方法时不必创建对象，所以该方法必须是<code>static</code>；</p><p>4）该方法接收<code>String</code>类型得数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数；</p><p>5）命令：<code>java 运行的类名 arg1 arg2 arg3</code>；</p><p>6）<code>main</code>方法遵循静态方法规则。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/main%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82.png" alt="main方法传参"></p><p>示例6-1：（idea中)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个参数：&quot;</span> + args[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%A4%BA%E4%BE%8B6-1%E7%BB%93%E6%9E%9C.png" alt="示例6-1结果"></p><h1 id="七、代码块"><a href="#七、代码块" class="headerlink" title="七、代码块"></a>七、代码块</h1><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><ul><li><strong>代码块（Code block）</strong>又称为<strong>初始化块</strong>，属于类中的成员【即是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过<code>&#123;&#125;</code>包围起来。</li><li>和方法不同，代码块没有方法名、返回、参数，只有方法体。</li><li>不用通过对象或类显示调用，而是加载类的时候，或创建对象时隐式调用。</li></ul><h2 id="7-2-基本语法"><a href="#7-2-基本语法" class="headerlink" title="7.2 基本语法"></a>7.2 基本语法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[ 修饰符 ] &#123; 代码 &#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>使用<code>static</code>修饰叫<strong>静态代码块</strong>，使用<code>Synchronized</code>修饰叫<strong>同步代码块</strong>；</li><li>分号（<code>;</code>）可以省略。</li></ol><h2 id="7-3-分类"><a href="#7-3-分类" class="headerlink" title="7.3 分类"></a>7.3 分类</h2><p>根据其位置和声明的不同，可以分为：</p><ul><li>局部代码块</li><li>构造代码块</li><li>同步代码块</li><li>静态代码块</li></ul><h3 id="7-3-1-局部代码块"><a href="#7-3-1-局部代码块" class="headerlink" title="7.3.1 局部代码块"></a>7.3.1 局部代码块</h3><p>在方法中出现，可以限定变量生命周期，及早释放，提高内存利用率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 局部代码块</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(number);<br>    &#125;<br>    <span class="hljs-comment">// 找不到number变量</span><br>    <span class="hljs-comment">// System. out.println(number);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-2-构造代码块"><a href="#7-3-2-构造代码块" class="headerlink" title="7.3.2 构造代码块"></a>7.3.2 构造代码块</h3><ul><li>在类中方法外出现，每次调用构造方法都会执行，并且在构造方法前执行。</li><li>相当于另外一种形式的构造器（堆构造器的补充机制），可以做初始化操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlock</span> &#123;<br>    <span class="hljs-comment">// 构造代码块，在方法外出现</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;number1: &quot;</span> + number1);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeBlock</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在构造方法后出现，但构造代码块优先于构造方法执行</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(<span class="hljs-string">&quot;number2: &quot;</span> + number2);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//构造代码块测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">codeBlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-comment">// 注意：构造代码块通过构造方法自动调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">number1: <span class="hljs-number">10</span><br>number2: <span class="hljs-number">100</span><br>这是构造方法<br></code></pre></td></tr></table></figure><p>因此，构造代码块依赖于构造方法，而且优先于构造方法执行。即实例对象建立，才会运行构造代码块，类不能调用构造代码块。</p><p><strong>构造代码块与构造函数的区别：</strong>构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。</p><p>也就是说，<strong>构造代码块中定义的是不同对象共性的初始化内容</strong>。如果多个构造器中都有重复的语句，可以抽取到构造初始化块中，提高代码的重用性。</p><h3 id="7-3-3-同步代码块"><a href="#7-3-3-同步代码块" class="headerlink" title="7.3.3 同步代码块"></a>7.3.3 同步代码块</h3><p>被 Java 中<code>Synchronized</code>关键词修饰的代码块。</p><blockquote><p><code>Synchronized</code>关键词不仅仅可以用来修饰代码块，与此同时也可以用来修饰方法，是一种线程同步机制，被<code>Synchronized</code>关键词修饰的代码块会被加上内置锁。</p></blockquote><p><strong>作用：</strong>在很多场景，我们没有必要去同步整个方法，而只需要同步部分代码即可，也就是使用同步代码块（JDK源码中有很多应用）。</p><p><code>Synchronized</code>同步代码块是一种高开销的操作，因此我们应该尽量减少被同步的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (CodeBlock.class) &#123;<br>            System.out.print(<span class="hljs-string">&quot;同步代码块!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-type">CodeBlock</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeBlock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，静态代码是属于类而不是属于对象的，因此使用<code>Synchronized</code>来修饰静态方法和静态对象的时候，类下的所有对象都会被锁定。</p><h3 id="7-3-4-静态代码块"><a href="#7-3-4-静态代码块" class="headerlink" title="7.3.4 静态代码块"></a>7.3.4 静态代码块</h3><p>使用<code>static</code>修饰的代码块，在类中方法外出现。</p><ul><li>随着<strong>类的加载</strong>而执行，并且只会<strong>执行一次</strong>。</li><li>静态块优先于各种代码块以及构造函数。</li><li>此外静态代码块不能访问普通变量，只能直接调用静态成员。</li></ul><p><strong>作用：</strong>对类进行初始化。</p><p><strong>类什么时候被加载？</strong></p><ol><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时（静态属性、静态方法）</li></ol><h2 id="7-4-执行顺序"><a href="#7-4-执行顺序" class="headerlink" title="7.4 执行顺序"></a>7.4 执行顺序</h2><p><strong>执行时机</strong></p><ul><li><strong>静态代码块</strong>：在类加载到JVM时初始化，且只被执行一次。</li><li><strong>构造代码块</strong>：在创建实例时，会被隐式的调用。每创建一次（每调用构造方法），构造代码块就会执行一次，构造代码块执行的顺序优先于构造器。</li></ul><h3 id="7-4-1-一个类中代码块执行顺序"><a href="#7-4-1-一个类中代码块执行顺序" class="headerlink" title="7.4.1 一个类中代码块执行顺序"></a>7.4.1 一个类中代码块执行顺序</h3><p>创建一个对象时，在一个类调用顺序是：</p><ol><li>执行静态代码块和静态属性的初始化；</li><li>执行构造代码块和普通属性的初始化；</li><li>执行构造方法；</li></ol><blockquote><p>代码块和属性初始化执行优先级一样，若有多个则按照代码定义顺序执行。</p></blockquote><p><strong>总结</strong></p><p><strong>加载类信息</strong>（加载静态代码块和静态属性初始化） -&gt; <strong>创建对象</strong>（加载普通代码块和普通属性初始化） -&gt; <strong>调用构造器</strong></p><h3 id="7-4-2-继承中代码块执行顺序"><a href="#7-4-2-继承中代码块执行顺序" class="headerlink" title="7.4.2 继承中代码块执行顺序"></a>7.4.2 继承中代码块执行顺序</h3><ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序执行）；</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序执行）；</li><li>父类的构造代码块和普通属性（优先级一样，按定义顺序执行）；</li><li>父类的构造方法</li><li>子类的构造代码块和普通属性（优先级一样，按定义顺序执行）；</li><li>子类的构造方法</li></ol><p><strong>总结</strong></p><p>**加载类信息(父→子)**（加载静态代码块和静态属性初始化）-&gt; (父类)<strong>加载构造代码块和普通属性初始化</strong> -&gt; (父类)<strong>调用构造器</strong>  -&gt; (子类)<strong>加载构造代码块和普通属性初始化</strong> -&gt; (子类)<strong>调用构造器</strong></p><blockquote><p>构造器的最前面隐含了<code>super()</code>和<code>&#123;普通代码块&#125;</code>。</p></blockquote><h1 id="八、对象初始化详细过程"><a href="#八、对象初始化详细过程" class="headerlink" title="八、对象初始化详细过程"></a>八、对象初始化详细过程</h1><h2 id="8-1-一个类及其对象初始化的过程"><a href="#8-1-一个类及其对象初始化的过程" class="headerlink" title="8.1 一个类及其对象初始化的过程"></a>8.1 一个类及其对象初始化的过程</h2><h3 id="什么时候需要初始化一个类"><a href="#什么时候需要初始化一个类" class="headerlink" title="什么时候需要初始化一个类"></a>什么时候需要初始化一个类</h3><p>首次创建某个对象时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <br></code></pre></td></tr></table></figure><p>首次访问某个类的静态方法或者静态字段时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Dog.staticFields;<br></code></pre></td></tr></table></figure><p>Java 解释器就会去找类的路径，定位已经编译好的 Dog.class 文件。</p><h3 id="获得类的资源"><a href="#获得类的资源" class="headerlink" title="获得类的资源"></a>获得类的资源</h3><p>然后 jvm 就会载入 <code>Dog.class</code>，生成一个<code>class</code>对象。这个时候如果有静态的方法或者变量，静态初始化动作都会被执行。这个时候要注意啦，静态初始化在程序运行过程中只会在 Class 对象首次加载的时候运行一次。这些资源都会放在 jvm 的<strong>方法区</strong>。</p><p><strong>方法区</strong>又叫<strong>静态区</strong>，跟堆一样，被所有的线程共享。</p><p>方法区中包含的都是在整个程序中永远唯一的元素，包含所有的 class 和 static 变量。</p><h3 id="初始化对象-Dog-dog-new-Dog"><a href="#初始化对象-Dog-dog-new-Dog" class="headerlink" title="初始化对象 Dog dog = new Dog()"></a>初始化对象 <code>Dog dog = new Dog()</code></h3><ol><li>第一次创建<code>Dog</code>对象先执行上面的一二步</li><li>在堆上为<code>Dog</code>对象分配足够的存储空间，所有属性和方法都被设置成默认值(数字为 0，字符为<code>null</code>，布尔为<code>false</code>，而所有引用被设置成<code>null</code>）</li><li>执行构造函数检查是否有父类，如果有父类会先调用父类的构造函数，这里假设 <code>Dog</code> 没有父类，执行默认值字段的赋值即方法的初始化动作。</li><li>执行构造函数。</li></ol><h2 id="8-2-有父类情况下的初始化"><a href="#8-2-有父类情况下的初始化" class="headerlink" title="8.2 有父类情况下的初始化"></a>8.2 有父类情况下的初始化</h2><p>假设: <code>Dog extends Animal</code></p><ol><li>执行第一步，找出<code>Dog.class</code>文件，接着在加载过程中发现他有一个基类（通过<code>extends</code> 关键字），于是先执行<code>Animal</code>类的第一二步，加载<code>Animal</code>类的静态变量和方法，加载结束之后再加载子类<code>Dog</code>的静态变量和方法。</li></ol><p>如果<code>Animal</code>类还有父类就以此类推，最终的基类叫做根基类。</p><blockquote><p>因为子类的<code>static</code>初始化可能会依赖于父类的静态资源，所以要先加载父类的静态资源。</p></blockquote><ol><li>接着要 <code>new Dog</code> 对象，先为<code>Dog</code>对象分配存储空间 -&gt; 到<code>Dog</code>的构造函数 -&gt; 创建默认的属性。这里其构造函数里面的第一行有个隐含的<code>super()</code>，即父类构造函数，所以这时会跳转到父类<code>Animal</code>的构造函数。</li></ol><p>Java 会帮我们完成构造函数的补充，Dog 实际隐式的构造函数如下:</p><ol><li>父类<code>Animal</code>执行构造函数前也是分配存储空间 -&gt; 到其构造函数 -&gt; 创建默认的属性 -&gt; 发现已经没有父类了，这个时候就给它的默认的属性赋值和方法的初始化。</li><li>接着执行构造函数余下的部分，结束后跳转到子类<code>Dog</code>的构造函数。</li><li>子类<code>Dog</code>对默认属性和方法分别进行赋值和初始化，接着完成构造函数接下来的部分。</li></ol><p><strong>为什么要执行父类 Animal 的构造方法才继续子类 Dog 的属性及方法赋值？</strong></p><p>因为子类 Dog 的非静态变量和方法的初始化有可能使用到其父类 Animal 的属性或方法，所以子类构造默认的属性和方法之后不应该进行赋值，而要跳转到父类的构造方法完成父类对象的构造之后，才来对自己的属性和方法进行初始化。</p><p>这也是为什么子类的构造函数显示调用父类构造函数 super() 时要强制写在第一行的原因，程序需要跳转到父类构造函数完成父类对象的构造后才能执行子类构造函数的余下部分。</p><p><strong>为什么对属性和方法初始化之后再执行构造函数其他的部分？</strong></p><p>因为构造函数中的显式部分有可能使用到对象的属性和方法。</p><blockquote><p><a href="https://www.runoob.com/w3cnote/java-init-object-process.html">Java 对象初始化详细过程 | 菜鸟教程</a></p></blockquote><h2 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3 总结"></a>8.3 总结</h2><h1 id="九、内部类"><a href="#九、内部类" class="headerlink" title="九、内部类"></a>九、内部类</h1><p>一个类的内部又完整嵌套了另一个类结构，被嵌套的（里面的）类成为内部类（inner class），嵌套其他类的（外面的）类称为外部类（outer class）。</p><p>内部类是类的第五大成员【属性、方法、构造器、代码块、内部类】</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>内部类最大特点是<strong>可以直接访问私有属性</strong>，并且可以体现类与类直接的包含关系。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>定义在外部类局部位置上</strong>（比如方法内）：</p><ol><li>局部内部类（有类名）</li><li>匿名内部类（没有类名，重点!!!!!!!）</li></ol><p><strong>定义在外部类的成员位置上：</strong></p><ol><li>成员内部类（没用<code>static</code>修饰）</li><li>静态内部类（有用<code>static</code>修饰）</li></ol><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在外部类的局部位置，比如方法、代码块中，并且有类名，本质仍然是一个类。</p><p><strong>重要规则</strong></p><ol><li>不能添加访问修饰符（由于它地位就是一个局部变量，局部变量不能使用修饰符），但是可以使用final修饰。</li><li>可以直接访问外部类的所有成员。</li><li>作用域：仅仅在定义它的方法或代码块中。</li><li>局部内部类 —&gt; 访问 —&gt; 外部类成员【访问方式：直接访问】</li><li>外部类 —&gt; 访问 —&gt; 局部内部类成员【访问方式：创建对象再访问】（且必须在作用域内）示例9-1</li><li>外部其他类 — 不能访问 —&gt; 局部内部类（因为局部内部类地位相当于局部变量）</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，使用：<strong>外部类名.this.成员</strong>（本质是外部类的对象，即哪个对象调用了m1）</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>定义在外部类的局部位置，比如方法、代码块中，并且没有类名，本质仍然是一个类，同时还是一个对象</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类or接口(参数列表) &#123;<br>    类体<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>因为匿名内部类<strong>既是一个类的定义</strong>，同时也<strong>本身也是一个对象</strong>，</p><p>所以从语法上看，它既有定义类的特征，也有创建对象的特征（对前面代码分析可以看出这个特点），因此可以调用匿名内部类方法。</p><p>示例9-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousInnerClassDetail</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Outer05</span> <span class="hljs-variable">outer05</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer05</span>();<br>        outer05.f1();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer05</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;  <span class="hljs-comment">//外部类属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//外部类方法</span><br>        <span class="hljs-comment">//(1) 创建一个基于类的匿名内部类</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//可以直接访问外部类的所有成员，包括私有的</span><br>                System.out.println(<span class="hljs-string">&quot;匿名内部类重写了hi方法 n1= &quot;</span> + n1);<br>            &#125;<br>        &#125;;<br>        person.hi();  <span class="hljs-comment">//动态绑定，运行类型是 Outer05$1</span><br><br>        <span class="hljs-comment">//(2) 也可以直接调用(本质：匿名内部类本身也是返回对象)</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()&#123;<br>        &#125;.ok(<span class="hljs-string">&quot;shit&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person hi()&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ok</span><span class="hljs-params">(String str)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;输出&quot;</span> + str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重要规则（与局部内部类相似）</strong></p><ol><li>不能添加访问修饰符，因为它的地位就是一个局部变量</li><li>可以直接访问外部类的所有成员，包含私有的</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>匿名内部类 —&gt; 访问 —&gt; 外部类成员【访问方式：直接访问】</li><li>外部其他类 —&gt; 不能访问 —&gt; 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（<code>外部类名.this.成员</code>）访问</li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在外部类的成员位置，并且没有<code>static</code>修饰。</p><p><strong>重要规则</strong></p><ol><li><p>可以添加任意访问修饰符</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>成员内部类 –&gt; 访问 –&gt; 外部类成员成员【访问方式：直接访问】</p></li><li><p>外部类 –&gt; 访问 —&gt; 成员内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类 —&gt; 访问 —&gt; 成员内部类</p></li><li><ol><li>① 利用外部类创建内部类对象，再访问；【例：<code>Outer.Inner inner = outer.new Inner();</code>】（<code>**outer.new Inner();**</code> 相当于把 <code>new Inner()</code> 当作<code>outer</code>对象的成员）</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>()<br></code></pre></td></tr></table></figure><ol><li><ol><li>② 在外部类中编写一个方法，返回内部类的对象。例：</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">Inner</span> getInnerInstance() &#123;     <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();  &#125; <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.getInnerInstance();<br></code></pre></td></tr></table></figure><ol><li><ol><li>③ <code>new Outer().new Inner();</code> 相当于①，只是把<code>Outer outer = new Outer();</code> 合并了。</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>().<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>(); <span class="hljs-keyword">Outer</span> <span class="hljs-keyword">outer</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>(); <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br></code></pre></td></tr></table></figure><ol><li>如果外部类和成员内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，使用：<code>**外部类名.this.成员**</code></li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义在外部类的成员位置，有static修饰。</p><p><strong>重要规则（与成员内部类相似）</strong></p><ol><li><p>可以添加任意访问修饰符</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>作用域：和外部类的其他成员一样，为整个类体</p></li><li><p>静态内部类 –&gt; 访问 –&gt; 外部类成员【访问方式：直接访问所有的静态成员】</p></li><li><p>外部类 –&gt; 访问 —&gt; 静态内部类【访问方式：创建对象，再访问】</p></li><li><p>外部其他类 —&gt; 访问 —&gt; 成员内部类</p></li><li><ol><li>方式①：利用外部类创建内部类对象，再访问；【例：<code>Outer.Inner inner = new Outer.Inner();</code>】<code>**new Outer.Inner();**</code> 因为静态内部类是静态成员，可以直接通过类名访问</li><li>方式②：在外部类中编写一个方法，返回内部类的对象。【例：<code>public static Inner getInner() &#123; return new Inner(); &#125;``Outer.Inner inner = Outer.getInner();</code> 】（非静态也可以）</li></ol></li><li><p>如果外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，使用：<strong>外部类名.成员</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberInnerClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer08</span> <span class="hljs-variable">outer08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer08</span>();<br>        outer08.t1();<br><br>        <span class="hljs-comment">//第一种 成员内部类</span><br>        <span class="hljs-comment">//Outer08.Inner08 inner08 = outer08.new Inner08();</span><br>        <br>        <span class="hljs-comment">//第一种 静态内部类</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer08</span>.Inner08();<br><br>        <span class="hljs-comment">//第二种</span><br>        <span class="hljs-comment">//在外部类中，编写一个方法，返回 Inner08 对象</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance</span> <span class="hljs-operator">=</span> outer08.getInner08Instance();<br>        <span class="hljs-comment">//在外部类中，编写一个静态方法，返回 Inner08 对象</span><br>        Outer08.<span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08Instance_</span> <span class="hljs-operator">=</span> Outer08.getInner08Instance_();<br>        <br>        inner08Instance.say();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer08</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><br>    <span class="hljs-comment">//1.定义在外部类的成员位置上</span><br>    <span class="hljs-comment">//2.可以添加任意访问修饰符，因为它就是一个成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner08</span> &#123;  <span class="hljs-comment">//成员内部类</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">66</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;n1=&quot;</span> + n1 + <span class="hljs-string">&quot; name=&quot;</span> + name + <span class="hljs-string">&quot; 外部类n1=&quot;</span> + Outer08.n1);  <span class="hljs-comment">//直接访问所有的静态成员</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Inner08 <span class="hljs-title function_">getInner08Instance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Inner08 <span class="hljs-title function_">getInner08Instance_</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//静态方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//使用成员内部类</span><br>        <span class="hljs-type">Inner08</span> <span class="hljs-variable">inner08</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner08</span>();<br>        inner08.say();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 方法</title>
    <link href="/2022/06/07/Java-%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/07/Java-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><p><strong>方法的返回值</strong> 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p><p>按照方法的返回值和参数类型将方法分为以下几种：</p><ul><li>无参数无返回值的方法</li><li>有参数无返回值的方法</li><li>有返回值无参数的方法</li><li>有返回值有参数的方法</li></ul><h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><h3 id="1）调用方式"><a href="#1）调用方式" class="headerlink" title="1）调用方式"></a>1）调用方式</h3><p>在外部调用静态方法时，可以使用<code>类名.方法名</code>的方式，也可以使用<code>对象.方法名</code>的方式[1]，而实例方法只有<code>对象.方法名</code>这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><h3 id="2）访问类成员是否存在限制"><a href="#2）访问类成员是否存在限制" class="headerlink" title="2）访问类成员是否存在限制"></a>2）访问类成员是否存在限制</h3><ul><li>静态方法在访问本类的成员时，<strong>只允许访问静态成员</strong>（即静态成员变量和静态方法），<strong>不允许访问实例成员</strong>（即实例成员变量和实例方法）</li><li>实例方法不存在以上这个限制。</li></ul><p>[1] 不建议使用 <code>对象.方法名</code> 的方式来调用静态方法，容易混淆。静态方法不属于类的某个对象而是属于这个类。</p><h2 id="静态方法为何不能调用非静态成员"><a href="#静态方法为何不能调用非静态成员" class="headerlink" title="静态方法为何不能调用非静态成员?"></a>静态方法为何不能调用非静态成员?</h2><ul><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ul><h1 id="方法重载和重写"><a href="#方法重载和重写" class="headerlink" title="方法重载和重写"></a>方法重载和重写</h1><p><strong>重载：</strong>java 允许同一个类中，多个同名方法的存在，但要求形参列表不一致。这样，同样的一个方法能够根据输入数据的不同，做出不同的处理。（好处：减轻了起名、记名的麻烦）</p><p><strong>重写：</strong>当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法。</p><h2 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h2><p>如果多个方法（比如 <code>StringBuilder</code> 的构造方法）有<strong>相同的名字</strong>、<strong>不同的参数</strong>， 便产生了<strong>重载</strong>。</p><p><strong>规则：</strong></p><ol><li>方法名：必须相同</li><li>形参列表：必须不同（形参类型 或 个数 或 顺序，至少一种不一样，参数名无所谓）</li><li>返回类型：无要求，不是方法重载的必要条件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br></code></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好（这个过程被称为**重载解析(overloading resolution)**）。Java 允许重载任何方法， 而不只是构造器方法。</p><p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p><h2 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h2><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><p><strong>要求：</strong></p><ol><li><strong>方法名、参数列表</strong>必须相同。</li><li>子类方法<strong>返回值类型</strong>应比父类方法返回值类型更小或相等。</li><li><strong>抛出的异常范围</strong>小于等于父类。</li><li><strong>访问修饰符范围</strong>大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private</code>&#x2F;<code>final</code>&#x2F;<code>static</code> 则子类就不能重写该方法，但是被<code>static</code>修饰的方法能够被再次声明。</li><li>构造方法无法被重写。</li></ol><p><strong>综上：</strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>发生范围</td><td>同一个类</td><td>子类</td></tr><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可修改</td><td>子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td>异常</td><td>可修改</td><td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td></tr><tr><td>访问修饰符</td><td>可修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr><tr><td>发生阶段</td><td>编译期</td><td>运行期</td></tr></tbody></table><p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》，<a href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892open in new window</a> ）：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>⚠关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><h2 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h2><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是<strong>允许在调用方法时传入不定长度的参数</strong>。</p><p>比如下面这个方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，可变参数<strong>只能作为函数的最后一个参数</strong>，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(String arg1, String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><ul><li>答案是会<strong>优先匹配固定参数的方法</strong>，因为固定参数的方法匹配度更高。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableLengthArgument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String s : args) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String arg1, String arg2)</span> &#123;<br>        System.out.println(arg1 + arg2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        printVariable(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        printVariable(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">ab<br>a<br>b<br>c<br>d<br></code></pre></td></tr></table></figure><p>另外，Java 的<strong>可变参数编译后实际会被转换成一个****数组</strong>，我们看编译后生成的 class文件就可以看出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableLengthArgument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String... args)</span> &#123;<br>        String[] var1 = args;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> args.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var3 &lt; var2; ++var3) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> var1[var3];<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h1><h2 id="方法递归调用内存分析"><a href="#方法递归调用内存分析" class="headerlink" title="方法递归调用内存分析"></a>方法递归调用内存分析</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8.png" alt="方法递归调用"></p><h2 id="重要规则"><a href="#重要规则" class="headerlink" title="重要规则"></a>重要规则</h2><ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li><li>方法的局部变量是独立的，不会相互影响</li><li>如果方法中使用的是引用类型变量（比如数组、对象），就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则将无限递归，出现<code>StackOverflowError</code>，死龟了</li><li>当一个方法执行完毕，或者遇到<code>return</code>，就会返回，遵守谁调用就将结果返回给谁，同时当方法执行完毕或返回时，该方法也就执行完毕。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一般形式</span><br>func(mode)&#123;    <br>    <span class="hljs-keyword">if</span>(endCondition) &#123;      <span class="hljs-comment">//递归出口</span><br>          end;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>         func(mode_small)  <span class="hljs-comment">//调用本身，递归</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经典算法题：八皇后问题</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>在 java 编程中，主要的变量就是<strong>属性（成员变量）</strong>和<strong>局部变量</strong>。</p><h2 id="java作用域的规则"><a href="#java作用域的规则" class="headerlink" title="java作用域的规则"></a>java作用域的规则</h2><p>属性和局部变量可以重名，访问时遵循就近原则</p><h2 id="全局变量（属性-成员变量）"><a href="#全局变量（属性-成员变量）" class="headerlink" title="全局变量（属性\成员变量）"></a>全局变量（属性\成员变量）</h2><ol><li>作用域为整个整体；</li><li>可以不赋值，直接使用（因为有默认值）；</li><li><strong>生命周期较长</strong>，伴随着对象创建而创建、销毁而销毁；</li><li>可以被本类使用，或其他类使用（通过对象调用）；</li><li>可以加修饰符。</li></ol><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ol><li>一般是指在成员方法内定义的变量。（后面讲的{代码块}中的变量也是局部变量），作用域为定义它的代码块中；</li><li>必须赋值后，才能使用（因为没有默认值）；</li><li><strong>生命周期较短</strong>，伴随它的代码块的执行而创建、结束而销毁，即在一次方法调用过程中；</li><li>只能在本类对应的方法中使用；</li><li>不可以加修饰符。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>           <br>        t1.test(); <span class="hljs-comment">// 第1种跨类访问对象属性的方式</span><br><br>                t1.test2(p1); <span class="hljs-comment">// 第2种跨类访问对象属性的方式</span><br><br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(p.name);<br>    &#125;    <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(Person p)</span> &#123;<br>        System.out.println(p.name);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;kobe&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="构造方法-x2F-构造器"><a href="#构造方法-x2F-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h1><p>构造方法，是类的一种特殊方法，主要作用是完成<strong>对新对象的初始化</strong>。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">访问修饰符 方法名(形参列表) &#123; 方法体<span class="hljs-comment">; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol><li><p>没有返回值（不用也不能写void）</p></li><li><p>方法名 和 类名 相同</p></li><li><p>参数列表 和 成员方法 一样的规则</p></li><li><p>构造器是完成对象的初始化，并不是创建对象</p></li><li><p>创建对象时，系统会自动调用该类的构造器</p></li><li><p>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器），比如 Person(){}。（可使用<code>javap</code>反编译看看）</p></li><li><ol><li><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E9%BB%98%E8%AE%A4%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="默认无参构造器"></li></ol></li><li><p>一旦自定义了构造器，默认的构造器就被覆盖，就不能再使用默认的无参构造器，除非显式定义一下，即：Dog(){} </p></li><li><ol><li><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8.png" alt="有参构造器"></li></ol></li></ol><hr><p>参考</p><ul><li>韩顺平Java基础课</li><li><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">Java基础常见面试题总结(上)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基本语法</title>
    <link href="/2022/05/30/Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/05/30/Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、运算符"><a href="#一、运算符" class="headerlink" title="一、运算符"></a>一、运算符</h1><h2 id="算术运算符（重点看-x2F-）"><a href="#算术运算符（重点看-x2F-）" class="headerlink" title="算术运算符（重点看 &#x2F; % ++ ）"></a>算术运算符（重点看 &#x2F; % ++ ）</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="%运算符"></a>%运算符</h3><p><strong>作用：</strong>取模、取余</p><p><strong>本质：</strong><code>a % b = a - a / b * b</code> </p><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="++运算符"></a>++运算符</h3><p><strong>作用：</strong>自增</p><p>作为独立式使用</p><ul><li>前++和后++完全等价于<code>i = i + 1</code>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自增</span><br>i++;  <br><span class="hljs-comment">// 等价于 </span><br>++i;<br><span class="hljs-comment">// 等价于 </span><br>i = i + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>作为表达式使用</p><ul><li>前++（++i）： 先自增后赋值</li><li>后++（i++）： 先赋值后自增</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> ++j;  <span class="hljs-comment">//等价于 j=j+1; k=j; --&gt; j==9, k==9</span><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j++;  <span class="hljs-comment">//等价于 k=j; j=j+1;  --&gt; j==9, k==8</span><br></code></pre></td></tr></table></figure><p>面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//面试题1：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;             <span class="hljs-comment">//i -&gt; 1</span><br>i = i++;               <span class="hljs-comment">// 规则使用临时变量：(1)temp = i; (2)i = i + 1; (3)i = temp;</span><br>System.out.println(i)  <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">//面试题2：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;             <span class="hljs-comment">// i -&gt; 1</span><br>i = ++i;               <span class="hljs-comment">// (1)i = i + 1; (2)temp = i; (3)i = temp;</span><br>System.out.println(i)  <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// tips:自己给自己赋值要用到临时变量</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&lt;</th><th>&gt;</th><th>&lt;&#x3D;</th><th>&gt;&#x3D;</th><th>instanceof</th></tr></thead><tbody><tr><td>相等于</td><td>不等于</td><td>小于</td><td>大于</td><td>小于等于</td><td>大于等于</td><td>检查是否是类的对象</td></tr></tbody></table><p>结果都是boolean值，true 或 false</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>（1）短路与 &amp;&amp;，短路或 ||，取反 !</p><p>（2）逻辑与 &amp;，逻辑或 |，逻辑异或^</p><table><thead><tr><th>a</th><th>b</th><th>a&amp;b</th><th>a&amp;&amp;b</th><th>a|b</th><th>a||b</th><th>!a</th><th>a^b</th></tr></thead><tbody><tr><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>√</td><td>×</td><td>×</td><td>×</td><td>√</td><td>√</td><td>×</td><td>√</td></tr><tr><td>×</td><td>√</td><td>×</td><td>×</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>√</td><td>×</td></tr></tbody></table><ol><li>结果都是<code>boolean</code>值，<code>true</code> 或 <code>false</code></li><li>开发中一般使用短路操作 <code>&amp;&amp;</code> 和 <code>||</code>，效率高</li></ol><ul><li><ul><li>短路与<code>&amp;&amp;</code>：如果第一个条件为<code>false</code>，则第二个条件不会判断，最终结果为<code>false</code></li><li>短路或<code>||</code>：如果第一个条件为<code>true</code>，则第二个条件不会判断，最终结果为<code>true</code></li></ul></li></ul><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, y = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (x++==<span class="hljs-number">6</span> &amp; ++y==<span class="hljs-number">6</span>) &#123;  <span class="hljs-comment">//x先比较后自增，第一个条件为false，y先自增后比较，第二个条件为true</span><br>    x = <span class="hljs-number">11</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;x=&quot;</span> + x + <span class="hljs-string">&quot;,y=&quot;</span> + y);  <span class="hljs-comment">// x=6, y=6</span><br></code></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符就是将某个运算后的值，赋给指定的变量</p><ul><li>基本赋值运算符：<code>=</code></li><li>复合赋值运算符：<code>+=</code>，<code>-=</code>，<code>/=</code>，<code>%=</code> 等</li></ul><p>特点：</p><ol><li>左边是变量，右边可以是变量、表达式、常量值</li><li>a +&#x3D; b;  等价于 a &#x3D; a + b; 其他以此类推</li><li>复合赋值运算符会自动进行类型转换</li></ol><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>b += <span class="hljs-number">3</span>;  <span class="hljs-comment">// 等价于 b = (byte)(b + 3) </span><br>b++;     <span class="hljs-comment">// 等价于 b = (byte)(b + 1)</span><br></code></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为<code>true</code>，运算后的结果是表达式1；反之<code>false</code>结果为表达式2（口诀：一眼丁真）</p><p>示例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">24</span>;<br><br><span class="hljs-comment">// 由于true，执行了表达式1（a++），不执行表达式2（b--），</span><br><span class="hljs-comment">// 因此a先返回值给res再自增，b--不执行</span><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> a &lt; b ? a++ : b--;  <br><br>System.out.println(<span class="hljs-string">&quot;a=&quot;</span> + a + <span class="hljs-string">&quot;b=&quot;</span> + b + <span class="hljs-string">&quot;res=&quot;</span> + res)<br><span class="hljs-comment">//a=9，b=24，res=8</span><br></code></pre></td></tr></table></figure><p>细节：</p><ol><li>表达式1 和 表达式2 要为可以赋给接收变量的类型（或可以自动转换&#x2F; 或强制转换）</li><li>三元运算符本质是 if–else 语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> a &gt; b ? a++ : --b;<br>等价于<br><span class="hljs-keyword">if</span> (a &gt; b) res = a++;<br><span class="hljs-keyword">else</span> res = --b;<br></code></pre></td></tr></table></figure><p>⚠️<strong>区别：</strong></p><p>三元运算符是一个整体！if 和 else 是独立语句块！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于三元运算符是一个整体，表达式1 和 表达式2 要自动转换为同一种类型</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.0</span>);  <br>System.out.println(obj1);  <span class="hljs-comment">//输出：1.0</span><br><br><span class="hljs-comment">// 根据编译器提示： &quot;true ? new Integer(1) : new Double(2.0)&quot;   </span><br><span class="hljs-comment">// 可以简化为-&gt;  &quot;(double) new Integer(1)&quot;  </span><br><span class="hljs-comment">// 可以移除包装-&gt;   &quot;(double) 1&quot;</span><br><br><span class="hljs-comment">//---------------------------------------</span><br><br>Object obj2;<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)<br>    obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br>    obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.0</span>);<br>System.out.println(obj2);  <span class="hljs-comment">//输出：1</span><br></code></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p><h1 id="二、进制转换"><a href="#二、进制转换" class="headerlink" title="二、进制转换"></a>二、进制转换</h1><h2 id="整数的四种表达方式"><a href="#整数的四种表达方式" class="headerlink" title="整数的四种表达方式"></a>整数的四种表达方式</h2><p>二进制(BIN)：<code>0,1</code>，以<code>0b</code>或<code>0B</code>开头。                  <code>int n1 = 0b1010;</code></p><p>十进制(DEC)：<code>0-9</code>。                                  <code>int n2 = 1010;</code></p><p>八进制(OCT)：<code>0-7</code>，以数字<code>0</code>开头。                    <code>int n3 = 01010;</code></p><p>十六进制(HEX)：<code>0-9</code>及<code>A(10)-F(15)</code>；以<code>0x</code>或<code>0X</code>开头。  <code>int n4 = 0x10101;</code></p><h2 id="Java-进制转换"><a href="#Java-进制转换" class="headerlink" title="Java 进制转换"></a>Java 进制转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 十转二</span><br>bin_num = Integer.toBinaryString(dec_num);<br><span class="hljs-comment">// 十转八</span><br>oct_num = Integer.toOctalString(dec_num);<br><span class="hljs-comment">// 十转十六</span><br>hex_num = Integer.toHexString(dec_num);<br></code></pre></td></tr></table></figure><h2 id="二进制（八进制、十六进制）转十进制"><a href="#二进制（八进制、十六进制）转十进制" class="headerlink" title="二进制（八进制、十六进制）转十进制"></a>二进制（八进制、十六进制）转十进制</h2><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>2</strong>的（位数-1）次方，然后求和。</p><p>例：0b1011 &#x3D; 1 * 20 + 1 * 21 + 0 * 82 + 1 * 23 &#x3D; 1 + 2 + 0 + 8 &#x3D; 11</p><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>8</strong>的（位数-1）次方，然后求和。</p><p>例：0234 &#x3D; 4 * 80 + 3 * 81 + 2 * 82 &#x3D; 4 + 24 + 128 &#x3D; 156</p><p>从最低为（右边）开始，将每个位上的数提取出来，乘以<strong>16</strong>的（位数-1）次方，然后求和。</p><p>例：0x23A &#x3D; 10 * 160 + 3 * 161 + 2 * 162 &#x3D; 10 + 48 + 512 &#x3D; 570</p><h2 id="十进制转二进制（八进制、十六进制同理）"><a href="#十进制转二进制（八进制、十六进制同理）" class="headerlink" title="十进制转二进制（八进制、十六进制同理）"></a>十进制转二进制（八进制、十六进制同理）</h2><p>“<strong>除2取余，逆序排列</strong>”：将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来。</p><p>例：十进制34转成二进制：  &#x3D;0B00100010</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="十进制转二进制"></p><h2 id="二进制转八进制（十六进制）"><a href="#二进制转八进制（十六进制）" class="headerlink" title="二进制转八进制（十六进制）"></a>二进制转八进制（十六进制）</h2><p>从低位开始，将二进制数每三位（每四位）一组，转成对应的八进制（十六进制）数即可。</p><p>例：0b1101(D)0101(5) &#x3D; 0xD5</p><p><strong>二转十六进制诀窍：</strong>二进制每四位视为“8421”码，1101即为1个8，1个4，0个2，1个1相加，结果为13，即D</p><h2 id="八进制（十六进制）转二进制"><a href="#八进制（十六进制）转二进制" class="headerlink" title="八进制（十六进制）转二进制"></a>八进制（十六进制）转二进制</h2><p>将<strong>八进制</strong>数每1位，转成对应的一个<font color="red">3</font>位二进制数。</p><p>例：0237转成二进制：0<font color="green">2(010)</font><font color="orange">3(011)</font><font color="blue">7(111)</font> &#x3D; 0b10011111</p><p>将<strong>十六进制</strong>数每1位，转成对应的一个<font color="red">4</font>位二进制数。</p><p>例：0x23B转成二进制：0x<font color="green">2(0010)</font><font color="orange">3(0011)</font><font color="blue">B(1011)</font> &#x3D; 0b001000111011 （快速计算”B”的二进制技巧：11 &#x3D; 15(1111) - 4(0100) &#x3D; B &#x3D; 11(1011) ）</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>原码表示范围：-127~127</p><p>反码表示范围：-127~127</p><p>补码表示范围：-128~127</p><p><strong>总结</strong>：</p><ol><li>二进制的最高位是符号位：0表示正数，1表示负数（）</li><li>正数的原码、反码、补码都一样（正数三码合一）</li><li>负数的反码 &#x3D; 它的原码符号位不变，其他位取反（0-&gt;1 1-&gt;0）</li><li>负数的补码 &#x3D; 它的反码 + 1（负数的反码 &#x3D; 它的补码 - 1）（补 &#x3D; 反 + 1）</li><li>负数的原码 &#x3D; 【它的反码 符号位不变，其他位取反】 &#x3D; 【（它的补码 - 1）符号位不变，其他位取反】&#x3D; 【它的绝对值(正数)的原码符号位变为0】</li><li>负数 &#x3D; 其绝对值的原码最高位取1（原码）的 补码（原码取反+1）</li><li>0的反码、补码都是0</li><li>java没有无符号数</li><li>在计算机运算的时候，都是以补码的方式来运算的</li><li>当我们看<strong>运算结果</strong>时，要看它的原码</li></ol><p><strong>计算机中，负数表达形式</strong></p><p>负数二进制以补码形式表达，</p><ol><li>把这个负数的绝对值转换为二进制，即求原码 （ |-24| &#x3D; 24 &#x3D; 00011000 ）</li><li>把原码取反，即求反码（ ~00011000 &#x3D; 11100111 ）</li><li>把反码加1，即求补码（ 11101000 &#x3D; -24(补码) ）</li></ol><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol><li>java中7个位运算：&amp;、|、^、~、&gt;&gt;、&lt;&lt;和&gt;&gt;&gt;</li><li>按位与&amp;：两位为1，结果为1，否则为0</li><li>按位或|：有一个为1，则结果为1，否则为0</li><li>按位异或^：同0异1</li><li>按位取反~：0变1，1变0</li></ol><p><strong>示例：</strong></p><p>求<code>~-2</code>的结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(~-<span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ol><li>先得到-2的原码：10000000 00000000 00000000 00000010</li><li>再得-2的反码：  11111111 11111111 11111111 11111101（&#x3D;原码符号位不变，其他位取反）</li><li>再得-2的补码：  11111111 11111111 11111111 11111110（&#x3D;反码+1）</li><li><del>-2操作：       00000000 00000000 00000000 00000001（</del>-2：对-2的补码进行取反操作）</li><li>运算后的原码：   00000000 00000000 00000000 00000001（1）</li></ol><p><strong>示例：</strong></p><p>求<code>~2</code>的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(~<span class="hljs-number">2</span>); <span class="hljs-comment">//-3</span><br></code></pre></td></tr></table></figure><ol><li>先得到2的补码：00000000 00000000 00000000 00000010（正数三码都一样）</li><li><del>2操作：       11111111 11111111 11111111 11111101（运算后的补码）（</del>2：对2的补码进行取反操作）</li><li>运算后的反码：  11111111 11111111 11111111 11111100（负数反码 &#x3D; 它的补码-1）</li><li>运算后的原码：   10000000 00000000 00000000 00000011（-3）</li></ol><p>算术右移<code>&gt;&gt;</code>：向右移若干位，符号位不变，低位溢出丢弃，高位补符号位（符号位补溢出的高位，即正数高位补 0，负数高位补 1）</p><p><code>x &gt;&gt; n</code>，相当于 x 除以 2 的 n 次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-number">15</span>&gt;&gt;<span class="hljs-number">2</span>;<br><span class="hljs-comment">// 15 =&gt; 0000 1111 =&gt; 0000 0011 </span><br><span class="hljs-comment">// 本质 15 / 2 / 2 = 3 </span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> -<span class="hljs-number">15</span> &gt;&gt; <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 1111 0001 &gt;&gt; 0000 0010 = 1111 1100(-4)</span><br></code></pre></td></tr></table></figure><p>算术左移<code>&lt;&lt;</code>：向左移若干位，符号位不变，低位补0，高位丢弃。</p><p><code>x &lt;&lt; n</code>，相当于 x 乘以 2 的 n 次方(不溢出的情况下)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-number">4</span>&lt;&lt;<span class="hljs-number">3</span>; <br><span class="hljs-comment">//4 =&gt; 0000 0100 -&gt; 0010 0000 </span><br><span class="hljs-comment">// (本质 4 * 2 * 2 * 2 = 32) (4&lt;&lt;3 =&gt; 4 * 2^3)</span><br></code></pre></td></tr></table></figure><p>无符号右移<code>&gt;&gt;&gt;</code>：忽略符号位，空位都以0补齐。</p><p>移位操作符实际上只支持<code>int</code>和<code>long</code>类型，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p><h2 id="移位的位数超过数值所占有的位数"><a href="#移位的位数超过数值所占有的位数" class="headerlink" title="移位的位数超过数值所占有的位数"></a>移位的位数超过数值所占有的位数</h2><p>当 <code>int</code> 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。</p><p>也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0），左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。</p><p>当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p><p>也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x &gt;&gt;&gt;42</code>等同于<code>x &gt;&gt;&gt; 10</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>System.out.println(<span class="hljs-string">&quot;初始数据：&quot;</span> + i);<br>System.out.println(<span class="hljs-string">&quot;初始数据对应的二进制字符串：&quot;</span> + Integer.toBinaryString(i));<br>i &lt;&lt;= <span class="hljs-number">42</span>;  <span class="hljs-comment">// 等价于 i &lt;&lt;= 10; 42 % 32 = 10</span><br>System.out.println(<span class="hljs-string">&quot;左移 10 位后的数据 &quot;</span> + i);  <br>System.out.println(<span class="hljs-string">&quot;左移 10 位后的数据对应的二进制字符 &quot;</span> + Integer.toBinaryString(i));<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">初始数据：-<span class="hljs-number">1</span><br>初始数据对应的二进制字符串：<span class="hljs-number">11111111111111111111111111111111</span><br>左移 <span class="hljs-number">10</span> 位后的数据 -<span class="hljs-number">1024</span><br>左移 <span class="hljs-number">10</span> 位后的数据对应的二进制字符 <span class="hljs-number">11111111111111111111110000000000</span><br></code></pre></td></tr></table></figure><h2 id="问题：为何使用原码、反码、补码"><a href="#问题：为何使用原码、反码、补码" class="headerlink" title="问题：为何使用原码、反码、补码"></a>问题：为何使用原码、反码、补码</h2><p>我们上面说过，原码、反码、补码的表示对于正数来说都是一样的，而对于负数来说，三种码的表示确是完全不同的，那大家是否会有个疑问：如果原码才是我们人类可以识别并用于直接计算的表示方式，那为什么还会有反码和补码？计算机直接存储原码不就完事了？</p><p>在解决这些问题前，我们先来了解计算机的底层概念，我们人脑可以很轻松的知道机器数的第一位是符号位，但对于计算机基础电路设计来说判别第一位是符号位是非常难和复杂的事情，为了让计算机底层设计更加简单，人们开始探索将符号位参与运算，并且采用只保留加法的方法，我们知道减去一个数，等于加上这个数的负数，即：1-1 &#x3D; 1 + (-1) &#x3D; 0，这样让计算机运算就更加简单了，并且也让符号位参与到运算中去。</p><p><strong>使用原码运算</strong></p><p>计算十进制表达式：<code>1-1 = 0</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 原：[ 1000 0010 ] &#x3D; -2</p><p>如果用原码表示，让符号位也参与计算，对于减法来说，结果是不正确的。这也是计算机内部在存储数据时不使用原码的原因，为了解决这一问题，出现了反码。</p><p><strong>使用反码运算</strong></p><p>计算十进制表达式：<code>1-1 = 0</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 反：[ 0000 0001 ] + 反：[ 1111 1110 ]</p><p>&#x3D; 反：[ 1111 1111 ] &#x3D; 原： [ 1000 0000 ] &#x3D; -0</p><p>通过计算我们发现用反码计算减法，结果的真值部分是正确的。而唯一的问题出现在”0”这个特殊的数值上，虽然人们理解上**+0和-0**是一样的，但是0带符号是没有任何意义的，而且会有 [0000 0000] 原和 [1000 0000] 原两个编码表示0。为了解决这一问题，出现了补码。</p><p><strong>使用补码运算</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>- <span class="hljs-number">1</span> = <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 补：[ 0000 0001 ] + 补：[ 1111 1111 ]</p><p>&#x3D; 补： [ 0000 0000 ] &#x3D; 原： [ 0000 0000 ] &#x3D; 0</p><p>这样0用 [0000 0000] 表示，而以前出现问题的-0则不存在了，而且人们还发现可以用[1000 0000]表示-128，-128的推算过程如下：</p><p>(-1) + (-127) &#x3D; -128</p><p>&#x3D; 原：[1000 0001] + 原：[ 1111 1111 ]</p><p>&#x3D; 补：[ 1111 1111 ] + 补：[ 1000 0001 ]</p><p>&#x3D; 补：[ 1000 0000 ]</p><p><strong>注意：</strong>因为实际上是使用以前的-0的补码来表示-128，所以**-128并没有原码和反码表示**，只要补码是[1000 0000]，其十进制数值就为-128。</p><p>因为补码能多存储一个-128，而且在计算机底层中存储的是补码，所以在计算机中一个8位的二进制数的存储范围是用补码表示的[-128,127]，而不是用原码或反码表示的[-127,127]。这也可以解释为什么计算机中一个字节的取值范围是[-128,127]。</p><p>这样也能够回答我们开始提出的问题了，原码、反码、补码的使用，是人们<strong>为了让符号位能参与运算并让计算机底层运算更加简单</strong>而设计出来的数据存储表示方式。</p><h1 id="三、标识符与关键字"><a href="#三、标识符与关键字" class="headerlink" title="三、标识符与关键字"></a>三、标识符与关键字</h1><p>标识符就是一个名字。（标识符：阿牛茶餐厅、美宜佳）</p><p>关键字是被赋予特殊含义的标识符。（关键字：医院、警察局、学校…）</p><p><code>default</code>关键字</p><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul><p>⚠️ 注意：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p><p>官方文档：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java提供了四种访问控制修饰符号，用于控制方法和属性的访问权限：</p><ol><li>公开级别：用<code>public</code>修饰，对外公开；</li><li>受保护级别：用<code>protected</code>修饰，对子类和同一个包中的类公开；</li><li>默认级别：没有修饰符号，向同一个包的类公开；</li><li>私有级别：用<code>private</code>修饰，只有类本身可以访问，不对外公开。</li></ol><h3 id="访问范围"><a href="#访问范围" class="headerlink" title="访问范围"></a>访问范围</h3><table><thead><tr><th>访问级别</th><th>访问控制修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>公开</td><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>受保护</td><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>默认</td><td>-</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>私有</td><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>修饰符可以用来修饰类中的属性、成员方法以及类；</li><li>只有默认的和<code>public</code>才能修饰类，并且遵循上述访问权限的特点</li><li>子类</li><li>成员方法的访问规则和属性一样</li></ol><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>可以修饰类、属性、方法、局部变量。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>1）当不希望类被继承时；</p><p>2）不希望父类的某个方法被子类覆盖&#x2F;重写override时；</p><p>3）当不希望类的某个属性的值被修改时；</p><p>4）当不希望某个局部变量被修改时。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>1）<code>final</code>修饰的属性又叫常量，一般用XX_XX_XX命名</p><p>2）<code>final</code>修饰的属性在定义时，必须赋初值，赋值可以在类定义属性时、构造器中、代码块中；</p><p>3）如果<code>final</code>修饰的属性是静态的，则初始化的位置只能是定义时、在静态代码块中（不能在构造器中赋值）</p><p>4）如果一个类已经是<code>final</code>类，就没有必要将方法修饰成<code>final</code>了。</p><p>5）<code>final</code>不能修饰构造器。</p><p>6）<code>**final**</code><strong>和</strong><code>**static**</code><strong>往往搭配使用，不会导致类加载（底层编译器做了优化处理），效率更高</strong>。</p><p>7）包装类（<code>Integer</code>、<code>Double</code>等都是<code>final</code>），<code>String</code>也是<code>final</code>类。</p><h1 id="四、控制结构"><a href="#四、控制结构" class="headerlink" title="四、控制结构"></a>四、控制结构</h1><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><p>程序从上到下逐行执行，中间没有任何判断和跳转。</p><p>Java定义变量时采用合法的前向引用。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="分支控制if-else"><a href="#分支控制if-else" class="headerlink" title="分支控制if-else"></a>分支控制if-else</h2><p>让程序有选择的执行，分支控制有三种（单分支、双分支、多分支）</p><p>嵌套分支：分支嵌套最好不要超过3层（可读性差）</p><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单分支：当条件表达式为true时，就会执行&#123; &#125;的代码。（如果&#123;&#125;中只有一条语句，可以省略&#123;&#125;，但建议写上）</span><br><span class="hljs-keyword">if</span>(条件表达式)&#123;<br>    执行代码块;<br>&#125;<br><br><span class="hljs-comment">//双分支：当条件表达式为true时，就会执行&#123;代码块1&#125;，否则执行&#123;代码块2&#125;。（如果&#123;代码块&#125;中只有一条语句，可以省略&#123;&#125;，但建议写上）</span><br><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>    代码块<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    代码块<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">//多分支：当条件表达式1为true时，就会执行&#123;代码块1&#125;，当条件表达式1为false时，再判断条件表达式2是否成立，以此类推，都不成立则执行&#123;代码块n&#125;。（多分支可以没有else）</span><br><span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">1</span>) &#123;<br>    代码块<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123;<br>    代码块<span class="hljs-number">2</span>;<br>&#125;<br>......<br><span class="hljs-keyword">else</span> &#123;<br>    代码块n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="switch分支结构"><a href="#switch分支结构" class="headerlink" title="switch分支结构"></a>switch分支结构</h2><p><strong>规则：</strong></p><ol><li>case 语句中的<code>value</code>的数据类型必须与表达式变量的数据类型相同，而且只能是<strong>常量</strong>或者<strong>字面常量；</strong>（或是表达式可以自动转换成可以与<code>case</code>的<code>value</code>相互比较的类型。）</li><li>switch表达式中的返回值必须是：<code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code>、<code>enum</code>、<code>String</code>；</li><li>表达式对应一个值；</li><li>当变量的值与 <code>case</code> 语句的值相等时，那么 <code>case</code> 语句之后的语句开始执行，直到 <code>break</code> 语句出现才会跳出 switch 语句；</li><li><code>case</code>常量1：当表达式的值等于<code>value1</code>，就执行语句块1；如果没有匹配<code>value1</code>，就继续匹配case <code>value2</code>；如果一个都没匹配上，执行<code>default</code>；</li><li><code>case</code> 语句不必须要包含 <code>break</code> 语句。如果没有 <code>break</code> 语句出现，程序会继续执行下一条 <code>case</code> 语句，直到出现 <code>break</code> 语句。（穿透）。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (expression) &#123;<br>    <span class="hljs-keyword">case</span> value1:<br>        <span class="hljs-comment">//语句块1;  //可省略</span><br>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value2:<br>        <span class="hljs-comment">//语句块2;</span><br>    <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//default语句块;</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/switch%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="switch控制结构"></p><h2 id="for-循环控制"><a href="#for-循环控制" class="headerlink" title="for 循环控制"></a>for 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>循环初始值可以有多个，但类型必须相同；</li><li>初始化和变量迭代可以写到其他地方，但是分号不能省略；（见示例）</li><li>循环条件是布尔表达式。</li><li>循环四要素：循环变量初始化；循环条件；循环语句；循环变量迭代。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(循环变量初始化; 循环条件(布尔表达式); 循环变量迭代/更新) &#123;<br>    <span class="hljs-comment">//循环操作（可以多条）;</span><br>&#125;<br><br><span class="hljs-comment">//示例：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//变量初始化（变量i的作用域更大）</span><br><span class="hljs-keyword">for</span> (; i&lt;<span class="hljs-number">10</span>; ) &#123;<br>    System.out.println(<span class="hljs-string">&quot;shit&quot;</span> + i);<br>    i++;  <span class="hljs-comment">//变量迭代</span><br>&#125;<br><span class="hljs-comment">//补充</span><br><span class="hljs-keyword">for</span>(;;)&#123; <span class="hljs-comment">//死循环</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for-each-循环（增强for）"><a href="#for-each-循环（增强for）" class="headerlink" title="for each 循环（增强for）"></a>for each 循环（增强for）</h2><p>foreach 循环语句是 Java1.5 的新特征之一，在遍历数组、集合方面，foreach 为开发者提供了极大的方便。foreach 循环语句是 for 语句的特殊简化版本，主要用于执行遍历功能的循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (元素类型 元素变量名x : 遍历对象obj) &#123;   <span class="hljs-comment">// 快捷键：大写I + 回车</span><br>    <span class="hljs-comment">//引用了x的java语句; </span><br>&#125; <br></code></pre></td></tr></table></figure><p>其中，“类型”为元素的类型，“元素变量名”表示对象的每一个元素，“遍历对象”表示被遍历的对象，如集合。</p><p>每执行一次循环语句，循环变量就读取集合中的一个元素。</p><h2 id="while-循环控制"><a href="#while-循环控制" class="headerlink" title="while 循环控制"></a>while 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>while循环是先判断 再执行语句；</li><li>只要布尔表达式为 true，循环就会一直执行下去；</li><li>循环条件是布尔表达式；</li><li>也有循环四要素。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//循环变量初始化</span><br><span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">10</span>) &#123;  <span class="hljs-comment">//循环条件</span><br>    xxx  <span class="hljs-comment">//循环体（语句）</span><br>    i++;  <span class="hljs-comment">//循环变量迭代</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="do…while-循环控制"><a href="#do…while-循环控制" class="headerlink" title="do…while 循环控制"></a>do…while 循环控制</h2><p><strong>基本规则：</strong></p><ol><li>do while 是关键字；</li><li>先执行，再判断，也就是说，一定会至少执行一次；</li><li>也有四要素，只是位置不一样；</li><li>最后有一个分号。</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>    System.out.print(<span class="hljs-string">&quot;value of x : &quot;</span> + x ); <span class="hljs-comment">//循环体（语句）</span><br>    x++; <span class="hljs-comment">//循环变量迭代</span><br>&#125; <span class="hljs-keyword">while</span>(x &lt; <span class="hljs-number">8</span>);  <span class="hljs-comment">//(循环条件)</span><br></code></pre></td></tr></table></figure><h2 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h2><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体。</p><p>当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次循环。</p><p>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次</p><h2 id="continue、break-和-return"><a href="#continue、break-和-return" class="headerlink" title="continue、break 和 return"></a><code>continue</code>、<code>break</code> 和 <code>return</code></h2><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ol><h3 id="break-跳转控制语句"><a href="#break-跳转控制语句" class="headerlink" title="break 跳转控制语句"></a>break 跳转控制语句</h3><p>主要用在循环语句或者 switch 语句中，用来跳出整个语句块</p><p>break语句出现仔多层嵌套的语句块中时，可以通过标签指明要终止的哪一层语句块。</p><p><strong>注意事项：</strong></p><ol><li>break语句可以指定退出哪一层；</li><li>label1是标签，名字由程序员指定；</li><li>break 后指定到哪个label 就退出到哪里；</li><li>在实际开发中，尽量不要用标签；</li><li>如果没有指定，break默认退出最近的循环体。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>lable1:<br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ ) &#123;<br><br>lable2:<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ ) &#123;<br>        <span class="hljs-keyword">if</span>( j == <span class="hljs-number">2</span> )&#123;<span class="hljs-keyword">break</span>;&#125;  <span class="hljs-comment">//等价于 break lable2</span><br>        System.out.print(j);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-number">01010101</span><br><span class="hljs-comment">//（如果break label1; 则输出结果为：01）</span><br></code></pre></td></tr></table></figure><h3 id="跳转控制语句-continue"><a href="#跳转控制语句-continue" class="headerlink" title="跳转控制语句 continue"></a>跳转控制语句 continue</h3><p><strong>基本规则：</strong></p><ol><li>continue 语句用于结束本次循环，继续执行下一次循环（作用是让程序立刻跳转到下一次循环的迭代）</li><li>continue 语句出现在多层嵌套循环语句体中时，可以通过标签指明要跳过的是哪一层循环（实际开发仍不建议使用）</li><li>在 for 循环中，continue 语句使程序立即跳转到更新语句。（i++）</li><li>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。（i&gt;0）</li></ol><p><strong>基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] numbers = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br><br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i : numbers ) &#123;<br>    <span class="hljs-keyword">if</span>( i == <span class="hljs-number">4</span> ) &#123;<br>        <span class="hljs-keyword">continue</span>;    <br>    &#125;<br>    System.out.print(i);<br>&#125;<br><span class="hljs-comment">//输出：1235678</span><br></code></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><ul><li>当<code>return</code>用在方法时，表示跳出方法；</li><li>如果用在main方法，表示退出程序。</li></ul><h1 id="六、注释"><a href="#六、注释" class="headerlink" title="六、注释"></a>六、注释</h1><p>Java 中的注释有三种：</p><ul><li><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</li><li><strong>多行注释</strong>：通常用于解释一段代码的作用。（不常用）</li><li><strong>文档注释</strong>：通常用于生成 Java 开发文档。</li></ul><p>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 数据类型</title>
    <link href="/2022/05/25/Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/05/25/Java-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li><p>6 种数字类型：</p></li><li><ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li><p>1 种字符类型：<code>char</code></p></li><li><p>1 种布尔型：<code>boolean</code></p></li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th>类型</th><th>占用存储空间</th><th>默认值</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>byte</td><td>1byte</td><td>0</td><td>-27-128</td><td>27 - 1127</td></tr><tr><td>short</td><td>2byte</td><td>0</td><td>-215-32768</td><td>215 - 132767</td></tr><tr><td>int</td><td>4byte</td><td>0</td><td>-231-2147483648</td><td>231 - 12147483647</td></tr><tr><td>long</td><td>8byte</td><td>0L</td><td>-263……</td><td>263 - 1……</td></tr><tr><td>float</td><td>4byte</td><td>0.0f</td><td>-1.4E-45 -3.403E38</td><td>3.4028235E38</td></tr><tr><td>double</td><td>8byte</td><td>0.0d</td><td>-1.798E308</td><td>1.7976931348623157E308</td></tr><tr><td>char</td><td>2byte</td><td>‘u0000’</td><td>0 \u0000</td><td>65535（216- 1）\uffff</td></tr><tr><td>boolean</td><td>1bit</td><td>false</td><td>false</td><td>true</td></tr></tbody></table><p>像 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>能表示的最大正数都 <strong>-1</strong> 了。这是为什么呢？</p><p>这是因为在<strong>二进制补码表示法</strong>中，<strong>最高位是用来表示符号的</strong>（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。</p><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。</p><h2 id="整型-byte、short、int、long"><a href="#整型-byte、short、int、long" class="headerlink" title="整型 - byte、short、int、long"></a>整型 - byte、short、int、long</h2><p><code>byte</code>：字节（1byte）：8位、有符号的，以二进制补码表示的整数</p><p><code>short</code>：短整型（2byte）：16 位、有符号的，以二进制补码表示的整数</p><p><code>int</code>：整型（4byte）：32位、有符号的，以二进制补码表示的整数</p><p><code>long</code>：长整型（8byte）：64 位、有符号的，以二进制补码表示的整数</p><h3 id="整型的使用细节"><a href="#整型的使用细节" class="headerlink" title="整型的使用细节"></a>整型的使用细节</h3><ol><li>Java 的整型常量默认为 <code>int</code> 型，声明 long 型常量须在后加<code>l</code>或<code>L</code>；</li><li>Java 程序中变量声常明为 <code>int</code> 型，除非不足以表示大数，才使用 <code>long</code>；</li><li><code>bit</code>: 计算机中的最小存储单位。 <code>byte</code>: 计算机中基本存储单元，<code>1byte = 8bit</code>。</li></ol><h2 id="浮点型-float、double"><a href="#浮点型-float、double" class="headerlink" title="浮点型 - float、double"></a>浮点型 - float、double</h2><p><code>float</code>：4byte：单精度、32位、符合IEEE 754 标准的浮点数</p><p><code>double</code>：8byte：双精度、64 位、符合 IEEE 754 标准的浮点数</p><h3 id="浮点型使用细节"><a href="#浮点型使用细节" class="headerlink" title="浮点型使用细节"></a>浮点型使用细节</h3><ol><li>浮点数在机器中存放形式，浮点数 &#x3D; 符号位 + 指数位 + 尾数位</li><li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li><li>浮点数默认为<code>double</code>类型，声明<code>float</code>型须在后面加上<code>f</code>或<code>F</code>。（数值加<code>d</code>表示<code>double</code>类型）</li><li>浮点数有两种表示形式：</li></ol><ul><li><ul><li>十进制数形式：如5.12 512.0f .512</li><li>科学计数法形式：如5.12e2（5.12*10^2）</li><li>科学记数法：结尾的”E+数字”表示E之前的数字要乘以10的多少次方。比如，3.14E-3就是3.14 x 10-3 &#x3D;0.00314。</li></ul></li></ul><ol><li>通常使用<code>double</code>型，精度更高</li><li>比较浮点数的时候，不能使用“<code>==</code>”操作符。（计算机 内存存储浮点数使用IEEE754标准，存在精度问题，在存储计算过程中容易引起较小的舍入误差）</li></ol><ul><li><ul><li>使用Math.abs() 方法来计算两个浮点数之间差异的绝对值，如果这个差异在阈值范围之内，我们就认为两个浮点数是相等的。如：Math.abs(num1 - num2) &lt; 0.0001</li><li>使用 BigDecimal 类的 compareTo() 方法对两个数进行比较，该方法将会忽略小数点后的位数。见示例1。（比如说 2.0 和 2.00 的位数不同，但它俩的值是相等的）</li></ul></li></ul><p><strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;2.0&quot;</span>);<br><br>System.out.println(a.equals(b));  <span class="hljs-comment">//false</span><br>System.out.println(a.compareTo(b) == <span class="hljs-number">0</span>);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="字符型-char"><a href="#字符型-char" class="headerlink" title="字符型 - char"></a>字符型 - char</h2><p><code>char</code>：2byte：单一的 16 位 Unicode 字符</p><h3 id="字符型使用细节"><a href="#字符型使用细节" class="headerlink" title="字符型使用细节"></a>字符型使用细节</h3><ol><li><code>char</code>用单引号<code>&#39; &#39;</code>，<code>String</code>字符串用双引号<code>&quot; &quot;</code></li><li>转义字符 ‘<code>\</code>‘ ，将其后的字符转变为特殊字符型常量。如：<code>char c = &#39;\n&#39;</code></li><li>Java 中，<code>char</code>本质是一个整数，输出时是 unicode 编码对应的字符（因此可直接赋值<code>char</code>一个整数）</li></ol><ul><li><ul><li>Unicode与中文之间的相互转换工具：<a href="https://www.w3cschool.cn/tools/index?name=unicode_chinese">在线Unicode&#x2F;中文转换工具 - 编码转换工具 - W3Cschool</a></li><li><a href="http://tool.chinaz.com/Tools/Unicode.aspx">Unicode编码转换 - 站长工具</a></li></ul></li></ul><ol><li>由3.可得，<code>char</code>类型可进行运算。</li><li>字符型存储到计算机中，需要找到字符对应的码值（整数），比如<code>&#39;a&#39;</code>：</li></ol><ul><li><ul><li>存储：<code>&#39;a&#39;</code> –&gt; 码值 97 –&gt; 二进制 0110 0001 –&gt; 存储</li></ul></li></ul><ol><li>字符编码表：</li></ol><ul><li><ul><li>- ASCII 编码表 1 个字节表示，一个128个字符（实际上一个字节可以表示256个字符，只用了128个）</li><li>Unicode 编码表 固定大小的编码，使用 2 个字节表示，字母和汉字统一占用 2 个字节（但这样浪费空间）。（Unicode兼容ASCII）</li><li>utf-8 编码表：大小可变的编码，使用1-6个字节表示一个符号，字母使用 1 个字节，汉字使用 3 个字节（实际开发用得最多）（Unicode的改进方式，互联网使用最广）</li><li>gbk 可以表示汉字，范围广，字母使用 1 个字节，汉字使用 2 个字节</li><li>gb2312 可以表示汉字，gb2312 &lt; gbk</li><li>big5 码，繁体中文，tw hk</li></ul></li></ul><h2 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型 - boolean"></a>布尔型 - boolean</h2><p><code>boolean</code>：1bit： 1 位，作为一种标志来记录 true&#x2F;false 情况</p><p>（准确讲是1byte，计算机处理数据的最小单位是 1 个字节）</p><p>事实上：boolean 占用多少字节取决于虚拟机本身的实现，《Java 虚拟机规范》提议：</p><ul><li>如果 boolean 是 “单独使用”：boolean 被编译为 int 类型，占 4 个字节</li><li>如果 boolean 是以 “boolean 数组” 的形式使用：boolean 占 1 个字节</li></ul><h3 id="布尔型细节"><a href="#布尔型细节" class="headerlink" title="布尔型细节"></a>布尔型细节</h3><ol><li>Java中不可以用 0 或者非 0 整数替代 false 和 true，这点和C、php等语言不同。</li></ol><h1 id="Java-类型转换"><a href="#Java-类型转换" class="headerlink" title="Java 类型转换"></a>Java 类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>自动类型转换：</strong>低精度数据类型 自动转换为 高精度数据类型：</p><ul><li>char –&gt; int –&gt; long –&gt; float –&gt; double</li><li>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</li></ul><p><strong>示例2</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span>;  <span class="hljs-comment">//true char --&gt; int</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;  <span class="hljs-comment">//true int --&gt; double</span><br></code></pre></td></tr></table></figure><h3 id="自动类型转换细节"><a href="#自动类型转换细节" class="headerlink" title="自动类型转换细节"></a>自动类型转换细节</h3><ol><li>多种类型得数据混合运算时，系统自动将所有数据转换成精度（容量）最大的数据类型，然后再进行计算：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1.2</span>;  <span class="hljs-comment">//double 11.2</span><br></code></pre></td></tr></table></figure><ol><li>当把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错。</li><li>（<code>byte</code>, <code>short</code>） 和 <code>char</code> 之间不会相互自动转换。</li><li><code>byte</code>, <code>short</code>, <code>char</code> 三者可以计算，在计算时首先转换为 <code>**int**</code> 类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b1 + s;     <span class="hljs-comment">// √ 因为：b1 + s =&gt; int</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> b1 + b2;  <span class="hljs-comment">// × 因为：b1 + b3 =&gt; int</span><br></code></pre></td></tr></table></figure><ol><li>boolean 不参与转换</li><li>自动提升原则：表达式结果的类型自动提升为<strong>操作数中最大的类型</strong>。</li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。需要加上强制转换符()，但可能造成精度降低或溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(s + b);  <span class="hljs-comment">//由于(s+b)=&gt;int，因此要强制转换成short才不报错</span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型和String类型的转换"><a href="#基本数据类型和String类型的转换" class="headerlink" title="基本数据类型和String类型的转换"></a>基本数据类型和String类型的转换</h3><ol><li><strong>基本类型转String类型</strong></li></ol><p>方法：直接拼接个双引号””</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><ol><li><strong>String类型转基本类型</strong></li></ol><p>方法：通过基本类型的包装类调用<code>parseXX</code>方法即可（每一个基本类型都对应一个包装类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;24&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br></code></pre></td></tr></table></figure><p><code>String</code>转换成<code>char</code> &#x3D;&#x3D;&gt; 得到字符串的第一个字符 （利用<code>charAt(n)</code>方法，将字符串的第<code>n</code>个字符取出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(s.charAt(<span class="hljs-number">0</span>))  <span class="hljs-comment">//s.charAt(0) 得到字符串s的第一个字符&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure><ol><li><strong>注意</strong></li></ol><ul><li>将<code>String</code>类型转成基本数据类型时，要确保<code>String</code>类型能够转成有效的数据，比如可以把<code>&quot;123&quot;</code>转成一个整数，但是不能把<code>&quot;shit&quot;</code>转成一个整数。</li><li>如果格式不正确，就会抛出异常，程序终止。</li></ul><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><ul><li>在进行基本的数据计算时，开发者可以直接使用基本数据类型。</li><li>但是当需要和Java其他对象结合使用，如存入集合中，就需要将基础数据类型实例封装为Java对象，</li><li>为了面向对象的这一特性，基本数据类型中的每一个类型在<code>java.lang</code>包中都有一个包装类，即将每个基本类型都包装成了一个类。八种基本类型对应包装类：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</li></ul><hr><table>    <tr>        <td>基本数据类型</td>        <td>包装类</td>        <td>接口</td>        <td>父类</td>        <td>接口</td>        <td>父类</td>    </tr>    <tr>        <td>boolean</td>        <td>Boolean</td>        <td rowspan="8">Comparable</td>        <td rowspan="2">—</td>        <td rowspan="8">Serializable</td>        <td rowspan="8">Object</td>    </tr>    <tr>        <td>char</td>        <td>Character</td>    </tr>    <tr>        <td>byte</td>        <td>Byte</td>        <td rowspan="6">Number</td>    </tr>    <tr>        <td>short</td>        <td>Short</td>    </tr>    <tr>        <td>int</td>        <td>Integer</td>    </tr>    <tr>        <td>long</td>        <td>Long</td>    </tr>    <tr>        <td>float</td>        <td>Float</td>    </tr>    <tr>        <td>double</td>        <td>Double</td>    </tr></table><h2 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h2><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中 [1]。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p>[1] 为什么说是<strong>几乎</strong>所有对象实例都存在于堆中呢？ </p><p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>更多参考：<a href="https://www.yuque.com/kingshit/java/khlmi9x1su7i6vr6">JIT逃逸分析</a></p><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 成员变量，存放在堆中</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">// 被 static 修饰，也存放在堆中，但属于类，不属于对象</span><br>    <span class="hljs-comment">// JDK1.7 静态变量从永久代移动了 Java 堆中</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 局部变量，存放在栈中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>; <span class="hljs-comment">// 编译错误，不能在方法中使用 static 修饰局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本数据类型和包装类转换"><a href="#基本数据类型和包装类转换" class="headerlink" title="基本数据类型和包装类转换"></a>基本数据类型和包装类转换</h2><ol><li>jdk5 前的手动装箱和拆箱方式。（装箱：基本类型 -&gt; 包装类型；拆箱：包装类型 -&gt; 基本类型）</li><li>jdk5 及以后的自动装箱和拆箱方式。</li><li>自动装箱底层调用的是<code>valueOf</code>方法，比如<code>Integer.valueOf()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer3</span> <span class="hljs-operator">=</span> n2;<br><span class="hljs-comment">//底层使用的是 Integer.valueOf(n2); </span><br><span class="hljs-comment">// valueOf本质是 当在 -128~127 时，直接返回；否则 new Integer(i); 详见</span><br><br><span class="hljs-comment">//自动拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> integer3;<br><span class="hljs-comment">//底层使用的是 integer2.intValue()，return integer3对象的value</span><br></code></pre></td></tr></table></figure><h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p><strong>装箱：</strong>将基本类型用它们对应的引用类型包装起来</p><p><strong>拆箱：</strong>将包装类型转换为基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱 等价于 Integer i = Integer.valueOf(10)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱 等价于 int n = i.intValue();</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><h2 id="浮点数运算的精度丢失风险"><a href="#浮点数运算的精度丢失风险" class="headerlink" title="浮点数运算的精度丢失风险"></a>浮点数运算的精度丢失风险</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.8f</span> - <span class="hljs-number">1.7f</span>;<br>System.out.println(a);  <span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);  <span class="hljs-comment">// 0.099999905</span><br>System.out.println(a == b);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>原因：</strong>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><p>更多内容详见：<a href="https://www.yuque.com/kingshit/wz61vk/yxked8f04twgtmnl">浮点数</a></p><h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到<strong>货币</strong>的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.00&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(c);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.2 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.20 */</span><br><span class="hljs-comment">// 比较内容，不是比较值</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* false */</span><br><span class="hljs-comment">// 比较值相等用compareTo，相等返回0</span><br>System.out.println(<span class="hljs-number">0</span> == x.compareTo(y)); <span class="hljs-comment">/* true */</span><br></code></pre></td></tr></table></figure><p>关于 <code>BigDecimal</code> 的详细介绍，参考：<a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a>。</p><h2 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h2><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><p>在 Java 中，64 位 long 整型是最大的整数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span><br>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h2 id="String类型和包装类转换"><a href="#String类型和包装类转换" class="headerlink" title="String类型和包装类转换"></a>String类型和包装类转换</h2><p>包装类（Integer 为例） -&gt; String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//方式一</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;  <br><span class="hljs-comment">//底层创建一个基于i对象的值的String对象，i对象的类型并没有改变</span><br><br><span class="hljs-comment">//方式二</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> i.toString();  <span class="hljs-comment">//</span><br><br><span class="hljs-comment">//方式三</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> String.valueOf(i);  <br><span class="hljs-comment">//底层还是跟方式二一样调用toString： </span><br><span class="hljs-comment">// return (obj == null) ? &quot;null&quot; : obj.toString()</span><br></code></pre></td></tr></table></figure><p>String -&gt; 包装类（Integer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-comment">//方式一：调用包装类的转换方法parseXxx()</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.parseInt(str);  <span class="hljs-comment">//底层：调用parseInt(s, 10); 参数radix:10表示输出十进制整数</span><br><br><span class="hljs-comment">//方式二：调用Integer构造器</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(str);  <span class="hljs-comment">//底层还是跟方式一一样：this.value = parseInt(s, 10); </span><br></code></pre></td></tr></table></figure><h2 id="包装类缓存机制"><a href="#包装类缓存机制" class="headerlink" title="包装类缓存机制"></a>包装类缓存机制</h2><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128, 127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0, 127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p><strong>所有整型包装类对象之间值的比较，全部使用</strong> <code>**equals**</code> <strong>方法比较。</strong></p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br>    System.out.println(i1 == j2);  <span class="hljs-comment">// false  new出来的是不同的对象</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 底层调用valueOf方法，当传入参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;              <span class="hljs-comment">// 等价于 Integer i4 = Integer.valueOf(127)</span><br>    System.out.println(i3 == i4);  <span class="hljs-comment">// true</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 底层调用valueOf方法，当传入参数不在 -128~127 范围时，直接创建新对象。</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i6</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;               <span class="hljs-comment">// 同上</span><br>    System.out.println(i5 == i6);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i7</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// 从数组里面取值，属于数组对象</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);  <span class="hljs-comment">// new出来的新对象</span><br>    System.out.println(i7 == i8);   <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i9</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;               <span class="hljs-comment">// Integer对象</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i10</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;                  <span class="hljs-comment">// 基本数据类型</span><br>    System.out.println(i9 == i10);  <span class="hljs-comment">// true  只要有基本数据类型，就是判断值是否相等!!!</span><br><br>    <span class="hljs-comment">// 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。</span><br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    <span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>    System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br>    <br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i13</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">i14</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>    System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>valueOf()</code>源码：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/valueOf%E6%BA%90%E7%A0%81.png" alt="valueOf源码"></p><p><strong>解读：</strong></p><ul><li>当传入的参数在 -128~127 范围时，不创建新对象直接返回cache数组对应的值。</li><li>当传入的参数不在 -128~127 范围时，直接创建新对象。</li></ul><p><code>**IntegerCache.cache**</code><strong>数组（部分）</strong>：</p><p>该数组由包装类<code>Integer</code>创建，大小为 256，存储了 -128~127</p><p><strong>Character</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">isDigit</span><span class="hljs-params">()</span></span>`方法：确定指定的字符是否为数字，返回`boolean<br></code></pre></td></tr></table></figure><p>示例：判断字符串是否都为数字组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断一个字符串是否都为数字组成</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>        <span class="hljs-keyword">if</span> ( !(Character.isDigit(str.charAt(i))) ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础概念</title>
    <link href="/2022/05/24/Java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/05/24/Java-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE-EE-ME"><a href="#Java-SE-EE-ME" class="headerlink" title="Java SE EE ME"></a>Java SE EE ME</h1><p>Java SE 就是标准版，包含标准的 JVM 和标准库</p><p>Java EE 是企业版，它只是在 Java SE 的基础上加上了大量的 API 和库，以便方便开发 Web 应用、数据库、消息服务等。</p><p>Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Java%E7%89%88%E6%9C%AC.png" alt="Java版本"></p><h1 id="JVM-amp-JDK-amp-JRE"><a href="#JVM-amp-JDK-amp-JRE" class="headerlink" title="JVM &amp; JDK &amp; JRE"></a>JVM &amp; JDK &amp; JRE</h1><p><strong>JVM（Java Virtual Machine, Java 虚拟机）</strong>并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p><p>维基百科上就有常见 JVM 的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">Comparison of Java virtual machinesopen in new window</a> ，感兴趣的可以去看看。并且，你可以在 <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specificationsopen in new window</a> 上找到各个版本的 JDK 对应的 JVM 规范。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JVM%E6%A8%A1%E5%9E%8B.png" alt="JVM模型"></p><p><strong>JDK（Java Development Kit）</strong>是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，还包含了 javac（编译 java 源码的编译器）以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p><p><strong>JRE（Java Runtime Environment）</strong>是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p><h2 id="JDK、JRE-和-JVM-的包含关系"><a href="#JDK、JRE-和-JVM-的包含关系" class="headerlink" title="JDK、JRE 和 JVM 的包含关系"></a>JDK、JRE 和 JVM 的包含关系</h2><p>JDK &#x3D; JRE + 开发工具集（例如 javac，java 编译工具等）</p><p>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）</p><p>如果只想运行开发好的<code>.class</code>文件，只需要 JRE。</p><p>但对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/JDK.png" alt="JDK"></p><p>不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ <a href="http://openjdk.java.net/jeps/282">jlink</a> 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。详见： <a href="https://javaguide.cn/java/new-features/java9.html">Java 9 新特性概览</a>。</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>官网：<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p><h2 id="配置环境变量path"><a href="#配置环境变量path" class="headerlink" title="配置环境变量path"></a>配置环境变量path</h2><ol><li>环境变量 - 系统变量 - 添加 JAVA_HOME 环境变量，指向 jdk 的安装目录 <code>D:\Program Files\jdk8\jdk1.8.0_333</code></li><li>编辑 path 环境变量，增加 <code>%JAVA_HOME%\bin</code></li><li>为了确保 jre（运行）在你使用 javaIDE 的时候不产生问题，新增配置 <code>%JAVA_HOME%\jre\bin</code></li></ol><p>windows 操作系统是如何搜索硬盘上某个命令？</p><ol><li>首先会从当前目录下搜索</li><li>当前目录搜索不到的话，会从环境变量path指定的路径当中搜索某个命令</li><li>如果都搜索不到，则报错</li></ol><h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><p>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><h1 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h1><ol><li>Java 源码本质上是一个文本文件，需要先用<code>javac</code>把 Xxx.java 编译成字节码文件 Xxx.class，然后，用<code>java</code>命令执行这个字节码文件</li><li>给虚拟机（JVM）传递的参数<code>Hello</code>是我们定义的类名，JVM 会启动<strong>类加载器（ClassLoader）</strong>，ClassLoader 会自动查找对应的 class 文件装载到 JVM 中执行。</li><li>JVM 将 Xxx.class 字节码文件解释成二进制数据。</li><li>操作系统执行二进制和底层硬件平台进行交互。</li></ol><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C.png" alt="编译与运行"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol><li>编译阶段主要的任务是检查 Java 源程序是否符合Java语法</li><li>符合 Java 语法则生成正常的字节码文件（<code>xxx.class</code>）</li></ol><p>字节码文件中不是纯粹的二进制，这种文件无法在操作系统中直接执行。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac Hello.java<br></code></pre></td></tr></table></figure><ol><li>java 源文件，通过编译器编译成JVM可识别的字节码文件</li><li>通过<code>javac.exe</code>编译工具对<code>Hello.java</code>文件进行编译</li><li>若程序没错，则没有任何提示，并在源文件同目录出现一个<code>Hello.class</code>文件，该文件称为字节码文件，是可以执行的 java 程序</li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>java.exe</code>主要负责运行阶段</p><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java Hello<br></code></pre></td></tr></table></figure><ol><li>有了可执行的 java 程序（<code>.class</code>字节码文件）</li><li>通过运行工具<code>java.exe</code>对字节码文件进行执行，本质是<code>.class</code>装载到 JVM 执行</li></ol><p>注：dos控制台默认简体中文 GBK 编码，若源码有中文，则需要以 chinese 编码保存</p><h2 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h2><ol><li>Java应用程序的执行入口是main()方法。有固定书写格式：public static void main(String[] args){…}</li><li>Java语言严格区分大小写。</li><li>类首字母大写。</li><li>一个源文件中最多只有一个public类。其他类个数不限。[示例1]</li><li>如果源文件中包含一个public类，则文件名必须按该类名命名。</li><li>也可以将mian方法写在非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法。[示例1]</li></ol><p>示例1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;yo my nigga!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编译后，每个类都对应一个.class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是皮蛋&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>&#125;<br># 编译 <span class="hljs-keyword">public</span> 类命名的文件<br>javac Hello.java <br><br># 运行里面的 Cat 类<br>java Cat <br></code></pre></td></tr></table></figure><p>在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p><p>　　1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。</p><p>　　2.public类的名称必须完全与含有该编译单元的文件名相同，包含大小写。如果不匹配，同样将得到编译错误。</p><p>　　3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。</p><p>一个编译单元（java文件）可以存在多个类，在编译时产生多个不同的<code>.class</code>文件， <code>.class</code>文件便是程序运行的数据来源。</p><p>java 将 public 类作为每个编译单元的数据接口，只能有一个，不然不能处理存在多个类的 java 文件。当一个编译单元（java文件）有多个非 public 类时，运行时需要对数据来源进行选择。</p><h2 id="Java-API文档"><a href="#Java-API文档" class="headerlink" title="Java API文档"></a>Java API文档</h2><p>API（Application Programming Interface）是Java提供的基本编程接口（java提供的类和相关方法）。中文在线文档：<a href="https://www.matools.com/">https://www.matools.com</a></p><h1 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h1><p>高级编程语言按照程序的执行方式分为两种：</p><ul><li>编译型：编译型语言open in new window 会通过编译器open in new window将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li><li>解释型：解释型语言open in new window会通过解释器open in new window一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li></ul><p><code>.class -&gt; 机器码</code>这一步：</p><ul><li><strong>JVM 类加载器</strong>首先加载<code>.class</code>字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</li></ul><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 <strong>JIT（Just in Time Compilation） 编译器</strong>，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong>。</p><p>🌈 拓展：<a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">有关 JIT 的实现细节: JVM C1、C2 编译器</a></p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B-%E5%9B%BE%E7%89%87%E6%9D%A5%E8%87%AAJavaGuide.png" alt="Java程序转变为机器代码的过程-图片来自JavaGuide"></p><p>Java程序转变为机器代码的过程</p><p>HotSpot 采用了<strong>惰性评估（Lazy Evaluation）</strong>的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h1 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h1><h2 id="什么是AOT？"><a href="#什么是AOT？" class="headerlink" title="什么是AOT？"></a>什么是AOT？</h2><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><p>JIT 与 AOT 两者的关键指标对比：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/AOTvsJIT.png" alt="AOTvsJIT"></p><p>可以看出，AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。</p><p>提到 AOT 就不得不提 GraalVMopen in new window 了！GraalVM 是一种高性能的 JDK（完整的 JDK 发行版本），它可以运行 Java 和其他 JVM 语言，以及 JavaScript、Python 等非 JVM 语言。 GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译。感兴趣的同学，可以去看看 GraalVM 的<a href="https://www.graalvm.org/latest/docs/">官方文档</a>。如果觉得官方文档看着比较难理解的话，也可以找一些文章来看看，比如：</p><ul><li><a href="https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw">基于静态编译构建微服务应用</a></li><li><a href="https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/%E8%B5%B0%E5%90%91-native-%E5%8C%96springdubbo-aot-%E6%8A%80%E6%9C%AF%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/">走向 Native 化：Spring&amp;Dubbo AOT 技术示例与原理讲解</a></li></ul><h2 id="为什么不全部使用-AOT-呢？"><a href="#为什么不全部使用-AOT-呢？" class="headerlink" title="为什么不全部使用 AOT 呢？"></a>为什么不全部使用 AOT 呢？</h2><p><strong>既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？</strong></p><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。</p><p>除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</p><p>举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p><h1 id="Oracle-JDK-vs-OpenJDK"><a href="#Oracle-JDK-vs-OpenJDK" class="headerlink" title="Oracle JDK vs OpenJDK"></a>Oracle JDK vs OpenJDK</h1><p>首先，2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。</p><p>其次，对于 Java 7 而言，OpenJDK 和 Oracle JDK 是十分接近的。 Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。</p><p>下面这段话摘自 Oracle 官方在 2012 年发表的一个博客：</p><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p><p>最后，简单总结一下 Oracle JDK 和 OpenJDK 的区别：</p><ul><li><strong>是否开源</strong>：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的（个人观点：众所周知，JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司，Oracle 公司以 Oracle 数据库而著名，而 Oracle 数据库又是闭源的，这个时候 Oracle 公司就不想完全开源了，但是原来的 SUN 公司又把 JDK 给开源了，如果这个时候 Oracle 收购回来之后就把他给闭源，必然会引起很多 Java 开发者的不满，导致大家对 Java 失去信心，那 Oracle 公司收购回来不就把 Java 烂在手里了吗！然后，Oracle 公司就想了个骚操作，这样吧，我把一部分核心代码开源出来给你们玩，并且我要和你们自己搞的 JDK 区分下，你们叫 OpenJDK，我叫 Oracle JDK，我发布我的，你们继续玩你们的，要是你们搞出来什么好玩的东西，我后续发布 Oracle JDK 也会拿来用一下，一举两得！）OpenJDK 开源项目：<a href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdkopen in new window</a> 。</li><li><strong>是否免费</strong>：Oracle JDK 会提供免费版本，但一般有时间限制。JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用。不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。</li><li><strong>功能性</strong>：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。</li><li><strong>稳定性</strong>：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。</li><li><strong>协议</strong>：Oracle JDK 使用 BCL&#x2F;OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ul><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类（详见Java API文档）</li><li>控制访问范围</li></ol><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ol><li>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package</li><li>import 指令位置放在 package 下面，在类定义前面，可以有多句且没有顺序要求</li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明</span><br><span class="hljs-keyword">package</span> com.rwj;  <br><span class="hljs-comment">// package关键字：表示打包</span><br><span class="hljs-comment">// com.rwj：表示包名</span><br><br><span class="hljs-comment">// 导入/引入</span><br><span class="hljs-keyword">import</span> java.util.Scanner;  <span class="hljs-comment">//表示只会引入java.util包下的Scanner类</span><br><span class="hljs-keyword">import</span> java.util.*;  <span class="hljs-comment">//表示将java.util包下的所有类都引入</span><br></code></pre></td></tr></table></figure><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>创建不同的目录&#x2F;文件夹来保存类文件。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>只能包含数字、字母、下划线、小圆点，不能用数字开头，不能是关键字或保留字</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.公司名.项目名.业务模块名<br></code></pre></td></tr></table></figure><p><code>com.sina.crm.user</code> &#x2F;&#x2F;用户模块</p><p><code>com.sina.crm.order</code> &#x2F;&#x2F;订单模块</p><p><code>com.sina.crm.utils</code> &#x2F;&#x2F;工具类</p><h2 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h2><p><code>java.lang.*</code>：lang 包是基本包，默认引入，不需要再手动引入</p><p><code>java.util.*</code>：util 包，系统提供的工具包，工具类，使用 Scanner</p><p><code>java.net.*</code>：网络包，网络开发</p><p><code>java.awt.*</code>：做 java 界面开发，GUI</p><hr><p>参考</p><p><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">Java基础常见面试题总结(上)</a></p><p><a href="https://liaoxuefeng.com/books/java/quick-start/history/index.html">Java历史 - Java教程 - 廖雪峰的官方网站</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux性能监控</title>
    <link href="/2022/02/22/Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <url>/2022/02/22/Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU监控相关命令"><a href="#CPU监控相关命令" class="headerlink" title="CPU监控相关命令"></a>CPU监控相关命令</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h2><p>Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况及总体状况。实时显示系统中各个进程的资源占用状况及总体状况。</p><h2 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a><code>mpstat</code></h2><p>实时系统监控工具，它会报告与多核心CPU相关的统计信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install sysstat -y<br>mpstat 1 <span class="hljs-comment">#每隔一秒输出CPU占用情况</span><br></code></pre></td></tr></table></figure><h1 id="内存监控相关命令"><a href="#内存监控相关命令" class="headerlink" title="内存监控相关命令"></a>内存监控相关命令</h1><h2 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a><code>free</code>命令</h2><p>可以用来快速查看主机的内存使用情况，包括了物理内存和虚拟内存。后面可以加上参数：<code>-h</code>和<code>-m</code>，否则默认会以<code>kb</code>为单位显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">free -h<br></code></pre></td></tr></table></figure><p>相关参数说明:</p><ul><li><code>total</code>：物理内存大小，就是机器实际的内存</li><li><code>used</code>：已使用的内存大小，这个值包括了 cached 和 应用程序实际使用的内存</li><li><code>free</code>：未被使用的内存大小</li><li><code>shared</code>：共享内存大小，是进程间通信的一种方式</li><li><code>buffers</code>：被缓冲区占用的内存大小</li><li><code>cached</code>：被缓存占用的内存大小</li></ul><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a><code>vmstat</code></h2><p>vmstat（Virtual Meomory Statistics，虚拟内存统计）是对系统的整体情况进行统计，包括内核进程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息。命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmstat 2 100<br></code></pre></td></tr></table></figure><p>其中<code>2</code>表示刷新间隔，<code>100</code>表示输出次数。</p><h1 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h1><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p><code>sar</code>是一个在Unix和Linux操作系统中用来收集、报告和保存 CPU、内存、输入输出端口使用情况的命令。SAR 命令可以动态产生报告，也可以把报告保存在日志文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sar -n DEV 3 100<br></code></pre></td></tr></table></figure><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p><code>netstat</code>命令一般用于检验本机各端口的网络连接情况，用于显示与 IP、TCP、UDP 和 ICMP 协议相关的统计数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -aup <span class="hljs-comment"># 输出所有UDP连接状况</span><br>netstat -atp <span class="hljs-comment"># 输出所有TCP连接状况</span><br>netstat -s <span class="hljs-comment"># 显示各个协议的网络统计信息</span><br>netstat -i <span class="hljs-comment"># 显示网卡列表</span><br>netstat -r <span class="hljs-comment"># 显示路由表信息</span><br></code></pre></td></tr></table></figure><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p><code>tcpdump</code>是最广泛使用的网络包分析器或者包监控程序之一，它用于捕捉或者过滤网络上指定接口上接收或者传输的TCP&#x2F;IP包。格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install tcpdump -y<br>tcpdump -i eth0 -c 3<br></code></pre></td></tr></table></figure><p>该命令不是系统自带的，可能需要自己搬运安装。命令执行效果如下：</p><h1 id="磁盘监控"><a href="#磁盘监控" class="headerlink" title="磁盘监控"></a>磁盘监控</h1><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a><code>iostat</code></h2><p><code>iostat</code>是一个用于收集显示系统存储设备输入和输出状态统计的简单工具。这个工具常常用来追踪存储设备的性能问题，其中存储设备包括设备、本地磁盘，以及诸如使用NFS等的远端磁盘。常用格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iostat -x -k 2 100 <span class="hljs-comment"># 2表示刷新间隔，100表示刷新次数</span><br></code></pre></td></tr></table></figure><h2 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a><code>iotop</code></h2><p><code>iotop</code>命令是一个用来监视磁盘I&#x2F;O使用状况的 top 类工具。iotop 具有与 top 相似的UI，其中包括PID、用户、I&#x2F;O、进程等相关信息。Linux 下的IO统计工具如 iostat，nmon 等大多数是只能统计到 per 设备的读写情况，如果你想知道每个进程是如何使用 IO 的就比较麻烦，使用<code>iotop</code>命令可以很方便的查看。</p><h1 id="全系统监控"><a href="#全系统监控" class="headerlink" title="全系统监控"></a>全系统监控</h1><p>上面分享的都是单个查看 Linux 系统磁盘、CPU、内存等指标的工具，如果我们想要迅速找出来主机的性能瓶颈所在，我们可以采用以下全能工具：</p><h2 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h2><p>Glances 是一个用来监视 GNU&#x2F;Linux 和 FreeBSD 操作系统的 GPL 授权的免费软件，通过 Glances，我们可以监视 CPU，平均负载，内存，网络流量，磁盘 I&#x2F;O，其他处理器 和 文件系统 空间的利用情况。</p><p>Glances 会用一下几种颜色来代表状态： 绿色：OK（一切正常） 蓝色：CAREFUL（需要注意） 紫色：WARNING（警告） 红色：CRITICAL（严重）。</p><p>阀值可以在配置文件中设置，一般阀值被默认设置为（careful&#x3D;50、warning&#x3D;70、critical&#x3D;90）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install glances -y<br>glances<br></code></pre></td></tr></table></figure><h2 id="dstat工具"><a href="#dstat工具" class="headerlink" title="dstat工具"></a>dstat工具</h2><p>dstat命令是一个用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具。与sysstat相比，dstat拥有一个彩色的界面，在手动观察性能状况时，数据比较显眼容易观察；而且dstat支持即时刷新，譬如输入dstat 3即每三秒收集一次，但最新的数据都会每秒刷新显示。</p><p>直接使用<code>dstat</code>，默认使用的是<code>-cdngy</code>参数，分别显示 cpu、disk、net、page、system 信息，默认是1s显示一条信息。可以在最后指定显示一条信息的时间间隔，如<code>dstat 5</code>是每5s显示一条，<code>dstat 5 10</code>表示每5s显示一条，一共显示10条。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install dstat -y<br>dstat 5 10<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux远程登录SSH</title>
    <link href="/2022/02/16/Linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95SSH/"/>
    <url>/2022/02/16/Linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95SSH/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-远程登录SSH"><a href="#Linux-远程登录SSH" class="headerlink" title="Linux 远程登录SSH"></a>Linux 远程登录SSH</h1><p>Linux一般作为服务器使用，这时我们就需要远程登录到Linux服务器来管理维护系统。</p><p>Linux系统中是通过ssh服务实现的远程登录功能，默认ssh服务端口号为 22。</p><h2 id="从Linux终端利用登录远程服务器"><a href="#从Linux终端利用登录远程服务器" class="headerlink" title="从Linux终端利用登录远程服务器"></a>从Linux终端利用登录远程服务器</h2><p>安装<code>ssh</code>并启动<code>ssh</code>服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#apt install openssh-server &amp;&amp; service sshd start</span><br><span class="hljs-comment">#右侧实验区系统已经安装</span><br></code></pre></td></tr></table></figure><p>终端下使用<code>ssh</code>登录远程服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在右侧实验区，尝试从本地登陆本地</span><br>ssh -p 22 root@127.0.0.1<br></code></pre></td></tr></table></figure><ul><li><code>-p**</code> 后面是端口，默认不指定的话是22</li><li><code>username </code>是服务器用户名，</li><li><code>127.0.0.1</code>是本地服务器 ip，也可以是远程服务器的IP。</li></ul><p>回国后会出现如下类似提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">The authenticity of host <span class="hljs-string">&#x27;127.0.0.1 (127.0.0.1)&#x27;</span> can<span class="hljs-string">&#x27;t be established.</span><br><span class="hljs-string">ECDSA key fingerprint is SHA256:8c69pPPyheuR4qjFit+ZSz47G8mfgKYXRrPFex6Vcj4.</span><br><span class="hljs-string">Are you sure you want to continue connecting (yes/no)?</span><br></code></pre></td></tr></table></figure><p>回车输入<code>yes</code>后，输入实验区提示的密码<code>&#123;host0.token&#125;</code>即可重复登录云环境本身。</p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="1、查看SSH客户端版本"><a href="#1、查看SSH客户端版本" class="headerlink" title="1、查看SSH客户端版本"></a>1、查看SSH客户端版本</h3><p>有的时候需要确认一下 SSH 客户端及其相应的版本号。使用<code>ssh -V</code>命令可以得到版本号。需要注意的是，Linux 一般自带的是 OpenSSH:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -V<br></code></pre></td></tr></table></figure><h3 id="2、连接到远程主机"><a href="#2、连接到远程主机" class="headerlink" title="2、连接到远程主机"></a>2、连接到远程主机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh name@remoteserver<br></code></pre></td></tr></table></figure><p>说明：<code>remoteserver</code>代表远程主机，<code>name</code>为登录远程主机的用户名。</p><h3 id="3、连接到远程主机指定的端口"><a href="#3、连接到远程主机指定的端口" class="headerlink" title="3、连接到远程主机指定的端口"></a>3、连接到远程主机指定的端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh name@remoteserver -p 2222<br></code></pre></td></tr></table></figure><p>说明：<code>p</code>参数指定端口号，通常在路由里做端口映射时，我们不会把22端口直接映射出去，而是转换成其他端口号，这时就需要使用<code>-p</code>端口号命令格式。</p><h3 id="4、通过远程主机1跳到远程主机2"><a href="#4、通过远程主机1跳到远程主机2" class="headerlink" title="4、通过远程主机1跳到远程主机2"></a>4、通过远程主机1跳到远程主机2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -t remoteserver1 ssh remoteserver2<br></code></pre></td></tr></table></figure><p>说明：当远程主机<code>remoteserver2</code>无法直接到达时，可以使用-t参数，然后由<code>remoteserver1</code>跳转到<code>remoteserver2</code>。在此过程中要先输入<code>remoteserver1</code>的密码，然后再输入<code>remoteserver2</code>的密码，然后就可以操作<code>remoteserver2</code>了。</p><h3 id="5、通过SSH运行远程shell命令"><a href="#5、通过SSH运行远程shell命令" class="headerlink" title="5、通过SSH运行远程shell命令"></a>5、通过SSH运行远程shell命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -l name remoteserver <span class="hljs-string">&#x27;linux-command&#x27;</span><br></code></pre></td></tr></table></figure><p>说明：连接到远程主机，并执行远程主机的 linux 命令。</p><p>例如：查看远程主机的内存使用情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@localhost free -G<br></code></pre></td></tr></table></figure><h3 id="6、修改SSH监听端口"><a href="#6、修改SSH监听端口" class="headerlink" title="6、修改SSH监听端口"></a>6、修改SSH监听端口</h3><p>默认情况下，SSH监听连接端口22，攻击者使用端口扫描软件就可以看到主机是否运行有SSH服务，将SSH端口修改为大于1024的端口是一个明智的选择，因为大多数端口扫描软件（包括nmap）默认情况都不扫描高位端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>并查找下面这样的行：<code>Port 22</code> 去掉该行前面的# 号，然后修改端口号并重新启动SSH服务：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic">service ssh restart<br></code></pre></td></tr></table></figure><h3 id="7、仅允许SSH协议版本2"><a href="#7、仅允许SSH协议版本2" class="headerlink" title="7、仅允许SSH协议版本2"></a>7、仅允许SSH协议版本2</h3><p>有两个SSH协议版本，仅使用SSH协议版本2会更安全，SSH协议版本1有安全问题，包括中间人攻击（man-in-the-middle）和注入（insertion）攻击。编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>文件并查找下面这样的行： # Protocol 2，1 修改为 Protocol 2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service ssh restart<br></code></pre></td></tr></table></figure><h3 id="8、禁止root用户登录"><a href="#8、禁止root用户登录" class="headerlink" title="8、禁止root用户登录"></a>8、禁止root用户登录</h3><p>通常情况下，不采用直接用<code>root</code>用户登录到远程主机，由于<code>root</code>用户拥有超级权限，这样会带来安全隐患，所以，一般我们用普通用户登录，当需要管理远程主机时，再切换到<code>root</code>用户下。打开<code>/etc/ssh/sshd_config</code>文件并查找下面这样的行：</p><p><code>#PermitRootLogin yes</code> 将<code>#</code>号去掉，然后将<code>yes</code>修改成<code>no</code>，重启<code>ssh</code>服务，这样就可以禁止<code>root</code>用户登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/ssh/sshd_config<br>service ssh restart<br></code></pre></td></tr></table></figure><h3 id="9、进行端口映射"><a href="#9、进行端口映射" class="headerlink" title="9、进行端口映射"></a>9、进行端口映射</h3><p>假如公司内网有台 web 服务器，但是只对内不对外，这样，外网就无法访问，可以用<code>ssh</code>进行端口映射来实现外网访问内网的 web 服务器。</p><p>假如 web 服务器名为<code>webserver</code>，<code>webserver</code>可以用<code>ssh</code>访问到远端主机<code>remoteserver</code>，登录到<code>webserver</code>，然后用下面命令进行映射 命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -R 3000:localhost:80 remoteserver<br></code></pre></td></tr></table></figure><p>执行完成后，在<code>remoteserver</code>机器上，执行<code>netstat -an | grep 3000</code>，查看有没有开通<code>3000</code>端口。并执行以下命令观察是否可以打开<code>webserver</code>上的网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://127.0.0.1:3000<br></code></pre></td></tr></table></figure><p>如果能打开界面，说明映射成功。但是，这只限于本机访问web服务器，即只能<code>remoteserver</code>机器访问<code>webserver</code>。因为<code>3000</code>端口绑定的是<code>remoteserver</code>机器的<code>127.0.0.1</code>端口。</p><p>可以编辑<code>remoteserver</code>机器上的<code>/etc/ssh/sshd_config</code>文件并添加如下内容： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GatewayPorts <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>把监听端口<code>3000</code>绑定到<code>0.0.0.0</code>地址上，这样外部的所有机器都能访问到这个监听端口，然后保存退出。并重启<code>ssh</code>服务。完成后其它机器就可以在浏览器中输入 <code>http://remoteserver:3000</code>来访问<code>webserver</code>了。</p><h3 id="10、设置登录时提示信息"><a href="#10、设置登录时提示信息" class="headerlink" title="10、设置登录时提示信息"></a>10、设置登录时提示信息</h3><p>首先编辑一个文件，如<code>bannertest.txt</code>，文件内容自行定义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;my welcome info&#x27;</span> &gt; /welcome.text<br>vim /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>然后打开文件并查找下面这样的行： <code>#Banner /some/path</code></p><p>将<code>#</code>号去掉，然后将<code>bannertest.txt</code>文件的全路径替换<code>/welcome.text</code>，然后保存，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">service ssh restart<br>ssh root@localhost<br></code></pre></td></tr></table></figure><p>重启<code>ssh</code>服务。当客户端登录时，就会看到<code>bannertest.txt</code>文件中的提示信息。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件</title>
    <link href="/2022/02/15/Linux%E6%96%87%E4%BB%B6/"/>
    <url>/2022/02/15/Linux%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-文件"><a href="#Linux-文件" class="headerlink" title="Linux 文件"></a>Linux 文件</h1><p>Linux文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。</p><p>在Linux中普通文件和目录文件保存在称为块物理设备的磁盘或者磁带上。一套Linux系统支持若干物理盘，每个物理盘可定义一个或者多个文件系统。（类比于微机磁盘分区）。每个文件系统由逻辑块的序列组成，一个逻辑盘空间一般划分为几个用途各不相同的部分，即引导块、超级块、inode区以及数据区等。</p><h2 id="文件管理的常用命令"><a href="#文件管理的常用命令" class="headerlink" title="文件管理的常用命令"></a>文件管理的常用命令</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><code>touch</code>命令可以创建空文件，或者改变文件的时间戳属性</p><p><strong>练习：使用touch命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> a.txt <span class="hljs-comment">#创建一个名为a.txt的空文件</span><br><span class="hljs-built_in">ls</span>  <span class="hljs-comment">#查看文件是否创建成功</span><br> <br><span class="hljs-built_in">touch</span> -d `<span class="hljs-built_in">date</span>` a.txt <span class="hljs-comment">#修改a.txt最后的修改时间</span><br></code></pre></td></tr></table></figure><h3 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h3><p><code>cat</code> 由第一行开始显示文件内容<br><code>tac</code> 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！<br><code>nl</code> 显示的时候，顺道输出行号！<br><code>more</code> 一页一页的显示文件内容<br><code>less</code> 与 more 类似，但是比 more 更好的是，他可以往前翻页！<br><code>head</code> 只看头几行<br><code>tail</code> 只看尾巴几行</p><p><code>cat</code> 是一个命令，除了主要用来查看文件；</p><p><strong>练习</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/uptime<br><span class="hljs-built_in">cat</span> /proc/version<br></code></pre></td></tr></table></figure><p>还可以与<code>&lt;&lt;END</code>连用用于读入大段数据。输入<code>cat &lt;&lt;END</code>之后，回车，会看到终端出现一个大于号，大于号后面可以输入内容，再回车，继续输入内容，直到我们输入<code>END</code> (大写的，与上面一致)，输入过程结束，我们输入的内容都显示在了屏幕上。</p><p><strong>练习</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">END</span><br><span class="hljs-string">a</span><br><span class="hljs-string">bc</span><br><span class="hljs-string">END</span><br></code></pre></td></tr></table></figure><p>两个有意思的命令，tac: 文件翻转；rev每列反转</p><p><strong>练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">END | tac</span><br><span class="hljs-string">first</span><br><span class="hljs-string">second</span><br><span class="hljs-string">third</span><br><span class="hljs-string">END</span><br></code></pre></td></tr></table></figure><p><strong>练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">END | rev</span><br><span class="hljs-string">abcde</span><br><span class="hljs-string">xyz</span><br><span class="hljs-string">END</span><br></code></pre></td></tr></table></figure><p><strong>练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ll &gt;&gt; ll.txt  <span class="hljs-comment">#将命令屏幕输出结果保存至文件ll.txt</span><br><span class="hljs-built_in">cat</span> ll.txt<br><span class="hljs-built_in">tac</span> ll.txt<br><span class="hljs-built_in">head</span> ll.txt<br></code></pre></td></tr></table></figure><h3 id="文件元信息查看"><a href="#文件元信息查看" class="headerlink" title="文件元信息查看"></a>文件元信息查看</h3><p><code>stat</code>命令可以显示详细的文件的属性状态信息</p><p><strong>练习</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> <span class="hljs-built_in">test</span><br><span class="hljs-built_in">stat</span> <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">stat</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="find查找文件"><a href="#find查找文件" class="headerlink" title="find查找文件"></a><code>find</code>查找文件</h3><p><strong>练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find *.txt /<br></code></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure><h2 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，</p><p>返回结果的第一列会类似<code>drwxrwxrwx</code>，其中第一个字符的含义如下</p><table><thead><tr><th><strong>标志</strong></th><th><strong>对应</strong></th></tr></thead><tbody><tr><td>-</td><td>文件</td></tr><tr><td>d</td><td>Directory 目录</td></tr><tr><td>l</td><td>Linking File 链接文档</td></tr><tr><td>b</td><td>Block Device 可随机存取的块设备,即可供储存的接口设备()</td></tr><tr><td>c</td><td>Charset Device 串行端口设备，键盘、鼠标(一次性读取装置)</td></tr><tr><td>s</td><td>Socket 套接字文件</td></tr></tbody></table><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定，从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。</p><p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中，第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p><p><strong>练习：观察linux下文件的标志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ll /usr/bin <span class="hljs-comment">#对结果进行观察</span><br>ll /dev <span class="hljs-comment">#对结果进行观察</span><br>ll /run <span class="hljs-comment">#对结果进行观察</span><br></code></pre></td></tr></table></figure><h3 id="改变文件属性命令"><a href="#改变文件属性命令" class="headerlink" title="改变文件属性命令"></a>改变文件属性命令</h3><p><code>chown</code>：更改文件属主，也可以同时更改文件属组 <code>chgrp</code>：更改文件属组 <code>chmod</code>：更改文件9个属性</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux介绍</title>
    <link href="/2022/02/11/Linux%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/02/11/Linux%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h2 id="Linux与UNIX的渊源"><a href="#Linux与UNIX的渊源" class="headerlink" title="Linux与UNIX的渊源"></a>Linux与UNIX的渊源</h2><p>Linux 和 UNIX 之间的关系是一个很有意思的话题。在目前主流的服务器端操作系统中，UNIX 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 UNIX 是操作系统中的”老大哥”，后来的 Windows 和 Linux 都参考了 UNIX。</p><h2 id="Linux系统组成"><a href="#Linux系统组成" class="headerlink" title="Linux系统组成"></a>Linux系统组成</h2><ul><li><strong>Linux系统内核</strong>，提供系统最核心的功能，如：调度cpu、内存、文件系统、网络通讯、IO等。</li><li><strong>系统级应用程序</strong>，可理解为出厂自带程序，可供用户快速上手操作系统，如：文件管理器、任务管理器、图片查看等。</li></ul><p>系统程序、第三方程序都是调用内核，内核再负责调度硬件完成相关指令。即：</p><p>使用者界面（Shell，KDE，application） → 内核（Kernel） → 硬件（Hardware）</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Linux%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90.png" alt="Linux系统组成"></p><h3 id="Linux-内核"><a href="#Linux-内核" class="headerlink" title="Linux 内核"></a>Linux 内核</h3><p>内核免费开源，源码地址：<a href="https://www.kernel.org/">https://www.kernel.org</a></p><h3 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h3><p>内核无法被用户直接使用，在内核之上，封装系统级应用程序，组合起来就称为Linux发行版。</p><h1 id="Windows-使用-Linux"><a href="#Windows-使用-Linux" class="headerlink" title="Windows 使用 Linux"></a>Windows 使用 Linux</h1><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>步骤：</p><ol><li>下载安装激活 VMware-workstation pro 软件</li><li><a href="https://www.centos.org/download/">下载</a> CentOS7 系统镜像</li><li>在 VMware-workstation 安装 CentOS7 系统</li></ol><h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>VMware虚拟机支持为虚拟机制作快照，通过快照将当前虚拟机的状态保存下来，以后可以通过快照快速恢复虚拟机到保存状态。</p><p>制作并还原快照：右键 - 快照 - 快照管理器 - 拍摄快照（制作）； 选择快照 - 转到（还原）</p><h2 id="远程连接-Linux"><a href="#远程连接-Linux" class="headerlink" title="远程连接 Linux"></a>远程连接 Linux</h2><p>由于虚拟机系统与windows系统交互不便，因此一般使用第三方终端模拟软件远程控制Linux终端。</p><p>常用：Xshell、FinalShell（hostbuf.com）……</p><h3 id="关于图形化"><a href="#关于图形化" class="headerlink" title="关于图形化"></a>关于图形化</h3><p>Linux从诞生至今，在图形化页面的优化上，并未重点发力。所以Linux操作系统的图形化页面：不好用、不稳定</p><p>在开发中，使用命令行形式，效率更高，更加直观，并且资源占用低，程序运行更稳定。</p><h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><p><strong>WSL（Windows Subsystem for Linux）</strong>是用于 Windows 系统上的Linux子系统，是Win10的新特性。</p><p>直连计算机硬件，无需通过虚拟机虚拟硬件</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/Win10-WSL.png" alt="Win10-WSL"></p><p>部署流程：</p><ol><li>启用：设置 - 应用和功能 - 程序和功能 - 启用或关闭 Windows 功能 - 勾选 适用于 Linux 的 Windows 子系统</li><li>安装：Microsoft Store - 获取 Ubuntu</li><li>其他：自带的终端窗口不好用，可以去应用商店获取使用 Windows Terminal 软件</li></ol><h1 id="初始Linux系统"><a href="#初始Linux系统" class="headerlink" title="初始Linux系统"></a>初始Linux系统</h1><p>登录Linux系统后，呈现在眼前的是这样一个界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">root@KingShit:~#<br></code></pre></td></tr></table></figure><ul><li><code>root</code>：用户名</li><li><code>KingShit</code>：登陆计算机的主机名</li><li><code>@</code>：用户名与主机名的分隔符</li><li><code>~</code>：代表<code>root</code>用户的<code>home</code>目录,，在我们其它路径后，这处会跟着改变</li><li><code>#</code>：用来指示根用户输入命令的地方；对普通用户来说一般是<code>$</code></li></ul><h1 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h1><p>Linux 目录结构是树型结构，只有一个顶级目录：根目录”&#x2F;“。</p><h1 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h1><p>命令本质是系统内置的程序，无论是什么命令，在Linux中，都有其通用格式：<code>command [-options] [parameter]</code>（<code>命令 选项 参数</code>）</p><ul><li><p><code>-options</code>：可选，命令的一些选项，可以通过选项控制命令的行为细节</p></li><li><p><code>parameter</code>：可选，命令参数，多用于命令的指向目标等</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gzip炸弹—埋雷与拆弹</title>
    <link href="/2022/01/26/gzip%E7%82%B8%E5%BC%B9%E2%80%94%E2%80%94%E5%9F%8B%E9%9B%B7%E4%B8%8E%E6%8B%86%E5%BC%B9/"/>
    <url>/2022/01/26/gzip%E7%82%B8%E5%BC%B9%E2%80%94%E2%80%94%E5%9F%8B%E9%9B%B7%E4%B8%8E%E6%8B%86%E5%BC%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="对于反爬虫—如何埋炸弹"><a href="#对于反爬虫—如何埋炸弹" class="headerlink" title="对于反爬虫—如何埋炸弹"></a>对于反爬虫—如何埋炸弹</h1><p>前提：知道某个请求是爬虫发来的了，你不满足于单单屏蔽对方，而是想搞死对方。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p><em>Requests 文档中的 Binary Response Content[1] 这一小节，看到这样一句话：</em></p><p><em>The gzip and deflate transfer-encodings are automatically decoded for you.</em></p><p><em>（Request）会自动为你把 gzip 和 deflate 转码后的数据进行解码</em></p></blockquote><p>网站服务器可能会使用 gzip 压缩一些大资源，这些资源在网络上传输的时候，是压缩后的二进制格式。客户端收到返回以后，如果发现返回的 Headers 里面有一个字段叫做 Content-Encoding，其中的值包含 gzip，那么客户端就会先使用 gzip 对数据进行解压，解压完成以后再把它呈现到客户端上面。浏览器自动就会做这个事情，用户是感知不到这个事情发生的。而 requests、Scrapy 这种网络请求库或者爬虫框架，也会帮你做这个事情，因此你不需要手动对网站返回的数据解压缩。</p><p>文件之所以能压缩，是因为里面有大量重复的元素，这些元素可以通过一种更简单的方式来表示。压缩的算法有很多种，其中最常见的一种方式，我们用一个例子来解释。</p><p>假设有一个字符串，它长成下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br>1111111111111111<br></code></pre></td></tr></table></figure><p>我们可以用5个字符来表示：192个1。这就相当于把192个字符压缩成了5个字符，压缩率高达97.4%。</p><p>如果我们可以把一个1GB的文件压缩成1MB，那么对服务器来说，仅仅是返回了1MB的二进制数据，不会造成任何影响。但是对客户端或者爬虫来说，它拿到这个1MB的数据以后，就会在内存中把它还原成1GB的内容。这样一瞬间爬虫占用的内存就增大了1GB。如果我们再进一步增大这个原始数据，那么很容易就可以把爬虫所在的服务器内存全部沾满，轻者服务器直接杀死爬虫进程，重则爬虫服务器直接死机。</p><h2 id="制造炸弹"><a href="#制造炸弹" class="headerlink" title="制造炸弹"></a>制造炸弹</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Linux</span><br>dd if=/dev/zero bs=1M count=1000 | gzip &gt; boom.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">macOS</span><br>dd if=/dev/zero bs=1048576 count=1000 | gzip &gt; boom.gz<br></code></pre></td></tr></table></figure><p>生成的这个 boom.gz 文件只有 995KB：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/boom%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%8F%AA%E6%9C%89995K.png" alt="boom压缩文件只有995K"></p><p>使用 <code>gzip -d boom.gz</code> 命令解压后发现生成了一个 1GB 的 boom 文件：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%AB%9F%E6%9C%891G.png" alt="解压后竟有1G"></p><p>把命令里面的<code>count=1000</code>改成一个更大的数字，就能得到更大的文件。</p><h1 id="对于爬虫—如何避免踩炸弹"><a href="#对于爬虫—如何避免踩炸弹" class="headerlink" title="对于爬虫—如何避免踩炸弹"></a>对于爬虫—如何避免踩炸弹</h1><h2 id="①-隐藏自己"><a href="#①-隐藏自己" class="headerlink" title="① 隐藏自己"></a>① 隐藏自己</h2><p>把你的爬虫隐藏起来，因为gzip炸弹只能在发现了爬虫以后使用，否则就会影响到正常用户。只要你的爬虫让网站无法发现，那么自然就不会踩中炸弹。</p><p>…</p><h2 id="②-识别出gzip炸弹"><a href="#②-识别出gzip炸弹" class="headerlink" title="② 识别出gzip炸弹"></a>② 识别出gzip炸弹</h2><p>当你不读取resp.content、resp.text的时候，Requests是不会擅自给你解压缩的，如下图所示。因此你可以放心查看Headers：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%85%88%E6%89%93%E5%8D%B0header%E7%9C%8B%E7%9C%8B.png" alt="先打印header看看"></p><p>如果发现网站返回的内容确实是 gzip 压缩后的内容，如何做到既不解压缩，又能获取到解压以后的大小？</p><p>如果你本地检查一个<code>.gz</code>文件，那么你可以使用命令<code>gzip -l xxx.gz</code>来查看它的头信息：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B4%E4%BF%A1%E6%81%AF.png" alt="查看文件头信息"></p><p>打印出来的数据中，第一个数字是压缩后的大小，第二个数字是解压以后的大小，第三个百分比是压缩率。这些信息是储存在压缩文件的头部信息中的，不用解压就能获取到。</p><p>那么当我使用Requests的时候，如何获得压缩后的二进制数据，防止它擅自解压缩？方法其实非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">resp = requests.get(url, stream=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(resp.raw.read())<br></code></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E5%8E%8B%E7%BC%A9%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F.png" alt="压缩后的二进制数据大小"></p><p>这个大小是压缩后的二进制数据的大小。</p><p>可以使用如下代码，在不解压的情况下，查询到解压缩后的文件大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">resp = requests.get(url, stream=<span class="hljs-literal">True</span>)<br><br>decompressed = resp.raw.read()<br><span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(io.BytesIO(decompressed), <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> g:<br>    g.seek(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    origin_size = g.tell()<br>    <span class="hljs-built_in">print</span>(origin_size)<br></code></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://pub-e9bde05ffea74978a0ce3b387e7ee1fd.r2.dev/2024/08/%E6%9F%A5%E7%9C%8B%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9A%84%E5%A4%A7%E5%B0%8F.png" alt="查看解压后的大小"></p><p><strong>总结</strong></p><p>判断 resp.headers 中，是否有一个名为 content-encoding，值包含 gzip 或 deflate 的字段。</p><ul><li><p>不包含？</p></li><li><ul><li>不是gzip炸弹</li></ul></li><li><p>包含？</p></li><li><ul><li>不解压的情况下，查询到解压缩后的文件大小：</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gzip<br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> requests<br>resp = requests.get(url, stream=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 获得压缩后的二进制数据</span><br>decompressed = resp.raw.read()<br><span class="hljs-comment"># </span><br><span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(io.BytesIO(decompressed), <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> g:<br>    g.seek(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    origin_size = g.tell()<br>    <span class="hljs-built_in">print</span>(origin_size)<br></code></pre></td></tr></table></figure><hr><p>文章来源：</p><p><a href="https://mp.weixin.qq.com/s/Lzo6Pm09XsOqPkz3O91Mgg">一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>网络爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
